Hello - from /home/vincent/.vscode/extensions/jaredly.reason-vscode-1.7.8/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/vincent/workspace%20vscodium/prolog.ml","languageId":"ocaml","version":1,"text":"open List\n\ntype terme = \n\t| Var of string\n\t| Func of string * terme list\n\ntype regle = terme list\n\n\nlet rec substituer_var terme var s =\n\tmatch terme with\n\t| Var(x) -> if x = var then s else Var(x)\n\t| Func(f, []) -> Func(f, []) \n\t| Func(f, args) -> Func(f, (map (function t -> (substituer_var t var s)) args))\n\n\nlet rec imprime_list l = \n\tmatch l with\n\t| [] -> ()\n\t| h::t -> (imprime h ; imprime_list t)\nand imprime = function\n\t| Var(x) -> ( print_string \" \"; print_string x; print_string \" \" )\n\t| Func(f, []) -> ( print_string \" \"; print_string f ; print_string \" \" )\n\t| Func (f, args) -> ( print_string \"(\"; print_string f; imprime_list args; print_string \")\" )\n\t \n\nlet rec imprime_sigma = function\n\t| [] -> ()\n\t| (a,b)::t -> (imprime a; print_string \"<-> \"; imprime b;  print_string \"\\n\"; imprime_sigma t ) ;;\n\t\nlet valeur_subst sigma var =\n\ttry assoc var sigma\n\twith Not_found -> var\n\t\nlet domaine_subst sigma =\n\tconcat_map  (function (x,v) -> if x = (valeur_subst sigma x) then [] else [x]) sigma\n\nlet rec substituer terme sigma  =\n\tmatch terme with\n\t| Var(x) -> (valeur_subst sigma terme)\n\t| Func(f, []) -> Func(f, []) \n\t| Func(f, args) -> Func(f, (map (function t -> (substituer t sigma)) args))\n\nlet rec sublis sigma l =\n\tmatch l with\n\t| [] -> []\n\t| h::t -> (substituer h sigma) :: (sublis sigma t)\n\nlet rec union e1 e2 =\n\tmatch e1 with \n\t| [] -> e2\n\t| t::q -> if (mem t e2) then (union q e2) else (t::(union q e2)) \n\nlet compose_subst sigma1 sigma2 =\n\tmap (function var -> (var, (substituer (valeur_subst sigma1 var) sigma2))) \n\t    (union (domaine_subst sigma1) (domaine_subst sigma2))\n\t\n\t\n\t\nlet sigma1 = [\t(Var(\"x\"), Func(\"h\", [Var(\"b\")]));\n              (Var(\"y\"),  Func (\"f\", [Var(\"x\"); Var(\"y\");Var(\"z\");])) ] ;;\n\nlet sigma2 = [\t(Var(\"x\"), Func(\"h\", [Var(\"x\")]));\n              (Var(\"z\"),  Func(\"g\", [Var(\"x\"); Var(\"a\")])) ] ;;\n\t \t\ncompose_subst sigma1 sigma2 ;;\n\t\t\t \nlet f1 = Func(\"f1\", [Var(\"x\"); Var(\"y\")]) ;;\nlet f2 = Func(\"f2\", [Var(\"z\"); Var(\"u\")]) ;;\n\nimprime (substituer f1 sigma1) ;;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nvaleur_subst sigma1 (Var(\"x\")) ;;\n\ndomaine_subst sigma1 ;;\nunion (domaine_subst sigma1) (domaine_subst sigma2) ;;\n\n\nimprime_sigma (union sigma1 sigma2) ;;\n\nexception Impossible\n\nlet rec listevararg = function\n\t| [] -> []\n\t| h::t -> (listevar) h @ (listevararg t)\nand listevar = function\n\t| Var(x) -> [Var(x)]\n\t| Func(x, t) -> listevararg t\n\n\t\nlet unifier t1 t2 =\n\tlet rec unificateur t1 t2 =\n\t\tmatch (t1,t2) with\n\t\t| (Var(x), _)  -> \n\t\t\t  begin\n\t\t\t\t\tif t1 = t2 then [] \n\t\t       else if (mem t1 (listevar t2)) then raise Impossible\n\t\t             else [(t1, t2)]\n\t\t    end\t\t  \n\t\t| (_, Var(x)) -> unificateur t2 t1\n\t\t| (Func(x, l1), Func(y, l2)) -> if x<>y then raise Impossible\n\t\t                             else (unifliste l1 l2 [])\n\tand unifliste l1 l2 sigma =\n\t\tmatch (l1, l2) with\n\t\t| ([], _) -> sigma\n\t\t| (h1::t1, h2::t2) ->\n\t\t\tbegin\n\t\t\t\tlet sigma1 = (unificateur h1 h2) in\n\t\t\t\t unifliste (map (function terme -> (substituer terme sigma1)) t1)\n\t\t\t\t           (map (function terme -> (substituer terme sigma1)) t2)\n\t\t\t\t\t\t\t\t\t (compose_subst sigma sigma1)\n\t\t\tend\t\t\n\tin unificateur t1 t2 \n\t\nlet t1 = Func(\"f\", [ Func(\"h\", [ Func(\"a\", []); Var(\"x\")]); Func (\"g\", [ Func (\"g\", [Var(\"z\")])])])\t;;\nlet t2 = Func(\"f\",  [Var(\"y\") ; Func(\"g\", [Var(\"x\")])]) ;;\n\nimprime_sigma (unifier t1 t2) ;;\t\t\n\t\t\t\t\t\t \nunifier (Var(\"x\")) (Func(\"z\", [Var(\"e\")])) ;;\nunifier (Var(\"x\")) (Func(\"z\", [Var(\"x\")])) ;;\nunifier (Func(\"f\", [])) (Func(\"z\", [Var(\"x\")])) ;;\n\n \n\n\nlet conclusion = hd\nlet lhypotheses = tl\n\nlet rec some f l =\n\tmatch l with\n\t| [] -> false\n\t| h::t ->  (f h) || (some f t)\n\n\nlet t1 = Func(\"f\", [ Func(\"h\", [ Func(\"a\", []); Var(\"x\")]); Func (\"g\", [ Func (\"g\", [Var(\"z\")])])]) ;;\n\t\nlet lregles = [ [ Func(\"b\", []) ] ; [ Func (\"c\", []) ] ] ;;\nlet but =  Func(\"c\", []) ;;\n\t\n\nlet demontre2 but lregles =\n\tlet reglesutilisees = ref [] in\n\tlet reponse ()  =\n\t  let () = (imprime_list !reglesutilisees; print_string \"autre solution o/n ? :\"; flush stdout; reglesutilisees := [] ) in\n\t  let r = input_char stdin in\n\t    if r = 'o' then false else true \n\tin\n\tlet rec demontreli lbuts =\n\t\tmatch lbuts with\n\t\t| [] -> reponse ()\n\t\t| h::t -> \n\t\t\t some (fun regle ->  if (h = (hd regle)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthen \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treglesutilisees := !reglesutilisees @ regle ; \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdemontreli ((tl regle) @ t) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse false)\n\t\t\t\t\t\t\t\t\t lregles \n\t\tin\n\t\t demontreli [but] ;;\n\n\nlet prolog but lregles =\n\tlet sigma_utilises = ref [] in\n\tlet reponse ()  =\n\t  let () = (imprime_sigma !sigma_utilises; print_string \"\\n autre solution o/n ? :\"; flush stdout; sigma_utilises := [] ) in\n\t  let r = input_char stdin in\n\t    if r = 'o' then false else true \n\tin\n\tlet rec prouveli lbuts lvaleur =\n\t\tmatch lbuts with\n\t\t| [] -> reponse ()\n\t\t| h::t -> \n\t\t\t some (fun regle ->  try\n\t\t\t\t                    let sigma1 = unifier h (hd regle) in\t\t\t\n\t\t\t                   \t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigma_utilises := !sigma_utilises @ sigma1 ; \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprouveli \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (sublis sigma1 ((lhypotheses regle) @ t))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(sublis sigma1 lvaleur)  \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  end\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twith Impossible -> false)\n\t\t\t\t\t\t\t\t\t lregles \n\t\tin\n\t\t prouveli [but] (listevar but)\n\nlet lregles = [ [ Func(\"b\", [Func(\"e\", []) ])] ; [ Func (\"c\", []) ] ;  [ Func (\"c\", [ Var(\"y\") ]) ] ] ;;\nlet but =  Var(\"x\") ;;\n\nlet peano = [ [Func(\"add\", [Var(\"x\"); Func(\"0\", []); Var(\"x\")]) ] ;\n              [Func(\"add\", [Var(\"x\");  Func(\"S\", [Var(\"y\")]) ; Func(\"S\", [Var(\"z\")])]) ; Func(\"add\", [Var(\"x\"); Var(\"y\"); Var(\"z\")])]\n\t\t\t\t\t\t] ;;\n\nlet but1 = Func(\"add\", [Var(\"x\") ; Var(\"y\") ; Func(\"S\", [Func(\"S\", [Func(\"S\", [Var(\"0\")])])])]) ;; \nlet but2 = Func(\"add\", [Func(\"0\", []) ; Var(\"x\")  ; Var(\"x\") ])\n\nlet t1 = [ [ Func(\"f\", [\n\t                      Func(\"h\", [Var(\"Z\")]) ;\n\t\t\t\t\t\t\t\t\t\t\t\t Var(\"T\") ;\n\t\t\t\t\t\t\t\t\t\t\t\t Var(\"Z\") ])] ] ;;\n\nlet t2 =   Func(\"f\", [\n\t                      Var(\"X\") ;\n\t\t\t\t\t\t\t\t\t\t\t\tFunc(\"g\", [Var(\"X\")]) ;\n\t\t\t\t\t\t\t\t\t\t\t\t Var(\"Y\") ])  ;;\n\n\nlet but =  Var(\"x\") ;;\n\n\nlet nat = [ [Func(\"nat\", [Func(\"0\", [])])] ;\n            [Func(\"nat\", [Func(\"s\",[Var(\"X\")])])] ]  ;;\n\nlet but = Func(\"nat\", [Var(\"X\")]) ;; \n\nprolog but1 peano ;;\n\n\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/vincent/workspace%20vscodium/prolog.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/vincent/workspace%20vscodium/prolog.ml"},"range":{"start":{"line":60,"character":22},"end":{"line":60,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/vincent/workspace%20vscodium/prolog.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/vincent/workspace%20vscodium/prolog.ml"},"range":{"start":{"line":60,"character":22},"end":{"line":60,"character":22}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/vincent/workspace%20vscodium/prolog.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"shutdown","params":null}
Sending response {"id": 5, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit","params":null}
Got exit! Terminating loop
Finished
