<!DOCTYPE html>
<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.32">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</style>
<title>Lambda calcul et réduction  
	 Interprétation et compilation  
	 Unification et résolution  
	 Exemples en Scheme et en ML
</title>
</head>
<body >
<!--HEVEA command line is: hevea document.tex -->
<!--CUT STYLE book--><!--CUT DEF chapter 1 --><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">Lambda calcul et réduction <br>
	 Interprétation et compilation <br>
	 Unification et résolution <br>
	 Exemples en Scheme et en ML</h1><h3 class="titlerest">Vincent Cognet</h3><h3 class="titlerest">27 avril 2020</h3></td></tr>
</table><!--TOC chapter id="sec1" Table des matières-->
<h1 id="sec1" class="chapter">Table des matières</h1><!--SEC END -->
<!--TOC chapter id="sec2" Le λ-calcul et la réduction-->
<h1 id="sec2" class="chapter">Chapitre 1  Le λ-calcul et la réduction</h1><!--SEC END -->
<!--TOC section id="sec3" Définition, champ lexical et syntaxique-->
<h2 id="sec3" class="section">1.1  Définition, champ lexical et syntaxique</h2><!--SEC END --><p>
Le λ-calcul est un système formel très rudimentaire. Il "n’utilise" que 
peu de moyens : le symbole λ, des variables et des parenthèses. Il n’a
qu’une seule règle de calcul, la β-réduction, qui modélise le passage d’un
argument à une fonction.</p><div class="theorem"><span style="font-weight:bold">Définition 1</span>  <em>
Un </em>λ <em>-terme est défini de manière récursive suivante:
</em><ul class="itemize"><li class="li-itemize"><em>
</em><em>Une variable </em><span style="font-style:italic">x</span><em> est un </em>λ<em>-terme.
</em></li><li class="li-itemize"><em>Une abstraction </em>λ <span style="font-style:italic">x</span>.<span style="font-style:italic">terme</span><em> est un </em>λ<em>-terme.
</em></li><li class="li-itemize"><em>Une application </em>(<span style="font-style:italic">terme</span>1  <span style="font-style:italic">terme</span>2)<em> est un </em>λ<em>-terme.
</em></li></ul><em>
</em></div><p>Exemple de lambda terme:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">( λ <span style="font-style:italic">x</span>. <span style="font-style:italic">xy</span> ) (<span style="font-style:italic">x</span> <span style="font-style:italic">z</span> <span style="font-style:italic">u</span>)  </td></tr>
</table><p>Voici le champ lexical des λ -termes:</p><p><br>

token = </p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >λ</td><td style="text-align:left;white-space:nowrap" >	 <code>LAMBDA</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >’.’</td><td style="text-align:left;white-space:nowrap" > <code>POINT</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >[ <span style="font-style:italic">a</span>−<span style="font-style:italic">z</span> ] [ <span style="font-style:italic">a</span>−<span style="font-style:italic">z</span>  0−9 ] *</td><td style="text-align:left;white-space:nowrap" > <code>VARIABLE</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >’(’	</td><td style="text-align:left;white-space:nowrap" >	 <code>PARLEFT</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >’)’	</td><td style="text-align:left;white-space:nowrap" >	 <code>PARRIGHT</code> 
</td></tr>
</table><p>
<br>
</p><p>Voici la grammaire des λ -termes, en utilisant les terminaux définis
avant :</p><p><br>

</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">terme</span> ::=</td><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><code>VARIABLE</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><code>PARLEFT</code>  <span style="font-style:italic">terme</span>  <span style="font-style:italic">terme</span>  <code>PARRIGHT</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><code>LAMBDA</code>  <code>VARIABLE</code>   .  <span style="font-style:italic">terme</span>
</td></tr>
</table><p>
<br>
</p><p>Nous utiliserons ocamllex et menhir, qui est la version moderne de ocamlyacc, pour l’analyse lexical et syntaxique des termes
du λ -calcul.</p>
<!--TOC subsection id="sec4" Analyse lexicale avec ocamllex-->
<h3 id="sec4" class="subsection">1.1.1  Analyse lexicale avec ocamllex</h3><!--SEC END --><p>
Nous définissons ici le champ lexical des différents <span style="font-style:italic">tokens</span> (<span style="font-style:italic">léxèmes</span>) du
λ-calcul.</p><pre class="verbatim">(* file: lambdalexical.mll *)
{
open Lambdagrammar (* Assumes the parser file is "lambdagrammar.mly" *)
}
let texte = ['a'-'z'] ['a'-'z' '0'-'9']*
rule token = parse
| "lambda" { LAMBDA }
| '.' { POINT }
| texte as varia { VARIABLE (varia) }
| '('  { PARLEFT }
| ')'  { PARRIGHT }
| _   { token lexbuf }
| eof  { raise End_of_file }
</pre><p>La compilation de ce fichier <code>.mll</code> va générer une fonction dont le nom
est celui de la règle (ici <code>token</code>).
Cette fonction prend comme argument le type <code>lexbuf</code> et rend le type <code>token</code>. </p><p><code>lexbuf</code> est un type de données abstrait défini dans le module Lexing 
qui permet de mémoriser la chaà®ne ou le fichier en cours d’analyse.
</p><pre class="verbatim">val token :  Lexing.lexbuf  -&gt; token 
</pre>
<!--TOC subsection id="sec5" Analyse syntaxique avec menhir-->
<h3 id="sec5" class="subsection">1.1.2  Analyse syntaxique avec menhir</h3><!--SEC END --><p>
Nous définissons ici la grammaire du λ-calcul.
Nous retrouvons les constructeurs du type ML associés à chacune des règles de la grammaire.
Ces constructeurs seront préenté dans la section qui suit.</p><pre class="verbatim">/* file: lambdagrammar.mly */
%{
open Terme
%}

%token &lt;string&gt; VARIABLE
%token LAMBDA PARLEFT PARRIGHT POINT
%token NEWLINE

%start exp
%type &lt;Terme.terme&gt; exp

%% /* Grammar rules and actions follow */
exp:      VARIABLE { Var($1) }
| PARLEFT exp exp PARRIGHT  { App($2, $3)}
| LAMBDA VARIABLE POINT exp  { Lam($2, $4) }
;
%%
</pre><p>Plus exactement, nous avons modifié cette grammaire <span style="font-style:italic">naïve</span> pour la
rendre non ambiguë et assurer l’associativité à gauche des
λ-applications.
En effet: 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span> <span style="font-style:italic">N</span> <span style="font-style:italic">O</span> <span style="font-style:italic">P</span> = (((<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) <span style="font-style:italic">O</span>) <span style="font-style:italic">P</span>) </td></tr>
</table><pre class="verbatim">%% 
line:  exp NEWLINE { $1 }
;

exp: LAMBDA VARIABLE POINT exp  { Lam($2, $4) }
   | app {$1}
;

app:  atome {$1}
   | app atome { App($1, $2) }
;

atome: PARLEFT exp PARRIGHT {$2}
       | VARIABLE {Var($1)}
;  
%%
</pre><p>
Nous obtenons ainsi:
</p><pre class="verbatim">$ ./lambda.out
&gt;&gt; m n o p
App(App(App(Var "m" ,Var "n" ),Var "o" ),Var "p" )

&gt;&gt; lambda f . (lambda x . f(x x)) (lambda x. f(x x))
Lam("f",App(Lam("x",App(Var "f" ,App(Var "x" ,Var "x" ))),
    Lam("x",App(Var "f" ,App(Var "x" ,Var "x" )))))
</pre><p>La compilation de ce fichier <code>.mly</code> va générer une fonction dont le nom
est celui de l’axiome de notre grammaire (ici <code>exp</code>). Cette fonction prend deux arguments: la fonction de l’analyseur lexical qui génère les tokens et l’input. Elle rend le type
des expressions utilisées commes actions dans la grammaire.
</p><pre class="verbatim">val exp :   (Lexing.lexbuf  -&gt; token) -&gt; Lexing.lexbuf -&gt; Terme.terme
</pre><p>Si le langage analysé n’est pas reconnu par la grammaire, l’exception <code>Parse_error</code> est levée.
</p>
<!--TOC subsection id="sec6" Implémentation du parsing en mode <span style="font-style:italic">récursif descendant</span>-->
<h3 id="sec6" class="subsection">1.1.3  Implémentation du parsing en mode <span style="font-style:italic">récursif descendant</span></h3><!--SEC END --><p>Si nous voulons nous passer d’un outil tel que ocamlyacc ou menhir, nous pouvons très facilement implémenter un parser
de manière récursive en partant depuis la racine (l’axiome des règles de notre grammaire) et en appelant de manière récursive les
régles suivantes en fonction du caractère lu.</p><p>On modifiera légèrement la grammaire comme ci-dessous pour faciliter le travail.</p><p><br>

</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">exprule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >| <code>VARIABLE</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >					</td><td style="text-align:left;white-space:nowrap" >	</td><td style="text-align:left;white-space:nowrap" >| <code>PARLEFT</code>   <span style="font-style:italic">parrule</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >					</td><td style="text-align:left;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >| <code>NEWLINE</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">parrule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >| <code>LAMBDA</code>  <span style="font-style:italic">lambdarule</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >					</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >| <span style="font-style:italic">apprule</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">lambdarule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><code>VARIABLE</code> <code>POINT</code> <span style="font-style:italic">exprule</span> <code>PARRIGHT</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">apprule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">exprule</span> <span style="font-style:italic">exprule</span> <code>PARRIGHT</code> </td></tr>
</table><p>
<br>
</p><p>Cela imposera cependant la saisie systématique des λ-termes avec des parenthèses autour des abstractions et des applications.
De même, nous n’aurons plus la facilité syntaxique de l’associativité à gauche des applications et de l’associativité à droite
du corps des abstractions.
Je ne sais pas si une telle grammaire peut être conçue pour une analyse en mode
récursif descendant.
Je pense que non (après m’être un peu cassé les cheveux là-dessus…)</p><p>Voici le code associé.
</p><pre class="verbatim">exception Fin
exception Erreur of string
 
let _ =
 let lexbuf = Lexing.from_channel stdin in
    
 let rec exprule courant =
  match courant with
  | VARIABLE(x) -&gt; Var(x)
  | PARLEFT -&gt; parrule (lexana lexbuf)
  | NEWLINE -&gt; raise Fin
  | _ -&gt;  raise (Erreur "exprule")
  
  and parrule courant =
     match courant with
    | LAMBDA -&gt; lambdarule courant
    | _ -&gt; apprule courant
   
  and apprule courant =
    let op1 = exprule courant in
      let op2 = exprule (lexana lexbuf) in
    let suivant = lexana lexbuf in (* consume PARRIGHT*)
    match suivant with 
     | PARRIGHT -&gt;  App(op1, op2) 
     | _ -&gt; raise (Erreur "apprule")
   
  and lambdarule courant =
     let var = lexana lexbuf in 
    let _ = lexana lexbuf in  (* consume POINT *)
    let corps = exprule(lexana lexbuf) in
    let _ =  lexana lexbuf (* consume PARRIGHT *) in
    match var with 
     | VARIABLE(x) -&gt; Lam(x, corps)
     | _ -&gt; raise (Erreur "lambdarule")
   
  in (betaNormalPrint (exprule (lexana lexbuf)); flush stdout)
</pre>
<!--TOC section id="sec7" Représentation en ML-->
<h2 id="sec7" class="section">1.2  Représentation en ML</h2><!--SEC END --><pre class="verbatim">type terme =
| Var of string
| App of terme * terme
| Lam of variable * terme
</pre><p>Un terme du λ -calcul est donc un type ML composé, avec les constructeurs <span style="font-style:italic">Var</span>, <span style="font-style:italic">App</span> et <span style="font-style:italic">Lam</span>.</p><p>Par exemple, le terme  λ <span style="font-style:italic">x</span>.(<span style="font-style:italic">x</span> <span style="font-style:italic">y</span>) <span style="font-style:italic">z</span>  est representé par la structure:</p><p><code>App ((Lam ("x", (App ((Var "x"), (Var "y"))))), (Var "z"))</code></p><p>C’est un peu verbeux.
Voici cependant sa représentation sous la forme d’un arbre syntaxique. Le symbole @ représente ici l’application.
</p><div class="center">
[level distance=1.5cm,
level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm]
@
child  node λ 
		child  node x 
		child  node @
				child  node x 
				child  node y 
			 
	 
child  node z ;

</div><p>Pour dessiner cet arbre, nous utilisons le très bon package TIKZ qui permet facilement de représenter
les arbres avec une syntaxe très simple.
</p><pre class="verbatim">\node{@}
child { node {$\lambda $}
  child { node {x} }
  child { node {@}
    child { node {x} }
    child { node {y} }
     }
   }
child { node {z} };
</pre><p>On implémente deux fonctions CAML
qui permettent d’afficher une expression de type λ -terme en code L<sup>A</sup>T<sub>E</sub>X ou en code TIKZ.</p><p>La fonction <code>varLibres</code> retourne les variables libres (ie. non liées) d’un λ -terme.
</p><pre class="verbatim">let rec varLibres lambdaTerm =
 match lambdaTerm with
 | Var x -&gt; [ x ]
 | App (n, m) -&gt; union (varLibres n) (varLibres m)
 | Lam (x, m) -&gt; remove x (varLibres m)
</pre><p>Par exemple: (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">yxw</span>)(λ <span style="font-style:italic">u</span>.<span style="font-style:italic">uv</span>) ⊢→ <span style="font-style:italic">y</span>,<span style="font-style:italic">w</span>,<span style="font-style:italic">v</span> </p><pre class="verbatim">let exemple = App (Lam ("x", App (Var("y"), App (Var("x"),Var("w")))),
Lam ("u", App (Var ("u"), Var ("v")))) ;;
varLibres exemple ;;
- : variable list = ["y"; "w"; "v"]
</pre><div class="theorem"><span style="font-weight:bold">Définition 1</span>  <em>
Un redex ou radical est un terme de la forme </em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span><em>
</em></div><p>
On a déjà distingué deux formes possible sur les λ-termes : les <span style="font-style:italic">abstractions</span> λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span> et les
<span style="font-style:italic">applications</span> (<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>). Un <span style="font-style:italic">redex</span> qui est de la forme (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span> est la
rencontre d’une abstraction et d’une application. Voici son implémentation.</p><p><br>

</p><div class="center">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >ML</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >SCHEME </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">(function x -&gt; M) N</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">((lambda (x) M) N)</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">let x = N in M</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">(let ((x N)) M)</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">M where x = N</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
</table>
</div><p>
La dernière syntaxe <span style="font-family:monospace">M where x = N</span> a disparu en OCAML. C’est dommage car elle est très élégante.
Nous essayerons de la reprendre pour notre interprète maison MiniML.</p><div class="theorem"><span style="font-weight:bold">Définition 1</span>  <em>
La </em>β <em>-réduction est une opération de substitution. Elle consiste à substituer dans le redex
</em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>) <span style="font-style:italic">N</span><em> les occurrences libres de x dans M par l’argument N.
On la formalise par la notation suivante:
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>) <span style="font-style:italic">N</span>) → <sub>β</sub><span style="font-style:italic">M</span>[<span style="font-style:italic">x</span> ← <span style="font-style:italic">N</span>]
</td></tr>
</table><em>
</em></div><p>Nous pouvons la décrire par les quatre règles d’inférence ci-dessous:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold">(</span><span style="font-weight:bold"><span style="font-style:italic">redex</span></span><span style="font-weight:bold">)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span>) → <span style="font-style:italic">M</span>[<span style="font-style:italic">x</span> ← <span style="font-style:italic">N</span>]</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold">(</span><span style="font-weight:bold"><span style="font-style:italic">abstraction</span></span><span style="font-weight:bold">)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span> → (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span><sub>1</sub>)</td></tr>
</table></td><td class="dcell">
   <span style="font-weight:bold">(1)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span><sub>1</sub> <span style="font-style:italic">N</span>)</td></tr>
</table></td><td class="dcell">
   <span style="font-weight:bold">(2)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span> → <span style="font-style:italic">N</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span> <span style="font-style:italic">N</span><sub>1</sub>)</td></tr>
</table></td></tr>
</table><p><br>

Pour l’implémentation, nous nous sommes appuyé sur le code de l’excellent livre <span style="font-style:italic">Programmer avec Scheme</span> de Jacques Chazarain.
Nous avons adapté son code SCHEME en OCAML. En comparant les deux versions, on s’aperçoit finalement
que la version OCAML, même si un peu plus concise que la version SCHEME grâce l’utilisation du <span style="font-style:italic">pattern matching</span>,
reste très proche de l’original SCHEME.</p><p><br>

La fonction <span style="font-family:monospace">substituer</span> permet de substituer la variable <span style="font-family:monospace">var</span> par le terme <span style="font-family:monospace">terme</span> dans l’expression <span style="font-family:monospace">exp</span>.</p><pre class="verbatim">let rec substituer exp var terme =
 match exp with
 | Var x -&gt; if x = var then terme else exp
 | App (n, m) -&gt; App ((substituer n var terme), (substituer m var terme))
 | Lam (x, m) -&gt; (* pas d'occurence libre on en fait rien *)
   if not (mem var (varLibres exp))
   then exp
   else (* si capture on renome *)
   if mem x (varLibres terme)
   then
    (let newV = renomme x (varLibres terme) in
     let newCorps = substituer m x (Var newV)
     in Lam (newV, (substituer newCorps var terme)))
   else  Lam (x, (substituer m var terme))
</pre><p>Avant de substituer une variable par une autre, nous devons nous assurer qu’il n’y aura pas de phénomène de capture, ie.
nous assurer qu’une variable libre ne deviendra pas liée, après substitution.
Dans l’exemple suivant, la variable x qui était libre dans  (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)  se retrouve capturée par λ
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">λ <span style="font-style:italic">x</span>. (<span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)[<span style="font-style:italic">y</span> ← (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)] = λ <span style="font-style:italic">x</span>.(<span style="font-style:italic">x</span> (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)) </td></tr>
</table><p>
Pour éviter cela, il faut avant substitution opérer un renommage de la variable liée:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">λ <span style="font-style:italic">x</span><sub>1</sub>. (<span style="font-style:italic">x</span><sub>1</sub> <span style="font-style:italic">y</span>)[<span style="font-style:italic">y</span> ← (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)] = λ <span style="font-style:italic">x</span><sub>1</sub>.(<span style="font-style:italic">x</span><sub>1</sub> (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)) </td></tr>
</table><p>
Ce renommage est appelé α-conversion. On dit que deux termes <span style="font-style:italic">M</span> et <span style="font-style:italic">N</span> sont équivalents modulo α.
On écrira <span style="font-style:italic">M</span>=<sub>α</sub><span style="font-style:italic">N</span></p><pre class="verbatim">(** renommer var *)
let renomme var listeVar =
 let rec renommeAux j =
  let varj = var ^ (string_of_int j)
  in if mem varj listeVar then renommeAux (j + 1) else varj
 in renommeAux 0
</pre><p>La fonction <span style="font-family:monospace">reduc1Normale</span> réduit le terme en appliquant la stratégie de réduction normale, c’est-à-dire
en commencant la réduction par le redex extèrieur, plus précisément le plus à gauche des extèrieurs.</p><pre class="verbatim">let rec reduc1Normale terme =
   match terme with
   | Var x -&gt; raise IRREDUCTIBLE 
   | Lam (x, m) -&gt; Lam (x, (reduc1Normale m))
   | App (n, m) -&gt;
  if estRedex terme
  then betaReducRedex terme
  else
   try App ((reduc1Normale n), m)
   with IRREDUCTIBLE   -&gt; App (n, (reduc1Normale m)) 
</pre><p>Enfin, nous avons une fonction <code>fullReduc</code> qui permet d’itérer l’opération de
β-réduction jusqu’à trouver la forme normale, ou boucler s’il n’y a pas de forme formale.
On lui impose donc maximum 1000 réductions <sup><a id="text1" href="#note1">1</a></sup>
Elle prend en argument la méthode (ie. la stratégie de réduction) à  utiliser. </p><pre class="verbatim">let rec fullReduc terme methode  =
  let rec loop terme  iter =
 try
  let newterme = methode terme in
  if (newterme = terme || iter = 0) then newterme
  else loop newterme (iter - 1)
 with IRREDUCTIBLE -&gt; terme 
  in loop terme 1000
 
let betaNormal t = fullReduc t reduc1Normale
</pre><div class="theorem"><span style="font-weight:bold">Théoreme 1</span>  <em>
La réduction normale appliquée à un terme normalisable aboutit toujours a la forme irréductible du terme.
</em></div><p>Nous avons en plus le théorème suivant qui nous assure que toutes les réductions d’un λ-terme (qui terminent) aboutissent au même
terme irréductible.</p><div class="theorem"><span style="font-weight:bold">Théoreme 1</span>  <em>
Théoreme de Church-Rosser : la </em>β <em>-réduction immédiate est confluente.
</em></div>
<!--TOC section id="sec8" Quelques exemples de réduction-->
<h2 id="sec8" class="section">1.3  Quelques exemples de réduction</h2><!--SEC END --><pre class="verbatim">let t1 = App (Lam ("x",App (Lam ("y", App (Var ("x"), Var ("y"))),Var ("u"))), Var ("z")) ;;
# fullReduc t1 ;;
--&gt; ((lambda x . ((lambda y . (xy))u))z)
--&gt; ((lambda y . (zy))u)
--&gt; (zu)
- : unit -&gt; unit = &lt;fun&gt;
</pre><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">y</span> . <span style="font-style:italic">xy</span>)<span style="font-style:italic">u</span>)<span style="font-style:italic">z</span>   → <sub>β</sub>(λ <span style="font-style:italic">y</span> . <span style="font-style:italic">zy</span>) <span style="font-style:italic">u</span>  → <sub>β</sub>(<span style="font-style:italic">zu</span>)
</td></tr>
</table><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">y</span> . <span style="font-style:italic">xy</span>)<span style="font-style:italic">u</span>)<span style="font-style:italic">z</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(λ <span style="font-style:italic">y</span> . <span style="font-style:italic">zy</span>)<span style="font-style:italic">u</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<span style="font-style:italic">zu</span>) </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >
[level distance=1.5cm,
level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm]
@ child  node λ child  nodex  child node @ child  node λ child  nodey 
child node @ child  node x  child node y    child node u    child node z  ;

</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >
[level distance=1.5cm,
level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm]
@ child  node λ child  nodey 
child node @ child  node z  child node y   
child node u  ;

</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >
[level distance=1.5cm,
level 1/.style=sibling distance=3cm ]
@ child  node z 
child  nodeu  ;


</td></tr>
</table><p><br>
<br>
<br>

Voici un exemple qui ne termine pas:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>) → <sub>β</sub>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)
→ <sub>β</sub>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>) → <sub>β</sub>…
</td></tr>
</table>
<!--TOC section id="sec9" La β-réduction faible avec appel par valeur-->
<h2 id="sec9" class="section">1.4  La β-réduction faible avec appel par valeur</h2><!--SEC END --><p>
Dans un langage fonctionnel comme SCHEME ou ML, il est important de noter que contrairement au λ-calcul, le corps de la lambda n’est pas évalué. 
On parle de β-réduction faible. 
Autrement dit, la règle suivante n’est pas utilisée:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold">(</span><span style="font-weight:bold"><span style="font-style:italic">abstraction</span></span><span style="font-weight:bold">)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"> λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span> → (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span><sub>1</sub>)</td></tr>
</table></td></tr>
</table><p>
Nous pourrons utiliser cette absence d’évaluation du corps 
des lambda expressions pour geler l’évaluation de nos expressions : <code>(delay exp) = (lambda () exp)</code> </p><p>L’appel par valeur signifie que les arguments sont évalué en premier. Les règles d’inférence appliquées sont donc dans cet ordre:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">   <span style="font-weight:bold">(1)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span> → <span style="font-style:italic">N</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span> <span style="font-style:italic">N</span><sub>1</sub>)</td></tr>
</table></td><td class="dcell">
   <span style="font-weight:bold">(2)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span><sub>1</sub> <span style="font-style:italic">N</span>)</td></tr>
</table></td><td class="dcell">
   <span style="font-weight:bold">(3)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center">((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span>) → <span style="font-style:italic">M</span>[<span style="font-style:italic">x</span> ← <span style="font-style:italic">N</span>]</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>Voici la fonction ML qui implémente cet ordre:
</p><pre class="verbatim">let rec reduc1Valeur terme =
  match terme with
  | Var x -&gt; raise IRREDUCTIBLE
  | Lam (x, m) -&gt; raise IRREDUCTIBLE
  | App (n, m) -&gt;
      (try App (n, (reduc1Valeur m))
       with
       | IRREDUCTIBLE -&gt;
           (try App ((reduc1Valeur n), m)
            with
            | IRREDUCTIBLE -&gt;
                (try betaReducRedex terme
                 with | NOTREDEX -&gt; raise IRREDUCTIBLE)))
</pre><p>Par exemple, nous aurons les réductions successives suivantes: </p><ul class="itemize"><li class="li-itemize">
réduction normale, qui aboutit toujours à la forme irréductibre
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>) ((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>)) →<sub>β</sub><span style="font-style:italic">y</span> </td></tr>
</table> </li><li class="li-itemize">réduction par valeur 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>))</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>))</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>)) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>))) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >… </td></tr>
</table></td></tr>
</table>
</li></ul>
<!--TOC section id="sec10" La récursivité et le point fixe-->
<h2 id="sec10" class="section">1.5  La récursivité et le point fixe</h2><!--SEC END --><p>
En analyse, le point fixe d’une fonction <span style="font-style:italic">f</span> est sa valeur <span style="font-style:italic">x</span> telle que <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span></p><p>Cela permet de définir <span style="font-style:italic">x</span> en fonction de lui-même.</p><p>Cette expression simple <span style="font-style:italic">x</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) est finalement très étrange et déroutante.
C’est la force de la récursivité : <span style="font-style:italic">x</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>… (<span style="font-style:italic">x</span>)…))))))</p><p>Un exemple est la valeur √<span style="text-decoration:overline">2</span> exprimée sous forme d’une fraction continue,
expression trouvée je crois par Euler.
Je la décris ci-dessous uniquement pour le plaisir d’écrire (et lire) de belles formules mathématiques en L<sup>A</sup>T<sub>E</sub>X</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> = 1+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> −1
= 1+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> −1)(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> +1)</td></tr>
</table></td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> +1</td></tr>
</table></td></tr>
</table></td><td class="dcell">
= 1 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hbar"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> = 1 + </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" >...
</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">
    (1)</td></tr>
</table><p>En CAML, la fonction qui itère cette fraction continue peut être définie par:
</p><pre class="verbatim">let rec square2 iter =
 if (iter = 1) then 1.
 else  1. +. ( 1. /. ( 1. +. square2 (iter - 1)));;
val square2 : int -&gt; float = &lt;fun&gt;

# square2 30 ;;
- : float = 1.4142135623730951

# sqrt 2. ;;
- : float = 1.41421356237309512.

</pre><p>En λ -calcul, nous avons un combinateur<sup><a id="text2" href="#note2">2</a></sup> qui nous permet de calculer le point fixe de n’importe quel λ -terme.
Ce combinateur s’appelle <span style="font-style:italic">Y</span> . Il est défini par  λ <span style="font-style:italic">f</span>.(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>))(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>)) </p><p>Ce n’est pas le seul combinateur de point fixe. Un autre dû à Turing est
Θ = (λ <span style="font-style:italic">x</span>. λ <span style="font-style:italic">y</span>. (<span style="font-style:italic">y</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>))) (λ <span style="font-style:italic">x</span>. λ <span style="font-style:italic">y</span>. (<span style="font-style:italic">y</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)))</p><p>Voici l’arbre syntaxique de <span style="font-style:italic">Y</span>:</p><p>[level distance=1.5cm,
level 1/.style=sibling distance=5cm,
level 2/.style=sibling distance=3cm,
level 3/.style=sibling distance=1.5cm,
level 4/.style=sibling distance=1.5cm]
λ child  nodef  child node @ child  node λ child
 nodex  child node @ child  node f  child node @ child  node x 
child node x     child node λ child  nodex  child
node @ child  node f  child node @ child  node x  child node x      ;
</p><p>Quel que soit le terme <span style="font-style:italic">M</span>, nous aurons (<span style="font-style:italic">YM</span>) = <sub>β</sub><span style="font-style:italic">M</span>(<span style="font-style:italic">YM</span>)</p><p>Essayons ceci avec notre notre fonction <code>fullReduc</code> en CAML.
Réduisons <span style="font-style:italic">YM</span> :</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>))) (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>))) <span style="font-style:italic">M</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span> (<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">M</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>))))  ▷ [2] </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">MM</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">MMM</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">MMMM</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>…
</td></tr>
</table></td></tr>
</table><p>La deuxième β-réduction est bien égale à <span style="font-style:italic">M</span> (<span style="font-style:italic">Y</span> <span style="font-style:italic">M</span>)
Nous voyons ici le mécanisme d’appel récursif à M. </p><p>Détaillons cela avec une fonction exprimée en pseudo-code d’un λ-calcul étendu.
Nous nous inspirons pour cela du très bon article de wikipedia <span style="font-family:monospace">https://en.wikipedia.org/wiki/Lambda_calculus</span>.</p><p>Soit <span style="font-style:italic">M</span> = (λ <span style="font-style:italic">f</span> λ <span style="font-style:italic">n</span> .(<span style="font-style:italic">if</span> <span style="font-style:italic">n</span>=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> <span style="font-style:italic">n</span>*<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>−1)))
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">YM</span>) 4</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">M</span> (<span style="font-style:italic">YM</span>) 4 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">f</span> λ <span style="font-style:italic">n</span> .(<span style="font-style:italic">if</span> <span style="font-style:italic">n</span>=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> <span style="font-style:italic">n</span>*<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>−1))) (<span style="font-style:italic">YM</span>) 4 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ  <span style="font-style:italic">n</span> . (<span style="font-style:italic">if</span> <span style="font-style:italic">n</span>=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> <span style="font-style:italic">n</span>*((<span style="font-style:italic">YM</span>) (<span style="font-style:italic">n</span>−1)))) 4 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">if</span> 4=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> 4*((<span style="font-style:italic">YM</span>) (4−1))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >4 * ((<span style="font-style:italic">YM</span>) 3) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >4 * (<span style="font-style:italic">M</span>(<span style="font-style:italic">YM</span>) 3) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >… </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >4 * 3 * 2 * 1 
</td></tr>
</table></td></tr>
</table><p>Ici encore, nous avons utilisé la stratégie de β-réduction normale. 
Mais avec une réduction par valeur, le terme en argument (<span style="font-style:italic">YM</span>) aura été réduit indéfiniment en <span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>… <span style="font-style:italic">YM</span>)…))),
sans réduire le redex <span style="font-style:italic">Mx</span></p><p>En utilisant notre programme OCAML, voyons cela avec en prenant <span style="font-style:italic">M</span> = λ <span style="font-style:italic">a</span>. (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)  :</p><p><code># betaNormal ym ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">f</span> . (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>)))λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" > → <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))</td><td style="text-align:left;white-space:nowrap" >▷ [2]  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > → <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))))</td><td style="text-align:left;white-space:nowrap" >▷ [3]  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > → <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p><code># betaValeur ym ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">f</span> . (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>)))λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))</td><td style="text-align:left;white-space:nowrap" >▷ [2]  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))))</td><td style="text-align:left;white-space:nowrap" >▷ [3] </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))))</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))))))</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))))))</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>
Les étapes ▷ [2] et ▷ [3] sont bien les mêmes sur les deux stratégies. 
Puis la β-réduction par valeur va continuer à réduire l’argument
(<span style="font-style:italic">YM</span>), là où la β-réduction normale va d’abord réduire le redex <span style="font-style:italic">Mx</span></p><p>Avec la réduction par valeur, il nous faut donc utiliser un autre combinateur de point fixe<sup><a id="text3" href="#note3">3</a></sup>
que nous appelerons <span style="font-style:italic">Z</span> 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Z</span> = λ <span style="font-style:italic">f</span>.(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span>.<span style="font-style:italic">xxv</span>))(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span>.<span style="font-style:italic">xxv</span>)) </td></tr>
</table><p>On constate que Z est η-équivalent à <span style="font-style:italic">Y</span>. Nous rappelons la définition suivante:</p><div class="theorem"><span style="font-weight:bold">Définition 1</span>  <em>
Les termes </em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">Mx</span>)<em> et M sont </em>η<em>-équivalents. On écrira </em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">Mx</span>) =<sub>η</sub><span style="font-style:italic">M</span><p><em>En ML, nous pouvons par exemple dire que </em><code><em> let g x = f x</em></code><em> est </em>η<em>-équivalent à </em><code><em> let g = f</em></code><em>
</em></p></div><p>Appliquons à nouveau notre exemple avec ce combinateur <span style="font-style:italic">Z</span> appliqué à <span style="font-style:italic">M</span>=λ <span style="font-style:italic">a</span>. λ <span style="font-style:italic">b</span>. <span style="font-style:italic">b</span>:</p><p><code># betaValeur zm ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >((λ <span style="font-style:italic">f</span> . ((λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))))(λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >((λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))(λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . (((λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))(λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>)))))<span style="font-style:italic">v</span>))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)
</td></tr>
</table></td></tr>
</table><p>Nous avons le même réultat et les même étapes de réduction avec <code>betaNormal zm ;;</code></p><p>En SCHEME, nous pourrons implémenter ce combinateur <span style="font-style:italic">Z</span> :
</p><pre class="verbatim">(define Z
 (lambda(f)
   (lambda (x) (lambda(v) ((f (x x) v))))
   (lambda (x) (lambda(v) ((f (x x) v))))))
</pre><p>En ML, le typage ne nous permettra pas de coder un combinateur comme <span style="font-style:italic">Y</span> ou <span style="font-style:italic">Z</span>.</p><p>Essayons cependant d’écrire:</p><pre class="verbatim">
# let rec fix f = f (fix f) ;;
val fix : ('a -&gt; 'a) -&gt; 'a = &lt;fun&gt;

let factabs fact = function
  | 0 -&gt; 1
  | n -&gt; n * fact (n - 1) ;;

val factabs : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;
# (fix factabs) 5 ;;
Stack overflow during evaluation (looping recursion?).


</pre><p>
ML est bien un langage <span style="font-style:italic">strict</span>: les arguments d’une fonction sont évalué en premier comme on l’a vu
dans la β-réduction faible avec appel par valeur.
Pour éviter la boucle infinie <span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>…(<span style="font-style:italic">f</span> (<span style="font-style:italic">fix</span> <span style="font-style:italic">f</span>))…), une astuce que j’ai pu lire est d’introduire une variable supplémentaire:
</p><pre class="verbatim"># let rec fix f x = f (fix f) x ;;
val fix : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
# (fix factabs) 5 ;;
- : int = 120
</pre><p>
Ici aussi, le mécanisme de la “η-expansion” est utilisé.
Je suis surpris cependant de voir que <code>fix</code> prenant deux arguments est correctement évalué lors de son appel <code>(fix f)</code>.
Je ne peux reproduire cela en SCHEME:</p><pre class="verbatim">(define factabs
  (lambda (f)
    (lambda (n)
      (if (eq? n 0)
          1
          (* n (f (- n 1)))))))

(define y
  (lambda (f x)
    (f (y f) x)))

(y factabs 5)
=&gt; y: arity mismatch; the expected number of arguments does not match 
  expected: 2
  given: 1
</pre>
<!--TOC section id="sec11" <span style="font-style:italic">Church</span> encoding. Les entiers et les booléens en λ-calcul-->
<h2 id="sec11" class="section">1.6  <span style="font-style:italic">Church</span> encoding. Les entiers et les booléens en λ-calcul</h2><!--SEC END -->
<!--TOC subsection id="sec12" Les entiers <span style="font-style:italic">Church</span> -->
<h3 id="sec12" class="subsection">1.6.1  Les entiers <span style="font-style:italic">Church</span> </h3><!--SEC END --><p>
Les entiers peuvent être représenté de la manière suivante:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >0 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >1 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> <span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >2 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> (<span style="font-style:italic">f</span> <span style="font-style:italic">x</span>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >3 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> (<span style="font-style:italic">f</span> (<span style="font-style:italic">f</span> <span style="font-style:italic">x</span>)) 
</td></tr>
</table></td></tr>
</table><p>La fonction successeur se définira <span style="font-style:italic">SUCC</span> ≡ λ <span style="font-style:italic">n</span>.λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> (<span style="font-style:italic">n</span> <span style="font-style:italic">f</span> <span style="font-style:italic">x</span>)
Avec notre représentation ML: </p><p><code>let succ = Lam("n", Lam("f", Lam("x",App(Var "f", App(App(Var "n", Var "f"), Var "x")))))</code></p><p>Exécutons avec la stratégie normale, puis avec la stratégie de réduction faible par valeur:</p><p><code># betaNormalPrint (App(succ, un)) ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">fx</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Exception</span>: <span style="font-style:italic">IRREDUCTIBLE</span>.
</td></tr>
</table></td></tr>
</table><p><code># betaValeurPrint (App(succ, un)) ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Exception</span>: <span style="font-style:italic">IRREDUCTIBLE</span>.
</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>
Nous n’aboutissons pas au terme λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">fx</span>))  avec la stratégie par valeur. Nous voyons que le corps de la lambda
n’est pas évalué. Je suis cependant surpris car je pensais cette stratégie (même si appelée <span style="font-style:italic">faible</span>) parvenait à calculer la
forme normale.</p><p>Nous pouvons écrire en OCAML la fonction qui convertit des entiers vers les terms <span style="font-style:italic">Church</span>:
</p><pre class="verbatim">
let rec int2Church = function
 | 0 -&gt; Lam("f", Lam("x", Var "x"))
 | n -&gt; App(succ, int2Church (n-1))
</pre><p><code># betaNormal (int2Church 3) ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>))<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xf</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xf</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xf</span>)<span style="font-style:italic">x</span>))))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xx</span>))))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">fx</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Exception</span>: <span style="font-style:italic">IRREDUCTIBLE</span>. 
</td></tr>
</table></td></tr>
</table><p>L’addition peut être exprimée par le combinateur λ <span style="font-style:italic">m</span> .λ <span style="font-style:italic">n</span> .λ <span style="font-style:italic">f</span>. λ <span style="font-style:italic">x</span>. <span style="font-style:italic">m</span> <span style="font-style:italic">f</span> (<span style="font-style:italic">n</span> <span style="font-style:italic">f</span> <span style="font-style:italic">x</span>) <span style="font-style:italic">x</span> <br>
La multiplication peut être exprimée par le combinateur λ <span style="font-style:italic">m</span> .λ <span style="font-style:italic">n</span> .λ <span style="font-style:italic">f</span>. λ <span style="font-style:italic">x</span>. <span style="font-style:italic">m</span> (<span style="font-style:italic">n</span> <span style="font-style:italic">f</span>) <span style="font-style:italic">x</span>  <br>
Le prédecesseur peut être exprimé par le combinateur λ <span style="font-style:italic">n</span>.λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">n</span> (λ <span style="font-style:italic">g</span>.λ <span style="font-style:italic">h</span>.<span style="font-style:italic">h</span> (<span style="font-style:italic">g</span> <span style="font-style:italic">f</span>)) (λ <span style="font-style:italic">u</span>.<span style="font-style:italic">x</span>) (λ <span style="font-style:italic">u</span>.<span style="font-style:italic">u</span>)  <br>

Après avoir défini les termes <code>succ</code> et <code>pred</code>, nous pouvons écrire les deux fonctions suivantes qui “jonglent”
entre les entiers ML et les entiers Church.
</p><pre class="verbatim">let int2Church n = 
 let rec aux = function
 | 0 -&gt; Lam("f", Lam("x", Var "x"))
 | n -&gt; App(succ, aux (n-1))
 in betaNormal (aux n)

let rec church2Int  terme = 
 match terme with
 | Lam("f", Lam("x", Var "x")) -&gt; 0
 | _ -&gt; 1 + church2Int (betaNormal(App(pred, terme)))

# church2Int (int2Church 10);;
- : int = 10
</pre><p>Egalement, nous pouvons représenter directement en ML les entiers <span style="font-style:italic">Church</span> sous forme de fonctionnelles:
</p><pre class="verbatim">let zero f x = x
let un f x = f x
let deux f x = f (f x)

let succ n f x = f (n f x)
let add n m f x = n f (m f x)

let to_int n = n (function k -&gt; k + 1) 0
let rec to_church = function | 0 -&gt; zero  | n -&gt; succ (to_church (n-1))
 
#to_int (add deux (succ (to_church 5))) ;;
- : int = 8 
</pre>
<!--TOC subsubsection id="sec13" Les booléens -->
<h4 id="sec13" class="subsubsection">Les booléens </h4><!--SEC END --><p>
Nous pourrons les représenter de la façon suivante. On y ajoute le prédicat IsZero.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >true</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">a</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >false</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">b</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >and</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.λ <span style="font-style:italic">q</span>.<span style="font-style:italic">p</span> <span style="font-style:italic">q</span> <span style="font-style:italic">p</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >or</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.λ <span style="font-style:italic">q</span>.<span style="font-style:italic">p</span> <span style="font-style:italic">p</span> <span style="font-style:italic">q</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >not</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.<span style="font-style:italic">p</span> (λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">b</span>) (λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">a</span>)=λ <span style="font-style:italic">p</span>.<span style="font-style:italic">p</span>false true </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >if</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">p</span> <span style="font-style:italic">a</span> <span style="font-style:italic">b</span>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >IsZero</td><td style="text-align:left;white-space:nowrap" >≡  λ <span style="font-style:italic">n</span>.<span style="font-style:italic">n</span> (λ <span style="font-style:italic">x</span>.false) true
</td></tr>
</table></td></tr>
</table>
<!--TOC subsubsection id="sec14" La fonction factorielle-->
<h4 id="sec14" class="subsubsection">La fonction factorielle</h4><!--SEC END --><p>
Nous pouvons l’exprimer de manière assez simple. La difficulté est de manipuler toujous les applications avec un seul argument, en version
<span style="font-style:italic">curryfiée</span>.
Nous appliquons le combinateur <span style="font-style:italic">Y</span> associé à la stratégie de réduction normale.
Attention à ne pas réduire telle quelle la fonction <code>fact</code>. La réduction serait infinie comme on l’a vu précedemment. Seul la préence
d’un argument permet d’aboutir à la forme normale.</p><p>Cette forme normale constitue notre <span style="font-style:italic">valeur</span> (au sens d’un langage interprété).
</p><pre class="verbatim">let fact =
  App (y,
    (Lam ("f",
       (Lam ("n",
          (App ((App ((App (si, (App (isZero, (Var "n"))))), un)),
             (App ((App (mult, (Var "n"))),
                (App ((Var "f"), (App (pred, (Var "n"))))))))))))))

# church2Int (betaNormal (App(fact, int2Church 4)));;
- : int = 24                                        
</pre><p>
Nous n’afficherons pas les réductions ici. Le calcul de la factorielle de 3 nécessite 705 β-réductions. 
La factorielle de 5 en nécessite plus de 28000…</p>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">La fonction STOP de mon toplevel sous Eclipse ne marche pas…</div></dd><dt class="dt-thefootnotes"><a id="note2" href="#text2">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Un combinateur est un λ-terme comprenant uniquement 
des variables liées</div></dd><dt class="dt-thefootnotes"><a id="note3" href="#text3">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Nous insistons 
là-dessus car nous rappelons que les interprètes MiniScheme et MiniML que nous implémenterons utiliseront la β-réduction faible par valeur.</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec15" L’interprétation-->
<h1 id="sec15" class="chapter">Chapitre 2  L’interprétation</h1><!--SEC END -->
<!--TOC section id="sec16" Introduction-->
<h2 id="sec16" class="section">2.1  Introduction</h2><!--SEC END --><p>
Nous avons vu que le λ-calcul utilise la réduction, basée sur un mécanisme de substitution.
Les langages interprété que nous allons implémenter n’utilisent pas ce mécanisme de substitution, mais
font appel un environnement qui permet de représenter les paires variable/valeur.
A l’application d’une fonction, cet environnement est enrichi <span style="font-style:italic">(étendu)</span> par les nouvelles paires variable/valeur
des arguments de la fonction.</p><p>Nous perdons donc le côté pur du λ-calcul qui se suffit à lui-même pour
dérouler ses calculs.
L’interprète ne pourra évaluer son expression qu’en préence d’un environnement.</p><p>Nous allons ici reprendre une grande partie du code de l’excellent blog <span style="font-family:monospace">https://bernsteinbear.com/blog/lisp/</span>.</p><p>Par rapport au code du blog cité, nous faisons deux changements majeurs. Le premier est d’utiliser à nouveau
les outils d’analyseur lexical et syntaxique <span style="font-weight:bold">ocamllex</span> et <span style="font-weight:bold">ocamlyacc</span>. Le second sera de modéliser l’environnement
sous forme d’une fonction et non d’une liste d’association ou <span style="font-style:italic">a-liste</span>.</p><p>En fait, nous nous apercevrons que l’idée de représenter l’environnement sous forme d’une
liste construite par un type de ce même langage est très séduisante, car elle permet d’accéder
à l’environnement du langage depuis ce même langage. Cependant, elle ne nous permettra pas de définir
des fonctions récursives. Pour cela il aurait fallu accéder à des listes <span style="font-style:italic">mutables</span>.
Nous avons donc finalement pris l’option de l’environnement modélisé par une fonction. Nous présenterons
cependant les deux approches et nous les décrirons en détails.</p><p>Une fois cet intépréteur réalisé, nous l’utiliserons pour implémenter un nouvel intepréte avec quelques variantes:
liaison <span style="font-style:italic">dynamique</span> et <span style="font-style:italic">statique</span>, évaluation <span style="font-style:italic">stricte</span> et <span style="font-style:italic">paresseuse</span> et enfin un intépréte par <span style="font-style:italic">continuation</span>.
Pour ces différentes variantes, nous nous inspirons de notre bible sur le langage LISP : <span style="font-style:italic">LISP In Small Pieces</span> de Christian Queinnec.</p>
<!--TOC section id="sec17" Un interprète MiniScheme avec OCAML-->
<h2 id="sec17" class="section">2.2  Un interprète MiniScheme avec OCAML</h2><!--SEC END -->
<!--TOC subsection id="sec18" typage des expressions et des valeurs-->
<h3 id="sec18" class="subsection">2.2.1  typage des expressions et des valeurs</h3><!--SEC END --><p>Nous implémentons deux types mutuellement récursifs. L’un pour modéliser les expressions SCHEME et l’autre
pour modéliser les valeurs.
Un interprète est principalement une fonction <span style="font-style:italic">eval</span> telle que <span style="font-style:italic">eval</span>(<span style="font-style:italic">expression</span>) = <span style="font-style:italic">valeur</span></p><p>Voici le code OCAML de ce type abstrait:</p><pre class="verbatim">type lobject =
  | Entier of int
  | Booleen of bool
  | Symbole of string
  | Nil
  | Paire of lobject * lobject
  | Primitive of string * (lobject list -&gt; lobject)
  | Quote of value      
  | Closure of name list * exp *  env   
  
and value = lobject
and name = string
and exp =
  | Literal of value
  | Var of name
  | If of exp * exp * exp
  | And of exp * exp
  | Or of exp * exp
  | Call of exp * exp list
  | Lambda of name list * exp    
  | Defexp of def

and def =
  | Val of name * exp
</pre><p>En SCHEME, une expression <code>exp</code> est ainsi:
</p><ul class="itemize"><li class="li-itemize">
un littéral qui peut représenter toutes les valeurs possibles
</li><li class="li-itemize">une variable de type string
</li><li class="li-itemize">une application qui est modélisée par le constructeur <code>Call</code>
</li><li class="li-itemize">une définition
</li><li class="li-itemize">un certain nombres de procédure spéciales appelées primitives <code>if, or, and ...</code>
</li></ul><p>L’approche retenue ici est donc de bien différencier le type d’une expression du type de sa valeur.
En SCHEME, nous aurions pu néanmoins nous abstenir de cette différenciation, car finalement une expression SCHEME est syntaxiquement
la même que sa valeur.
Il se trouve que cette différentiation (type expression ≠ type valeur) complique finalement pas mal de choses. Nous le verrons spécifiquement avec la fonction 
<code>quote</code>. Mais cela s’avère cependant pédagogique...
Nous ne ferons plus ce choix pour l’implémentation de l’interprète SCHEME en SCHEME.</p>
<!--TOC subsection id="sec19" Les étapes Read, Eval, Print-->
<h3 id="sec19" class="subsection">2.2.2  Les étapes Read, Eval, Print</h3><!--SEC END --><p>
L’interpréte présente trois étapes que l’on décrit souvent avec l’acronyme <span style="font-style:italic">REPL</span> :
Read, Eval, Print, Loop</p><p>L’étape <span style="font-style:italic">READ</span> sera effectuée avec les moteurs ocamllex et ocmalyacc.
Cette étape va lire la saisie clavier et construire l’arbre syntaxique des expressions SCHEME.</p><p>Voici quelques exemples d’arbres syntaxiques générés avec Yacc.
Ces arbres syntaxiques sont à nouveau dessiné avec le package Tikz et nous avons développé une petite
fonction qui parcourt l’expression et génère le code Tikz.</p><p><code>(moins 4 3)</code>
</p><div class="center">
[level distance=1.5cm]
call child node var child  nodemoins  
child node exp list child  node 4  child  node 3  
;</div><p><code>(if #t (plus 4 5) (moins 3 2))</code>
</p><div class="center">
[ level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm, level 3/.style=sibling distance=1.5cm]<p>if child  node true child node call child  node var child  nodeplus 
child node exp list child  node 4  child  node 5    child node call child
 node var child  nodemoins  child node exp list child  node 3  child  node 2   
;</p></div><p>Et enfin une expression let <code>(let ((a 2) (b 3)) (plus a b))</code>
</p><div class="center">
[ level 1/.style=sibling distance=3.5cm,
level 2/.style=sibling distance=2cm, level 3/.style=sibling distance=1.5cm]
let child  child  node bind child  nodea  child node 2 child  node bind child  nodeb 
child node 3  child node body let childnode call child  node var child  nodeplus 
child node exp list child  node var child  nodea  child  node var child  nodeb     ;

</div><p>L’étape <span style="font-style:italic">EVAL</span> va parcourir l’arbre syntaxique de l’expression, traiter cette expression et
en exprimer une valeur modélisée avex le type <code>value</code></p><p>La fonction <code>evalexp</code> est une fonction prenant comme arguments une expression de type <code>exp</code> et un environnement.
Elle retourne une valeur de type <code>value</code>. Voici sa signature: <br>
<code>val evalexp : exp -&gt; env -&gt; value = &lt;fun&gt;</code></p><p>L’étape <span style="font-style:italic">PRINT</span> n’est autre que la fonction d’affichage finale de l’interprète.
Une fois cette étape finie, l’interprète boucle sur l’étape initiale <span style="font-style:italic">READ</span></p>
<!--TOC subsection id="sec20" Liaison lexicale vs liaison dynamique-->
<h3 id="sec20" class="subsection">2.2.3  Liaison lexicale vs liaison dynamique</h3><!--SEC END --><p>
Nous allons utiliser ici la liaison lexicale (statique), et non dynamique.
Cela nous impose de capturer l’environnement existant au moment de la définition de la fonction. 
Plus précisément, l’environnement est capturé par l’évaluation de la lambda, évaluation dont la valeur est appelée une <span style="font-style:italic">closure</span>
ou <span style="font-style:italic">fermeture</span>. <br>
<code> Lambda (parametres, expression) -&gt; Closure (parametres, expression, env) </code> <br>

Dans le cas de la liaison dynamique, la fonction est appliquée en utilisant l’environnement courant, et non pas son
environnement de définition. Donc pas besoin de fermeture.</p><p>A ma connaissance, la liaison statique est maintenant utilisée dans la plupart des langages fonctionnels.
En SCHEME et ML,nous pouvons voir dans l’exemple ci-dessous que l’évaluation de la définition de la
lambda <code>inc_x</code> capture la valeur de <code>x</code> .
<br>

</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >SCHEME</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >ML </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>&gt; (define x 1)</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code># let x = 1</code> ;; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>&gt; (define inc_x (lambda () (+ x 1)))</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code># let inc_x = function () -&gt; x+1 ;;</code> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>&gt; (inc_x)</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code># inc_x ()</code> ;; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>2</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>- : int = 2</code> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>&gt; (let ((x 100)) (inc_x))</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code># let x = 100 in inc_x () ;;</code> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>2</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code>- : int = 2</code> </td></tr>
</table><p>
<br>

</p>
<!--TOC subsection id="sec21" Gestion de l’environnement-->
<h3 id="sec21" class="subsection">2.2.4  Gestion de l’environnement</h3><!--SEC END --><p>Comme indiqué en préambule, plusieurs choix sont possibles pour la modélisation de l’environnement.
Le choix le plus simple est une représentation par une liste de paires <span style="font-style:italic">variable</span> ↔ <span style="font-style:italic">value</span>
Ce choix peut être fait en OCAML par le type natif <code>list</code> ou en utilisant le type concret <code>Paire of Symbole * lobject</code></p><p>La principale difficulté est la représentation de fonctions récursives, comme en exemple la factorielle ci-dessous:
</p><pre class="verbatim">(define fact 
 (lambda (n) 
  (if (eq? n 0) 
    1
    (* n (fact (- n 1)))))
</pre><p>
Nous devons capturer l’environnement existant au moment de la définition de la fonction.
Cet environnement existant ne contient pas déjà la définition de <code>fact</code>.</p><p>Il y a trois possibilités pour traiter ce problème de représentation d’un environnement <span style="font-style:italic">récursif</span>.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Utiliser une structure de liste qui permet à l’environnement capturé lors de la cloture de la lambda de boucler sur lui-même
La matérialisation de cette boucle ne peut à ma connaissance qu’être réalisée par un type liste <span style="font-style:italic">mutable</span>.<p>Comment construire un environnement qui contient la fonction que l’on est en train de définir ?
</p><pre class="verbatim">envRec =  (fac, &lt;lambda corps&gt;, envRec) :: env 
</pre><p>
C’est une équation de point fixe…</p><p>On remarquera également que le <code>letrec</code> de SCHEME peut être sémantiquement remplacé par un <code>let</code> associé de <code>set!</code>
Et de la même manière, nous pouvons faire cette opération en ML, avec l’unique nuance est que le <code>let</code> temporaire repréente bien
une fonction pour que la cohérence des types soit assurée.</p><pre class="verbatim">SCHEME
(letrec ((f e))
  corps)
  ==&gt;
 (let ((f 'any))
    (let ((f-aux e))
       (set! f f-aux)
       corps))

(let ((fact 'any))
      (let ((f-aux (lambda (n) (if (eq? n 0) 1 (* n (fact (- n 1)))))))
        (set! fact f-aux))
  (fact 5))

OCAML 
let fact = ref (function x -&gt; x) in
 let aux n = if n=0 then 1 else n * !fact (n - 1) in
  fact:= aux ; !fact 5
</pre></li><li class="li-enumerate">Dans le cas de fonction récursive, ne plus nous reposer sur l’environnement mais, comme en λ-calcul, 
utiliser un combinateur de point fixe qui permet de calculer le point fixe de notre fonction, sans avoir à la nommer.
Nous rappelons ci-dessous un exemple de combinateur implémenté en SCHEME, et comment il peut être utilisé.
<pre class="verbatim">(define Y
(lambda(f)
 (let ((g (lambda (h) (lambda(x) ((f (h h) x))))))
  (g g))))

(define F*
  (lambda (f)
    (lambda (n)
      (if (eq? n 0)
          1
          (* n (f (- n 1)))))))
          
 (define fact (Y F*))
</pre></li><li class="li-enumerate">La troisième approche est de modéliser l’environnement par une fonction, et non plus une liste d’association.
La consultation de l’environnement consiste à appliquer la fonction <code>env</code> qui le représente.<p>Considérons l’expression <code>(letrec ((x1 e1) ... (xn en)) corps)</code> qui, on le rappelle, est équivalente à 
<code> ((lambda (x1 ... xn) corps) e1 ... en)</code></p><p>L’environnement capturé <code>envRec</code> au moment de la définition de la lambda doit correspondre à 
l’environnement étendu aux <code>xi</code> dont les valeurs sont données par l’évaluation des <code>ei</code> de la lambda 
dans cet environnement <code>envRec</code>
C’est nécessaire afin que les <code>ei</code> puissent faire appel à des références récursives des <code>xi</code>.</p><p>Nous avons ainsi (et à nouveau) une équation de point fixe:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">  </td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >    <span style="font-style:italic">envRec</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">eval</span> (<span style="font-style:italic">e</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">envRec</span>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >    <span style="font-style:italic">envRec</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">env</span> (<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)  <span style="font-style:italic">si</span>  <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> ∉ <span style="font-style:italic">letrec</span>
</td></tr>
</table></td></tr>
</table></li></ol>
<!--TOC section id="sec22" Un interprète LISP avec le nouvel interprète MiniScheme …-->
<h2 id="sec22" class="section">2.3  Un interprète LISP avec le nouvel interprète MiniScheme …</h2><!--SEC END -->
<!--TOC section id="sec23" Un interprète MiniML -->
<h2 id="sec23" class="section">2.4  Un interprète MiniML </h2><!--SEC END -->
<!--TOC subsection id="sec24" L’inférence de type-->
<h3 id="sec24" class="subsection">2.4.1  L’inférence de type</h3><!--SEC END -->
<!--TOC subsection id="sec25" Le pattern matching-->
<h3 id="sec25" class="subsection">2.4.2  Le pattern matching</h3><!--SEC END -->
<!--TOC chapter id="sec26" La compilation-->
<h1 id="sec26" class="chapter">Chapitre 3  La compilation</h1><!--SEC END -->
<!--TOC section id="sec27" Le λ-calcul comme byte-code-->
<h2 id="sec27" class="section">3.1  Le λ-calcul comme byte-code</h2><!--SEC END -->
<!--TOC chapter id="sec28" La résolution-->
<h1 id="sec28" class="chapter">Chapitre 4  La résolution</h1><!--SEC END -->
<!--TOC section id="sec29" Représentation des termes finis-->
<h2 id="sec29" class="section">4.1  Représentation des termes finis</h2><!--SEC END --><p>Les symboles de constante <code>true</code>, <code>158</code>, les symboles de fonctions unaires <code>not</code>, <code>+</code>,
les symboles de fonctions binaires <code>or</code>, etc. constituent la signature Σ du langage.
Si <span style="font-style:italic">f</span> est d’arité <span style="font-style:italic">n</span> ≥ 1, alors <span style="font-style:italic">f</span> est un symbole fonctionnel, et si <span style="font-style:italic">f</span> est d’arité 0, <span style="font-style:italic">f</span> est un symbole de constante.
Nous ajoutons à Σ un ensemble <span style="font-style:italic">X</span> de symboles de variables.</p><p>L’ensemble des termes <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub> est défini de la manière suivante:
</p><ul class="itemize"><li class="li-itemize">
	si <span style="font-style:italic">c</span> ∈ Σ et <span style="font-style:italic">c</span> d’arité 0, alors <span style="font-style:italic">c</span> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub> 
	</li><li class="li-itemize">si <span style="font-style:italic">f</span> ∈ Σ et <span style="font-style:italic">f</span> d’arité <span style="font-style:italic">n</span> ≥ 1 avec <span style="font-style:italic">M</span><sub>1</sub>, …, <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub>, alors <span style="font-style:italic">f</span> <span style="font-style:italic">M</span><sub>1</sub> ... <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub>
	</li><li class="li-itemize">si <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">X</span>, alors <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub>
</li></ul><p>Nous pouvons représenter les termes en OCAML avec le type abstrait suivant:
</p><pre class="verbatim"> type terme = 
 | Var of string
 | Func of string * terme list
</pre><p>En fait, quasiment tous les objets que nous manipulerons pourront être modélisés par des termes.
Prenons l’exemple suivant pour définir le <span style="font-style:italic">type</span> des entiers naturels à partir de la signature Σ = {<span style="font-style:italic">O</span>, <span style="font-style:italic">S</span>}
Les symboles <span style="font-style:italic">O</span> et <span style="font-style:italic">S</span> sont respectivement d’arité 0 et 1.
Nous avons ainsi : </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sub>Σ</sub>= {0, <span style="font-style:italic">SO</span>, <span style="font-style:italic">SSO</span>, <span style="font-style:italic">SSSO</span>, ... } </td></tr>
</table><p>
En OCAML, nous pourrons écrire:
</p><pre class="verbatim">type nat = Zero | S of nat 
</pre><p>
En Prolog:
</p><pre class="verbatim">nat(zero).
nat(s(X)) :- nat(X)
</pre>
<!--TOC section id="sec30" La substitution-->
<h2 id="sec30" class="section">4.2  La substitution</h2><!--SEC END --><p>
Une substitution est une application θ : <span style="font-style:italic">X</span> → <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> </p><p>Le domaine de substitution est l’ensemble des variables de <span style="font-style:italic">X</span> telles que θ (<span style="font-style:italic">x</span>) ≠ <span style="font-style:italic">x</span>
On dit aussi que l’application θ est l’identité <span style="font-style:italic">presque</span> partout, i.e sauf sur une partie finie
de <span style="font-style:italic">X</span>.
Considérons le domaine de θ = {<span style="font-style:italic">x</span><sub>1</sub>, ..., <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>}, alors θ est représenté par l’ensemble
des couples (variable, terme) {(<span style="font-style:italic">x</span><sub>1</sub>, θ (<span style="font-style:italic">x</span><sub>1</sub>), ...,(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, θ (<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>) } </p><p>Nous avons:
</p><ul class="itemize"><li class="li-itemize">
	θ <span style="font-style:italic">c</span> = <span style="font-style:italic">c</span>, si <span style="font-style:italic">c</span> ∈ Σ d’arité 1
	</li><li class="li-itemize">θ (<span style="font-style:italic">f</span> <span style="font-style:italic">M</span><sub>1</sub> … <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub>) = <span style="font-style:italic">f</span>(θ <span style="font-style:italic">M</span><sub>1</sub> … θ <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> ), si <span style="font-style:italic">f</span> ∈ Σ d’arité <span style="font-style:italic">n</span> 
	</li><li class="li-itemize">θ <span style="font-style:italic">x</span> = θ (<span style="font-style:italic">x</span>) si <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">X</span>
</li></ul><p>
Attention à la confusion, le nom θ est donc aussi donné à application de <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> → <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> , en
plus de l’application <span style="font-style:italic">X</span> → <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> </p><p>Voici un exemple d’implémentation de la substitution en OCAM:
</p><pre class="verbatim">let rec substituer terme sigma  =
  match terme with
  | Var(x) -&gt; (valeur_subst sigma terme)
  | Func(f, []) -&gt; Func(f, []) 
  | Func(f, args) -&gt; Func(f, (map (function t -&gt; (substituer t sigma)) args))
</pre>
<!--TOC section id="sec31" Filtrage et réécriture. L’arithmétique de Peano-->
<h2 id="sec31" class="section">4.3  Filtrage et réécriture. L’arithmétique de Peano</h2><!--SEC END --><p>
Il est très simple de programmer en OCAML une fonction de réécriture.
Appliquons cela sur l’arithmétique de Peano.</p><p>Peano a reconstruit la théorie des
entiers à partir de la fonction successeur. On se donne uniquement le symbole
<span style="font-style:italic">S</span> d’arité 1 et le symbole de constante 0.
Les entiers sont les termes de la forme 0, <span style="font-style:italic">S</span>0, <span style="font-style:italic">SS</span>0, <span style="font-style:italic">SSS</span>0 …
Nous pouvons implémenter cela en OCAM avec le type abstrait <code>peano</code>
</p><pre class="verbatim">type peano = 
 | Zero
 | Succ of peano
 | Plus of peano * peano
    | Mult of peano * peano

let un = Succ Zero ;;
let deux = Succ (Succ Zero) ;;
let trois = Succ (Succ (Succ Zero)) ;;

</pre><p>Puis nous avons les quatres règles de réécriture suivante:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>1</sub>)</td><td style="text-align:left;white-space:nowrap" >(+ <span style="font-style:italic">x</span> 0) → <span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>2</sub>)</td><td style="text-align:left;white-space:nowrap" >(+  <span style="font-style:italic">x</span> (<span style="font-style:italic">S</span> <span style="font-style:italic">y</span>)) → (<span style="font-style:italic">S</span> (+<span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>3</sub>)</td><td style="text-align:left;white-space:nowrap" >(* <span style="font-style:italic">x</span> 0) → 0 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>4</sub>)</td><td style="text-align:left;white-space:nowrap" >(* <span style="font-style:italic">x</span> (<span style="font-style:italic">S</span> <span style="font-style:italic">y</span>)) → (+ <span style="font-style:italic">y</span> (* <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)) </td></tr>
</table></td></tr>
</table><p>
Ces quatre règles sont implémentées par la fonction <code>réduire</code> ci-dessous:
</p><pre class="verbatim">let rec reduire = function
 | Plus (p, Zero) -&gt; reduire p
 | Plus (p1 , (Succ p2)) -&gt; Succ ( reduire ((Plus (reduire p1, reduire p2))) )
 | Mult (p, Zero) -&gt; Zero
 | Mult (p1, (Succ p2)) 
     -&gt; reduire (Plus (reduire p1, reduire ((Mult (reduire p1, reduire p2))) ))
    | _ as p -&gt; p 

let rec peano_entier = function
 | Zero -&gt; 0
 | Succ p -&gt; 1 + (peano_entier p)
 | any -&gt; peano_entier (reduire any)
 
peano_entier (Plus ( Mult(deux, trois), trois));;
</pre>
<!--TOC section id="sec32" L’unification des termes-->
<h2 id="sec32" class="section">4.4  L’unification des termes</h2><!--SEC END --><p>
Un interprète PROLOG peut être considéré comme une machine à unifier.
Définissons d’abord l’opération d’unification de deux termes.</p><p>Un unificateur de deux termes <span style="font-style:italic">t</span><sub>1</sub> et <span style="font-style:italic">t</span><sub>2</sub> est une substitution σ telle que σ <span style="font-style:italic">t</span><sub>1</sub> = σ <span style="font-style:italic">t</span><sub>2</sub></p><p>Description de l’agorithme d’unification.</p><p>Soit <span style="font-style:italic">E</span>, un système d’équations, on peut définir des transformations <span style="font-style:italic">E</span><sub>1</sub> → <sub><span style="font-style:italic">t</span></sub> <span style="font-style:italic">E</span><sub>2</sub> 
entre systèmes d’équations. On note le symbole ⊥ qui représente un système sans solution.
Résoudre <span style="font-style:italic">E</span><sub>0</sub> consiste à appliquer une suite de transformations <span style="font-style:italic">E</span><sub>0</sub> → <sub>*</sub> <span style="font-style:italic">E</span><sub><span style="font-style:italic">n</span></sub>  de sorte que
<span style="font-style:italic">E</span><sub><span style="font-style:italic">n</span></sub> soit en forme résolue, ou bien <span style="font-style:italic">E</span><sub><span style="font-style:italic">n</span></sub> = ⊥</p><p>Nous avons six types de transformation possibles: <br>

</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >décomposition</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">f</span> <span style="font-style:italic">M</span><sub>1</sub> … <span style="font-style:italic">M</span><sub><span style="font-style:italic">r</span></sub> = <span style="font-style:italic">f</span> <span style="font-style:italic">N</span><sub>1</sub> … <span style="font-style:italic">N</span><sub><span style="font-style:italic">r</span></sub> } → <span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">M</span><sub>1</sub> = <span style="font-style:italic">N</span><sub>1</sub> , … ,<span style="font-style:italic">M</span><sub><span style="font-style:italic">r</span></sub> = <span style="font-style:italic">N</span><sub><span style="font-style:italic">r</span></sub> }  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >effacement</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">M</span>=<span style="font-style:italic">M</span> } → <span style="font-style:italic">E</span>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >élimination</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } → <span style="font-style:italic">E</span>[<span style="font-style:italic">x</span>:=<span style="font-style:italic">M</span>] ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } si <span style="font-style:italic">M</span> ∉ <span style="font-style:italic">X</span>, <span style="font-style:italic">x</span> ∉ <span style="font-style:italic">var</span>(<span style="font-style:italic">M</span>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >inversion</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">M</span>=<span style="font-style:italic">x</span> } → <span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } si <span style="font-style:italic">M</span> ∉ <span style="font-style:italic">X</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >conflit</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">f</span> <span style="font-style:italic">M</span> = <span style="font-style:italic">g</span> <span style="font-style:italic">M</span>} → ⊥  si  <span style="font-style:italic">f</span> ≠ <span style="font-style:italic">g</span>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >cycle</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } → ⊥  si <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">var</span>(<span style="font-style:italic">M</span>) </td></tr>
</table><p><br>
</p><p>La difficulté de cet algorithme est sa condition d’arrêt. 
Si aucune règle ne peut plus s’appliquer sur les éléments du système d’équation, alors l’algorithme doit s’arrêter et son résultat est
la substitution unifiant les deux termes initiaux.
Avec une seule fonction parcourant le système d’équations, représentés en OCAML par le type <code>(term * term) list</code>,
je pense que ce n’est pas possible. Je me suis là aussi un peu cassé les cheveux.
Voici mon code avec deux fonctions:
</p><pre class="verbatim">let rec  unifier equation =
match equation with
| (Var(x),Var(y)) -&gt; if x=y then [] else [(Var(x), Var(y))] 
| (Func(f1,l1),Func(f2, l2)) -&gt; if f1 = f2 &amp;&amp; List.length l1 = List.length l2 
 then unifierliste (List.combine l1 l2)
 else raise Impossible
| (Func(m,n),Var(x)) -&gt; unifier8 (Var(x), Func(m,n)) 
| (Var(x), Func(m,n)) -&gt; if (mem (Var(x)) (listevar (Func(m,n)))) 
 then raise Impossible
 else [(Var(x), Func(m,n)) ] 
and unifierliste = function
| [] -&gt; []
| (x,y)::t -&gt;
 let t2 = unifierliste t in
 let t1 = unifier ((substituer x t2 ),(substituer y t2)) in
 t1 @ t2
</pre><p>
On retrouve dans la fonction <code>unifier</code>, qui travaille uniquement sur une paire de terme, les différentes règles
de l’algorithme. La fonction <code>unifierliste</code> va unifier sa première paire en utilisant la substitution trouvée dans le reste
de l’équation. C’est un bel exemple de récursivité qui nous dépasse souvent…Ce bout de code vient du site de l’université de Cornell.</p><p>Voici un autre exemple moins proche de l’algorithme présenté.
</p><pre class="verbatim">let unifier t1 t2 =
  let rec unificateur t1 t2 =
    match (t1,t2) with
    | (Var(x), _)  -&gt; 
      begin
        if t1 = t2 then [] 
        else if (mem t1 (listevar t2)) then raise Impossible
             else [(t1, t2)]
      end    
    | (_, Var(x)) -&gt; unificateur t2 t1
    | (Func(x, l1), Func(y, l2)) -&gt; if x&lt;&gt;y then raise Impossible
      else (unifliste l1 l2 [])
  and unifliste l1 l2 sigma =
    match (l1, l2) with
    | ([], _) -&gt; sigma
    | (h1::t1, h2::t2) -&gt;
      begin
        let sigma1 = (unificateur h1 h2) in
        unifliste (map (function terme -&gt; (substituer terme sigma1)) t1)
          (map (function terme -&gt; (substituer terme sigma1)) t2)
          (compose_subst sigma sigma1)
      end  
    | _ -&gt; raise Impossible
  in unificateur t1 t2 
</pre>
<!--TOC section id="sec33" Un mini PROLOG-->
<h2 id="sec33" class="section">4.5  Un mini PROLOG</h2><!--SEC END --><pre class="verbatim">let question() =
 begin
   print_string "\n autre solution 1/2 (1=oui, 2=non) ? :" ;
   if read_int()= 1  then false else true 
 end
  
let autre_solution lvar lvaleur  =
 if lvaleur &lt;&gt; [] then (affiche_solution lvar lvaleur ; question())
 else false 
  
let prolog but lregles =
 let lvar_but = listevar but in
 let rec prouveli lbuts lvaleur =
   match lbuts with
   | [] -&gt; autre_solution lvar_but lvaleur
   | h::t -&gt; 
  some (fun regle -&gt;  try
     let regle_bis = (renomme regle) in
     let sigma1 = unifier h (hd regle_bis) in   
     prouveli 
       (sublis sigma1 ((lhypotheses regle_bis) @ t))
       (sublis sigma1 lvaleur)  
      with Impossible -&gt; false)
    lregles 
 in
 prouveli [but] lvar_but
  
</pre>
<!--TOC section id="sec34" Quelques exemples de programmation en PROLOG-->
<h2 id="sec34" class="section">4.6  Quelques exemples de programmation en PROLOG</h2><!--SEC END --><p>
Définissons en PROLOG le type des entiers naturels avec la fonction <code>nat</code> d’arité 1, la fonction <code>s</code>
d’arité 1 et la constante <code>0</code>.
Nous avons ainsi les 2 règles:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">nat</span>(0) ⇐ </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">nat</span>(<span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>)) ⇐ <span style="font-style:italic">nat</span>(<span style="font-style:italic">x</span>)
</td></tr>
</table></td></tr>
</table><pre class="verbatim">---------------------------------------------------
let nat = [ [Func("nat", [Func("0", [])])] ;
            [Func("nat", [Func("s",[Var("X")])]) ; Func("nat", [Var("X")])] ] ;;
let but = Func("nat", [Var("X")]) ;; 

prolog but nat ;;
----------------------------------------------------
vincent@HP-Notebook:~/workspace vscodium$ ./prolog.byte 
 X  &lt;-&gt;  0 
 autre solution 1/2 (1=oui, 2=non) ? :1
 X  &lt;-&gt; (s 0 )
 autre solution 1/2 (1=oui, 2=non) ? :1
 X  &lt;-&gt; (s(s 0 ))
 autre solution 1/2 (1=oui, 2=non) ? :1
 X  &lt;-&gt; (s(s(s 0 )))
 autre solution 1/2 (1=oui, 2=non) ? :2
vincent@HP-Notebook:~/workspace vscodium$ 

</pre>
<!--TOC chapter id="sec35" Annexes / Divers-->
<h1 id="sec35" class="chapter">Chapitre 5  Annexes / Divers</h1><!--SEC END -->
<!--TOC section id="sec36" Quelques fonctions sur les listes-->
<h2 id="sec36" class="section">5.1  Quelques fonctions sur les listes</h2><!--SEC END --><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-size:small">SCHEME</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-size:small">OCAML </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
(define (somme l)
 (if (null? l)
   0
   (+ (car l) (somme (cdr l)))))
   
</span></pre><span style="font-size:small">
</span></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
let rec somme l =
  match l with
  | [] -&gt; 0
  | hd::tl -&gt; hd + somme(tl)  
  
</span></pre><span style="font-size:small"> 
</span></div><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><pre class="verbatim"><span style="font-size:small">
f car (f car (... (f car acc)...))

(define (foldright f acc l)
 (if (null? l)
  acc
  (f (car l) (foldright f acc (cdr l)))))
  
</span></pre></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><pre class="verbatim"><span style="font-size:small">
f hd (f hd (... (f hd acc)...))

let rec foldright f acc l =
  match l with
  | [] -&gt; acc
  | hd::tl -&gt; f hd (foldright f acc tl)
  
</span></pre></div><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
f (... (f (f acc car) car)...) car) 

(define (foldleft f acc l)
 (if (null? l)
  acc
  (foldleft f (f (car l) acc) (cdr l))))
  
</span></pre><span style="font-size:small">
</span></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
f (... (f (f acc hd) hd)...) hd) 

let rec foldleft f acc l =
  match l with
  | [] -&gt; acc
  | hd::tl -&gt; foldleft f (f acc hd) tl
  
</span></pre><span style="font-size:small">
</span></div><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
(foldleft * 1 '(1 2 3 4))
-&gt; 24

</span></pre><span style="font-size:small">
</span></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
# foldleft ( * ) 1 [1;2;3;4] ;;
- : int = 24

</span></pre><span style="font-size:small">
</span></div><span style="font-size:small"> </span></td></tr>
</table>
<!--TOC section id="sec37" Les listes mutables-->
<h2 id="sec37" class="section">5.2  Les listes mutables</h2><!--SEC END --><p>En SCHEME, nous avons les fonctions <code>ser-car!</code> et <code>set-cdr!</code> qui nous permettent de modifier physiquement
le car et le cdr d’un doublet.
Nous pouvons par exemple définir la liste circulaire <code>(a b c a b c ...)</code>
</p><pre class="verbatim">(define maliste (list 'a 'b 'c))
(set-cdr! (cddr maliste) maliste)
 maliste
 -&gt; #0= (a b c . #0#)
</pre><p>
L’affichage de la liste infine provient de l’interprète DrRacket.</p><p>Essayons de reproduire cela en OCAML
(de manière intuitive et sûrement très maladroite…)
</p><pre class="verbatim">
exception Listenulle
type liste = Nil | Cons of int ref * liste ref ;;

let set_car d v =
 match d with
 | Nil -&gt; raise Listenulle
 | Cons(car,cdr) -&gt; car:=v  ;;
 
let set_cdr d v =
 match d with
 | Nil -&gt; raise Listenulle
 | Cons(car,cdr) -&gt; cdr:=v ;;
 
let  cdr l =
 match l with
 | Nil -&gt; raise Listenulle
 | Cons(tete, reste) when !reste &lt;&gt; Nil -&gt; reste

let maliste = Cons(ref 1 , ref ( Cons (ref 2, ref ( Cons (ref 3, ref Nil))) ))
set_cdr (!cdr !(cdr maliste)) maliste ;;

# maliste;;
- : liste =
Cons ({contents = 1},
 {contents =
   Cons ({contents = 2},
    {contents =
      Cons ({contents = 3},
       {contents =
         Cons ({contents = 1},
          {contents =
            Cons ({contents = 2},
             {contents =
               Cons ({contents = 3},
                ...
                
</pre>
<!--TOC section id="sec38" Les listes infinies ou <span style="font-style:italic">streams</span>-->
<h2 id="sec38" class="section">5.3  Les listes infinies ou <span style="font-style:italic">streams</span></h2><!--SEC END --><p>	
Les <span style="font-style:italic">streams</span> sont des listes infinies. 
Pour les représenter, nous utilisons le fait que le corps d’une lambda n’est pas évalué, comme nous avons pu le voir en λ-calcul avec la
stratégie de β-réduction faible</p><p>Un <span style="font-style:italic">stream</span> sera ainsi représenté comme une liste, mais dont le <code>cdr</code> ne pointera plus directement 
sur une liste, mais sera une fonction dont le corps sera la liste. L’évaluation du <code>cdr</code> est ainsi retardé.</p><pre class="verbatim">type 'a stream = Cons of 'a * (unit -&gt; 'a stream) ;;
let hd (Cons (h, _)) = h ;;
let tl (Cons (_, tf)) = tf () ;;

let rec from n = Cons (n, fun () -&gt; from (n+1));;
let entiers = from 0 ;;
let rec take n s =
  if n=0 then []
  else hd s :: take (n-1) (tl s) ;;

# take 30 entiers
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20;
 21; 22; 23; 24; 25; 26; 27; 28; 29]
</pre><p>Nous pouvons aussi modéliser la fraction continue représentant √<span style="text-decoration:overline">2</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hbar"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> = 1 + </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="hbar"></td></tr>
<tr><td class="dcell" >...
</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell">
    (1)</td></tr>
</table><p>
Voici le code OCAML. Je n’ai pas trouvé manière plus élégante pour exprimer le stream.
</p><pre class="verbatim">let rec square2 iter =
  if (iter = 1) then 1.
  else
  1. +. ( 1. /. ( 1. +. square2 (iter - 1)))

let rec racine2cons n = Cons(square2 n, fun () -&gt; racine2cons (n+1))

let rec racine2stream = racine2cons 1
  in take 10 racine2stream ;;

- : float list =
[1.; 1.5; 1.4; 1.41666666666666674; 1.4137931034482758; 1.41428571428571437;
 1.41420118343195256; 1.41421568627450989; 1.41421319796954315;
 1.41421362489486957]
</pre><p>
Nous voyons la convergence très rapide de la fraction continue.</p><p>Cependant, le calcul OCAML est très inefficace, car chaque nouvel élément de la liste recalcule la totalité de la fraction continue
en passant par la fonction <code>square2 iter</code>. Si nous essayons par exemple de calculer les 10000 premiers éléments du stream, cela prend sur ma machine une
dizaine de seconde. </p><p>En utilisant le module <code>Lazy</code> d’OCAML, nous pouvons utiliser le mécanisme de <span style="font-style:italic">mémoisation</span>. Les valeurs du stream ne seront pas recalculé au 
2ème appel.
</p><pre class="verbatim">open Lazy ;;
let racine2_10000 = take 10000 racine2stream  (* environ 10 secondes à chaque appel *)

let racine2_10000_lazy = lazy (take 10000 racine2stream) ;;
let racine2_force = force racine2_10000_lazy ;; (* uniquement long au 1er appel *)
</pre>
<!--TOC section id="sec39" Church encoding reference-->
<h2 id="sec39" class="section">5.4  Church encoding reference</h2><!--SEC END --><p><span style="font-size:small">
</span><span style="font-size:small"><span style="font-family:monospace">https://en.wikipedia.org/wiki/Church_encoding</span></span><span style="font-size:small">
</span></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">+1	</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">+1</span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	</span><span style="font-size:small">succ</span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	... </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> + </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">	</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = </span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">m</span></span></sup><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">) 	</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">plus</span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	λ </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">) 	</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">λ </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small">succ</span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> * </span><span style="font-size:small"><span style="font-style:italic">n</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">*</span><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = (</span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">m</span></span></sup><span style="font-size:small">)</span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	</span><span style="font-size:small">multiply</span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">)  </span><span style="font-size:small"><span style="font-style:italic">x</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	λ </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">)  </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> 	</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">λ </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">) </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span></sup></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> = </span><span style="font-size:small"><span style="font-style:italic">m</span></span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	 </span><span style="font-size:small">exp</span><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">) </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	 λ </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">.(</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">) </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	 λ </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">−1</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	</span><span style="font-size:small">inc</span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> </span><span style="font-size:small">con</span><span style="font-size:small"> = </span><span style="font-size:small">val</span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">−1</span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	</span><span style="font-size:small"><span style="font-style:italic">if</span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">==0) 0 </span><span style="font-size:small"><span style="font-style:italic">else</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">−1)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	
λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> (λ </span><span style="font-size:small"><span style="font-style:italic">g</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">h</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">h</span></span><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">g</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">)) (λ </span><span style="font-size:small"><span style="font-style:italic">u</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">) (λ </span><span style="font-size:small"><span style="font-style:italic">u</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">u</span></span><span style="font-size:small">)  </span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> − </span><span style="font-size:small"><span style="font-style:italic">n</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	</span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">−</span><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small"> = (</span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small">−1</span></sup><span style="font-size:small">)</span><sup><span style="font-size:small"><span style="font-style:italic">n</span></span></sup><span style="font-size:small"> (</span><span style="font-size:small"><span style="font-style:italic">f</span></span><sup><span style="font-size:small"><span style="font-style:italic">m</span></span></sup><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">x</span></span><span style="font-size:small">)</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	</span><span style="font-size:small">minus</span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> = (</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small">pred</span><span style="font-size:small">) </span><span style="font-size:small"><span style="font-style:italic">m</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">	...	</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">λ </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small">.λ </span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small"> </span><span style="font-size:small">pred</span><span style="font-size:small"> </span><span style="font-size:small"><span style="font-style:italic">m</span></span><span style="font-size:small"> </span></td></tr>
</table></td></tr>
</table>
<!--TOC section id="sec40" Le module Graphics d’OCAML, les fractales-->
<h2 id="sec40" class="section">5.5  Le module Graphics d’OCAML, les fractales</h2><!--SEC END --><p>Nous allons ici présenter tres brievement le module Graphics.
Je reprends le code de Xavier Leroy tiré de son livre <span style="font-style:italic">le langage CAML</span></p><pre class="verbatim">open Graphics ;;

Graphics.open_graph "";;
Graphics.set_window_title "THE WINDOW" ;;

type  etat = { mutable x : float; mutable y : float; 
               mutable visee : float; mutable levee : bool };;
let crayon = { x = 0.0; y = 0.0; visee = 0.0; levee = false };; 
let fixe_crayon b = crayon.levee &lt;- b;;

let pi_sur_180 =let pi = 4.0 *. (atan 1.0) in pi /. 180.0 


let tourne angle = crayon.visee &lt;- (crayon.visee +. angle *. pi_sur_180) ;;

let zero_x = float_of_int ((size_x ()) / 2);;
let zero_y = float_of_int ((size_y ()) / 2);;

let vide_ecran () =
 set_color white;
 fill_rect 0 0 (size_x ()) (size_y ());
 set_color black;
 crayon.x &lt;- zero_x;
 crayon.y &lt;- zero_y;
 crayon.visee &lt;- 0.0;
 crayon.levee &lt;- false;
 moveto (round crayon.x) (round crayon.y);;


let avance d =
 let dx = d *. cos (crayon.visee)
 and dy = d *. sin (crayon.visee) in
 crayon.x &lt;- crayon.x +. dx;
 crayon.y &lt;- crayon.y +. dy;
 if crayon.levee then moveto (round crayon.x) (round crayon.y)
 else lineto (round crayon.x) (round crayon.y);;

let rec motif n c =
 if n = 0 then avance c
 else
  begin
   motif (n -1) (c /. 3.0);
   tourne 60.0;
   motif (n -1) (c /. 3.0);
   tourne (-120.0);
   motif (n -1) (c /. 3.0);
   tourne 60.0;
   motif (n -1) (c /. 3.0)
  end;;

let flocon n c =
  for i = 1 to 3 
   do 
     motif n c; tourne (-120.0)
   done;;

  flocon 1 100.0;  flocon 2 100.0;   flocon 3 100.0;  flocon 4 100.0; 

</pre><p><img src="document001.png">
<img src="document002.png">
<img src="document003.png">
<img src="document004.png"></p>
<!--TOC section id="sec41" The boxes-->
<h2 id="sec41" class="section">5.6  The boxes</h2><!--SEC END --><p>
Nous avons vu comment représenter un environnement comme une liste
d’associations avec des paires <code>variable.valeur</code>
Une autre méthode est d’utiliser le principe de <span style="font-style:italic">box</span> qui encapsule la
valeur dans une lambda. La <span style="font-style:italic">box</span> est une lambda qui prend une valeur à  sa
création. Puis elle réagit à  deux messages qui permettent respectivement
d’afficher la valeur capturée ou de la modifier avec la procédure <code>set!</code></p><p>Voici l’implémentation en Scheme:
</p><pre class="verbatim">(define (box value)
  (lambda (msg)
    (case msg
      ("get" value)
      ("set" (lambda (new-value) (set! value new-value))))))

(define (make-box value)
  (box value))

(define maboite (make-box 4))
(maboite "get")
((maboite "set") 5)
</pre><p>En CAML, nous pouvons rédiger le code ci-dessous:
</p><pre class="verbatim">exception Erreur

let box value0 =
 let value = ref value0 in
 fun message -&gt;
  match message with
  | "get" -&gt; (fun any -&gt; print_int !value)
  | "set" -&gt; (fun newvalue -&gt; (value := newvalue ; print_int !value ))
  | "reset"-&gt; (fun any -&gt; (value := value0 ; print_int !value))
  | _ -&gt; raise Erreur
  
  
let maboite = box 5 ;;
(maboite "get") 0 ;;
(maboite "set") 1976 ;;
(maboite "get") 0 ;;
(maboite "reset") 0 ;;
</pre>
<!--TOC section id="sec42" La machine de Turing-->
<h2 id="sec42" class="section">5.7  La machine de Turing</h2><!--SEC END --><p>
Une machine de Turing est un automate à  état (<span style="font-style:italic">state machine</span>) qui a la
capacité de lire puis d’enregistrer un caractère sur une bande de longueur
infinie. </p><p>La machine change d’état sur la base de trois éléments: l’état courant,
le caractère lu de la bande et une table externe de transition. La table de
transition est externe à  la bande et elle est statique.
L’action résultante est un changement potentiel d’état, une écriture de
caractère sur la bande et un déplacement à  droite ou à  gauche de la tête de
lecture.</p><p>Nous implémentons cela avec le concept de <span style="font-style:italic">box</span> présenté dans le chapitre
précédent. La lambda va encapsuler l’état courant, la position de la tête de
lecture, la bande et la table de transition.
La table de transition est modélisée par une a-liste d’a-listes.
La première a-liste permet de faire matcher l’état courant.
La seconde a-liste permet de faire matcher le caractère lu.
Ces deux informations combinées fournissent le triplet de sortie
<code>(état_suivant, caractère_écrit, direction)</code></p><pre class="verbatim">let matable = [ ("q0" , [ ("&gt;", ("q1", "X", "G")) ;
          ("&lt;", ("q0", "&lt;", "D")) ; 
          (" ", ("q2", " ", "G")) ;
          ("X", ("q0", "X", "D")) ]) ;
          ("q1" , [ ("&gt;", ("q1", "&gt;", "G")) ;
                    ("&lt;", ("q0", "X", "D")) ;
                    (" ", ("qf", "non", "G")) ;
                    ("X", ("q1", "X", "G")) ]) ;
          ("q2" , [ ("&gt;", ("q2", "&gt;", "G")) ;
                    ("&lt;", ("qf", "non", "G")) ;
                    (" ", ("qf", "oui", "G")) ;
                    ("X", ("q2", "X", "G")) ]) ;
      ] ;;
</pre><p>Cette table de transition va nous permettre de vérifier le bon parenthésage
d’une expression en entrée fournie sur la bande représentée par une liste 
<code>let mabande =   [" "; "&lt;"; "&gt;"; " "]</code></p><p>L’état <code>q0</code> va rechercher une parenthèse <code>&gt;</code> en allant vers la droite.</p><p>L’état <code>q1</code> va rechercher une parenthèse <code>&lt;</code> en allant vers la gauche.</p><p>L’état <code>q2</code> va rechercher une parenthèse <code>&gt;</code> en allant vers la gauche.</p><p>Les parenthèses matchées sont remplacées par le caractère <code>X</code>.
Le passage à  l’état final <code>qf</code> est accompagné par l’écriture <code>oui</code> ou
<code>non</code> sur la bande suivant si l’expression est ou non correctement parenthésée.</p><pre class="verbatim">
let make_turing table etat0 position0 bande0 =
 let etat = ref etat0 in
 let position = ref position0 in
 let bande = ref bande0 in
 let fct_transition state input = assoc input (assoc state table) in
 let lire () = nth !bande !position in
 let deplacer = function 
  | "G" -&gt; if (!position = 0) then (bande := " " :: !bande) else (position := !position - 1) 
    | "D" -&gt; 
    begin
    position := !position + 1 ;
    if ((lire ()) = " ") then (bande := !bande @ (" ":: []))
     end
  | _ -&gt; raise Erreur
 in
 let rec liste_tail liste pos =
   match pos with
   | 0 -&gt; liste
   | n -&gt; liste_tail (tl liste) (pos - 1)
  in
  let rec liste_tete liste pos =
   match pos with
   | 0 -&gt; []
   | n -&gt; (hd liste) :: liste_tete (tl liste) (pos - 1)
  in
 let ecrire symb =
 bande := (liste_tete !bande !position) @ (symb :: []) @ ( liste_tail (tl !bande) !position)
 in
  fun instruction -&gt;
  match instruction with
  | "executer" -&gt; 
   let (e, s, d) = fct_transition !etat (lire ()) in
      begin
        ecrire s ;
        deplacer d;
        etat := e ;
     if (!etat = "qf") then raise Final 
       end 
  | "reset" -&gt; begin etat := etat0 ; bande := bande0; position := position0 end
  | "affiche"  -&gt; 
      begin print_string "etat:" ; print_string !etat ; 
           print_string "  position:"; print_int !position ; 
        print_string "  lire:"; print_string (lire ()) ;
        print_string "  bande:  "; print_liste !bande
        end 
  | _ -&gt; raise Erreur
  
let executer_turing turing trace =
 let rec iterer () =
  turing "executer" ; if trace then turing "affiche"; iterer () 
 in
 begin
  turing "reset" ;
  try
   iterer () 
  with Final -&gt; turing "affiche"
  end 

</pre><p>Voici le résultat sur l’expression  &lt;&gt; 
</p><pre class="verbatim"># let turing_par = make_turing matable etatinit posinit  [" "; "&lt;"; "&gt;"; " "]  ;;
# executer_turing turing_par true ;;

etat:q0  position:2  lire:&gt;  bande:   &lt;&gt; 
etat:q1  position:1  lire:&lt;  bande:   &lt;X 
etat:q0  position:2  lire:X  bande:   XX 
etat:q0  position:3  lire:   bande:   XX  
etat:q2  position:2  lire:X  bande:   XX  
etat:q2  position:1  lire:X  bande:   XX  
etat:q2  position:0  lire:   bande:   XX  
etat:qf  position:0  lire:   bande:   ouiXX  
</pre><p>Et voici le résultat sur l’expression  &lt;&lt;&gt;&lt;&gt; 
</p><pre class="verbatim"># let turing_par = make_turing matable etatinit posinit  [" "; "&lt;"; "&lt;"; "&gt;"; "&lt;"; "&gt;"; " "] ;;
# executer_turing turing_par true ;;

etat:q0  position:2  lire:&lt;  bande:   &lt;&lt;&gt;&lt;&gt; 
etat:q0  position:3  lire:&gt;  bande:   &lt;&lt;&gt;&lt;&gt; 
etat:q1  position:2  lire:&lt;  bande:   &lt;&lt;X&lt;&gt; 
etat:q0  position:3  lire:X  bande:   &lt;XX&lt;&gt; 
etat:q0  position:4  lire:&lt;  bande:   &lt;XX&lt;&gt; 
etat:q0  position:5  lire:&gt;  bande:   &lt;XX&lt;&gt; 
etat:q1  position:4  lire:&lt;  bande:   &lt;XX&lt;X 
etat:q0  position:5  lire:X  bande:   &lt;XXXX 
etat:q0  position:6  lire:   bande:   &lt;XXXX  
etat:q2  position:5  lire:X  bande:   &lt;XXXX  
etat:q2  position:4  lire:X  bande:   &lt;XXXX  
etat:q2  position:3  lire:X  bande:   &lt;XXXX  
etat:q2  position:2  lire:X  bande:   &lt;XXXX  
etat:q2  position:1  lire:&lt;  bande:   &lt;XXXX  
etat:qf  position:0  lire:   bande:   nonXXXX  
</pre>
<!--TOC section id="sec43" La machine à pile-->
<h2 id="sec43" class="section">5.8  La machine à pile</h2><!--SEC END --><p>
Nous utilisons l’implémentation ci-dessous pour la représentation des piles sous
formes de listes mutables.
</p><pre class="verbatim">type 'a pile = 'a list ref ;;
let empiler x p = p := x :: !p ;;

exception Vide ;;

let depiler p =  
 match !p with
  | [] -&gt; raise Vide
  |x::t -&gt; p:=t ; x ;;

let sommet p =
 match !p with
 | [] -&gt; raise Vide
 | x::t -&gt; x  ;;
</pre><p>La machine à pile exécutera les instructions suivantes:<br>
<code>["EMPILER"; "nombre"],["ADD"], ["SUB"], ["MUL"], ["STOP"]</code></p><p>La lecture d’une instruction est réalisée par la fonction <span style="font-family:monospace">fetch</span>. Cette
fonction parcourt de manière linéaire le code représenté par un <span style="font-style:italic">array</span>.
Chaque <span style="font-family:monospace">fetch</span> incrémente la variable <code>pc</code> qui représente le
<span style="font-style:italic">program counter</span>.</p><pre class="verbatim">exception Erreur ;;
 
let executer code =
 let pc = ref 0 in
 let pile = ref [] in
 let fetch code  =
 begin
  pc := !pc + 1 ; 
  Array.get code (!pc - 1) 
 end 
 in
 let rec exec () =
  let instr = fetch code in
  match instr with
  | ["EMPILER"; n] -&gt; ( empiler (int_of_string n) pile ; exec () )
  | ["ADD"] -&gt; let v2 = depiler pile in let v1 = depiler pile in 
              ( empiler (v1 + v2) pile ; exec () )
  | ["SUB"] -&gt; let v2 = depiler pile in let v1 = depiler pile in
              ( empiler (v1 - v2) pile ; exec () )
  | ["MUL"] -&gt; let v2 = depiler pile in let v1 = depiler pile in
              ( empiler (v1 * v2) pile ; exec () )
  | ["STOP"] -&gt; print_int (sommet pile)
  | _ -&gt; raise Erreur
 in exec ()
</pre><p>Voici l’exécution de la machine à pile:
</p><pre class="verbatim">let code = [| ["EMPILER"; "10"] ;["EMPILER"; "15"] ; ["ADD"] ;
        ["EMPILER"; "4"] ; ["MUL"] ; ["STOP"] |] ;;
        
# executer code ;;
# 100- : unit = ()
</pre>
<!--TOC section id="sec44" L’alphabet grec-->
<h2 id="sec44" class="section">5.9  L’alphabet grec</h2><!--SEC END --><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > α</td><td style="text-align:center;white-space:nowrap" >β</td><td style="text-align:center;white-space:nowrap" >γ</td><td style="text-align:center;white-space:nowrap" >δ</td><td style="text-align:center;white-space:nowrap" >є</td><td style="text-align:center;white-space:nowrap" >ζ</td><td style="text-align:center;white-space:nowrap" >η</td><td style="text-align:center;white-space:nowrap" >θ</td><td style="text-align:center;white-space:nowrap" >ι</td><td style="text-align:center;white-space:nowrap" >κ</td><td style="text-align:center;white-space:nowrap" >λ</td><td style="text-align:center;white-space:nowrap" >µ</td><td style="text-align:center;white-space:nowrap" >ν</td><td style="text-align:center;white-space:nowrap" >ξ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">o</span></td><td style="text-align:center;white-space:nowrap" >π</td><td style="text-align:center;white-space:nowrap" >ρ</td><td style="text-align:center;white-space:nowrap" >σ</td><td style="text-align:center;white-space:nowrap" >τ</td><td style="text-align:center;white-space:nowrap" > υ</td><td style="text-align:center;white-space:nowrap" >φ</td><td style="text-align:center;white-space:nowrap" >χ</td><td style="text-align:center;white-space:nowrap" >ψ</td><td style="text-align:center;white-space:nowrap" >ω </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">A</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td><td style="text-align:center;white-space:nowrap" >Γ</td><td style="text-align:center;white-space:nowrap" >Δ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">E</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">Z</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span></td><td style="text-align:center;white-space:nowrap" >Θ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">I</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">K</span></td><td style="text-align:center;white-space:nowrap" >Λ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">M</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">N</span></td><td style="text-align:center;white-space:nowrap" >Ξ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">O</span></td><td style="text-align:center;white-space:nowrap" >Π</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span></td><td style="text-align:center;white-space:nowrap" >Σ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">T</span></td><td style="text-align:center;white-space:nowrap" >Υ</td><td style="text-align:center;white-space:nowrap" >Φ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">X</span></td><td style="text-align:center;white-space:nowrap" >Ψ</td><td style="text-align:center;white-space:nowrap" >Ω
</td></tr>
</table></td></tr>
</table><p>
Ego, eimi to alfa kai to omega. Eirene umin !</p><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>Ce document a été traduit de L<sup>A</sup>T<sub>E</sub>X par </em><a href="http://hevea.inria.fr"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a></blockquote></body>
</html>
