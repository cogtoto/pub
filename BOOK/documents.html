<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a>Le&#160;calcul<br/>
Réduction&#160;et&#160;résolution<br/>
Exemples&#160;en&#160;Scheme,&#160;ML&#160;et&#160;COQ<br/>
᾿Αγεωμέτρητος&#160;μη&#160;εἰσίτω<br/>
Vincent&#160;Cognet<br/>
Sainte-Marguerite,&#160;le&#160;27&#160;avril&#160;2020<br/>
<a href="https://github.com/cogtoto">https://github.com/cogtoto</a><br/>
<hr/>
<a name=2></a>2<br/>
<hr/>
<a name=3></a><b>Table&#160;des&#160;matières</b><br/>
<a href="documents.html#9"><b>1</b></a><br/>
<a href="documents.html#9"><b>Le&#160;</b><i>λ</i><b>-calcul&#160;et&#160;la&#160;réduction</b></a><br/>
<b>9</b><br/>
<a href="documents.html#9">1.1</a><br/>
<a href="documents.html#9">Définition,&#160;champ&#160;lexical&#160;et&#160;syntaxique&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
9<br/>
<a href="documents.html#9">1.1.1</a><br/>
<a href="documents.html#9">Analyse&#160;lexicale&#160;avec&#160;ocamllex</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
9<br/>
<a href="documents.html#10">1.1.2</a><br/>
<a href="documents.html#10">Analyse&#160;syntaxique&#160;avec&#160;menhir</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
10<br/>
<a href="documents.html#11">1.1.3</a><br/>
<a href="documents.html#11">Implémentation&#160;du&#160;parsing&#160;en&#160;mode&#160;<i>récursif&#160;descendant&#160;</i></a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
11<br/>
<a href="documents.html#13">1.2</a><br/>
<a href="documents.html#13">Représentation&#160;en&#160;ML&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
13<br/>
<a href="documents.html#17">1.3</a><br/>
<a href="documents.html#17">La&#160;<i>β</i>-réduction&#160;faible&#160;avec&#160;appel&#160;par&#160;valeur</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
17<br/>
<a href="documents.html#18">1.4</a><br/>
<a href="documents.html#18">La&#160;récursivité,&#160;le&#160;point&#160;fixe&#160;et&#160;la&#160;diagonale&#160;de&#160;Cantor&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
18<br/>
<a href="documents.html#24">1.5</a><br/>
<a href="documents.html#24"><i>Church&#160;</i>encoding.&#160;Les&#160;entiers&#160;et&#160;les&#160;booléens&#160;en&#160;<i>λ</i>-calcul&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
24<br/>
<a href="documents.html#24">1.5.1</a><br/>
<a href="documents.html#24">Les&#160;entiers&#160;<i>Church&#160;</i></a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
24<br/>
<a href="documents.html#26">1.5.2</a><br/>
<a href="documents.html#26">Les&#160;booléens</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
26<br/>
<a href="documents.html#26">1.5.3</a><br/>
<a href="documents.html#26">La&#160;fonction&#160;factorielle&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
26<br/>
<a href="documents.html#26">1.6</a><br/>
<a href="documents.html#26">La&#160;notation&#160;de&#160;<i>de&#160;Bruijn</i></a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
26<br/>
<a href="documents.html#29"><b>2</b></a><br/>
<a href="documents.html#29"><b>Le&#160;</b><i>λ</i><b>-calcul&#160;simplement&#160;typé&#160;et&#160;les&#160;Pure&#160;Type&#160;Systems</b></a><br/>
<b>29</b><br/>
<a href="documents.html#29">2.1</a><br/>
<a href="documents.html#29">Le&#160;<i>λ</i>-calcul&#160;simplement&#160;typé&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
29<br/>
<a href="documents.html#29">2.1.1</a><br/>
<a href="documents.html#29">Présentation</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
29<br/>
<a href="documents.html#29">2.1.2</a><br/>
<a href="documents.html#29">Implémentation&#160;en&#160;COQ&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
29<br/>
<a href="documents.html#33">2.1.3</a><br/>
<a href="documents.html#33">Inférence&#160;de&#160;type&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
33<br/>
<a href="documents.html#35">2.2</a><br/>
<a href="documents.html#35">Les&#160;<i>Pure&#160;Type&#160;Systems&#160;</i></a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
35<br/>
<a href="documents.html#35">2.2.1</a><br/>
<a href="documents.html#35">Introduction</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
35<br/>
<a href="documents.html#38">2.2.2</a><br/>
<a href="documents.html#38">MiniCOQ&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
38<br/>
<a href="documents.html#40">2.2.3</a><br/>
<a href="documents.html#40">Le&#160;∨&#160;logique</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
40<br/>
<a href="documents.html#41">2.2.4</a><br/>
<a href="documents.html#41">L’égalité&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
41<br/>
<a href="documents.html#42">2.2.5</a><br/>
<a href="documents.html#42">Le&#160;faux&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
42<br/>
<a href="documents.html#43">2.2.6</a><br/>
<a href="documents.html#43">Le&#160;point&#160;fixe</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
43<br/>
<a href="documents.html#43">2.2.7</a><br/>
<a href="documents.html#43">La&#160;logique&#160;classique</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
43<br/>
<a href="documents.html#47"><b>3</b></a><br/>
<a href="documents.html#47"><b>L’interprétation</b></a><br/>
<b>47</b><br/>
<a href="documents.html#47">3.1</a><br/>
<a href="documents.html#47">Introduction&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
47<br/>
<a href="documents.html#47">3.2</a><br/>
<a href="documents.html#47">Un&#160;interprète&#160;MiniScheme&#160;avec&#160;OCAML&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
47<br/>
<a href="documents.html#47">3.2.1</a><br/>
<a href="documents.html#47">L’évaluation&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
47<br/>
<a href="documents.html#49">3.2.2</a><br/>
<a href="documents.html#49">Les&#160;étapes&#160;Read,&#160;Eval,&#160;Print</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
49<br/>
<a href="documents.html#50">3.2.3</a><br/>
<a href="documents.html#50">Liaison&#160;lexicale&#160;vs&#160;liaison&#160;dynamique&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
50<br/>
<a href="documents.html#51">3.2.4</a><br/>
<a href="documents.html#51">Gestion&#160;de&#160;l’environnement&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
51<br/>
3<br/>
<hr/>
<a name=4></a><a href="documents.html#53">3.3</a><br/>
<a href="documents.html#53">Un&#160;interprète&#160;LISP&#160;avec&#160;le&#160;nouvel&#160;interprète&#160;MiniScheme&#160;.&#160;.&#160;.</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
53<br/>
<a href="documents.html#54">3.4</a><br/>
<a href="documents.html#54">L’auto-interprétation&#160;de&#160;l’interprète</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
54<br/>
<a href="documents.html#54">3.4.1</a><br/>
<a href="documents.html#54">La&#160;tour&#160;de&#160;Babel&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
54<br/>
<a href="documents.html#55">3.4.2</a><br/>
<a href="documents.html#55">Réification&#160;et&#160;réflexion&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
55<br/>
<a href="documents.html#63"><b>4</b></a><br/>
<a href="documents.html#63"><b>La&#160;compilation</b></a><br/>
<b>63</b><br/>
<a href="documents.html#63">4.1</a><br/>
<a href="documents.html#63">Compilation&#160;des&#160;<i>λ</i>-termes&#160;en&#160;termes&#160;applicatifs&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
63<br/>
<a href="documents.html#67">4.2</a><br/>
<a href="documents.html#67">Compilation&#160;basique&#160;vers&#160;une&#160;machine&#160;à&#160;pile</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
67<br/>
<a href="documents.html#68">4.2.1</a><br/>
<a href="documents.html#68">Certification&#160;de&#160;la&#160;compilation&#160;avec&#160;le&#160;langage&#160;COQ&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
68<br/>
<a href="documents.html#71">4.3</a><br/>
<a href="documents.html#71">Compilation&#160;du&#160;LISP&#160;vers&#160;une&#160;machine&#160;abstraite&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
71<br/>
<a href="documents.html#75"><b>5</b></a><br/>
<a href="documents.html#75"><b>La&#160;résolution</b></a><br/>
<b>75</b><br/>
<a href="documents.html#75">5.1</a><br/>
<a href="documents.html#75">Représentation&#160;des&#160;termes&#160;finis&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
75<br/>
<a href="documents.html#77">5.2</a><br/>
<a href="documents.html#77">La&#160;substitution&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
77<br/>
<a href="documents.html#78">5.3</a><br/>
<a href="documents.html#78">Filtrage&#160;et&#160;réécriture&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
78<br/>
<a href="documents.html#78">5.3.1</a><br/>
<a href="documents.html#78">Le&#160;filtrage&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
78<br/>
<a href="documents.html#79">5.3.2</a><br/>
<a href="documents.html#79">La&#160;réécriture&#160;et&#160;l’arithmétique&#160;de&#160;Peano&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
79<br/>
<a href="documents.html#81">5.4</a><br/>
<a href="documents.html#81">L’unification&#160;des&#160;termes&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
81<br/>
<a href="documents.html#83">5.5</a><br/>
<a href="documents.html#83">Un&#160;mini&#160;PROLOG&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
83<br/>
<a href="documents.html#84">5.6</a><br/>
<a href="documents.html#84">Quelques&#160;exemples&#160;de&#160;programmation&#160;en&#160;PROLOG</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
84<br/>
<a href="documents.html#84">5.6.1</a><br/>
<a href="documents.html#84">Les&#160;entiers&#160;naturels&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
84<br/>
<a href="documents.html#84">5.6.2</a><br/>
<a href="documents.html#84">Les&#160;additions&#160;de&#160;Peano</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
84<br/>
<a href="documents.html#85">5.6.3</a><br/>
<a href="documents.html#85">Programmation&#160;&#34;logique&#34;&#160;en&#160;COQ&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
85<br/>
<a href="documents.html#86">5.6.4</a><br/>
<a href="documents.html#86">La&#160;base&#160;généalogique&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
86<br/>
<a href="documents.html#86">5.7</a><br/>
<a href="documents.html#86">L’algorithme&#160;de&#160;complétion&#160;de&#160;Knuth-Bendix&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
86<br/>
<a href="documents.html#86">5.7.1</a><br/>
<a href="documents.html#86">Confluence&#160;et&#160;paires&#160;critiques&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
86<br/>
<a href="documents.html#88">5.7.2</a><br/>
<a href="documents.html#88">Terminaison&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
88<br/>
<a href="documents.html#88">5.7.3</a><br/>
<a href="documents.html#88">Complétion&#160;de&#160;Knuth-Bendix&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
88<br/>
<a href="documents.html#91"><b>6</b></a><br/>
<a href="documents.html#91"><b>Calculabilité&#160;et&#160;complexité</b></a><br/>
<b>91</b><br/>
<a href="documents.html#91">6.1</a><br/>
<a href="documents.html#91">Les&#160;fonctions&#160;récursives</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
91<br/>
<a href="documents.html#93">6.2</a><br/>
<a href="documents.html#93">La&#160;machine&#160;de&#160;Turing&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
93<br/>
<a href="documents.html#95">6.3</a><br/>
<a href="documents.html#95">La&#160;thèse&#160;de&#160;Church&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
95<br/>
<a href="documents.html#96">6.4</a><br/>
<a href="documents.html#96">Complexité&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
96<br/>
<a href="documents.html#96">6.4.1</a><br/>
<a href="documents.html#96">Théorème&#160;de&#160;Cook&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
96<br/>
<a href="documents.html#96">6.4.2</a><br/>
<a href="documents.html#96">Implémentation&#160;de&#160;l’algorithme&#160;SAT&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
96<br/>
<a href="documents.html#97">6.4.3</a><br/>
<a href="documents.html#97">Sudoku&#160;-&#160;SAT&#160;encoding&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
97<br/>
<a href="documents.html#99"><b>7</b></a><br/>
<a href="documents.html#99"><b>Annexes&#160;/&#160;Divers</b></a><br/>
<b>99</b><br/>
<a href="documents.html#99">7.1</a><br/>
<a href="documents.html#99">Quelques&#160;fonctions&#160;sur&#160;les&#160;listes&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
99<br/>
<a href="documents.html#99">7.2</a><br/>
<a href="documents.html#99">Les&#160;listes&#160;mutables&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<br/>
99<br/>
<a href="documents.html#100">7.3</a><br/>
<a href="documents.html#100">Les&#160;listes&#160;infinies&#160;ou&#160;<i>streams&#160;</i></a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;100<br/>
<a href="documents.html#102">7.4</a><br/>
<a href="documents.html#102">Le&#160;module&#160;Graphics&#160;d’OCAML,&#160;les&#160;fractales&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;102<br/>
<a href="documents.html#105">7.5</a><br/>
<a href="documents.html#105">Utilisation&#160;de&#160;METAFONT&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;105<br/>
<a href="documents.html#107">7.6</a><br/>
<a href="documents.html#107">The&#160;boxes&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;107<br/>
<a href="documents.html#108">7.7</a><br/>
<a href="documents.html#108">Les&#160;modules&#160;OCAML.&#160;Modélisation&#160;d’un&#160;monoïde&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;108<br/>
4<br/>
<hr/>
<a name=5></a><a href="documents.html#109">7.8</a><br/>
<a href="documents.html#109">Machine&#160;Learning&#160;and&#160;Neural&#160;Networks&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;109<br/><a href="documents.html#109">7.8.1</a><br/>
<a href="documents.html#109">Introduction</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;109<br/>
<a href="documents.html#109">7.8.2</a><br/>
<a href="documents.html#109">Un&#160;peu&#160;de&#160;théorie</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;109<br/>
<a href="documents.html#110">7.8.3</a><br/>
<a href="documents.html#110">Calcul&#160;matriciel&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;110<br/>
<a href="documents.html#111">7.8.4</a><br/>
<a href="documents.html#111">Fonctions&#160;d’activation&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;111<br/>
<a href="documents.html#112">7.9</a><br/>
<a href="documents.html#112">Les&#160;nombres&#160;premiers.&#160;L’algorithme&#160;RSA</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;112<br/>
<a href="documents.html#116">7.10&#160;Approximation&#160;du&#160;nombre&#160;<i>π</i></a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;116<br/>
<a href="documents.html#117">7.10.1&#160;La&#160;méthode&#160;des&#160;polygones&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;117<br/><a href="documents.html#119">7.10.2&#160;La&#160;série&#160;alternée&#160;de&#160;Leibniz&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;119<br/><a href="documents.html#120">7.10.3&#160;La&#160;loi&#160;des&#160;grands&#160;nombres&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;120<br/><a href="documents.html#120">7.10.4&#160;Le&#160;produit&#160;de&#160;Wallis&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;120<br/><a href="documents.html#121">7.10.5&#160;L’intégrale&#160;R&#160;1</a><br/>
<a href="documents.html#121">1</a><br/>
<a href="documents.html#121"><i>dx&#160;</i></a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;121<br/>
<a href="documents.html#121">0&#160;1+<i>x</i>2</a><br/>
<a href="documents.html#121">7.11&#160;Poésies&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;121<br/><a href="documents.html#122">7.12&#160;Les&#160;fractions&#160;continues&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;122<br/>
√<br/>
<a href="documents.html#123">7.13&#160;L’irrationalité&#160;de</a><br/>
<a href="documents.html#123">2&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;123<br/>
<a href="documents.html#123">7.14&#160;Démonstration&#160;non&#160;constructive&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;123<br/><a href="documents.html#123">7.15&#160;L’hyperbole&#160;<i>xy&#160;</i>=&#160;1&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;123<br/><a href="documents.html#124">7.16&#160;L’exponentielle&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;124<br/><a href="documents.html#124">7.17&#160;Les&#160;fonctions&#160;sin&#160;1&#160;et&#160;<i>x.&#160;</i>sin&#160;1</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;124<br/>
<a href="documents.html#124"><i>x</i></a><br/>
<a href="documents.html#124"><i>x</i></a><br/>
<a href="documents.html#124">7.18&#160;Srivanasa&#160;Ramanujan</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;124<br/>
<a href="documents.html#125">7.19&#160;Le&#160;grec&#160;ancien&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;125<br/>
<a href="documents.html#125">7.19.1&#160;L’alphabet&#160;grec&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;125<br/><a href="documents.html#125">7.19.2&#160;Les&#160;mathématiques&#160;grecques</a><br/>
.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;125<br/>
<a href="documents.html#125">7.19.3&#160;Extraits&#160;du&#160;nouveau&#160;testament&#160;</a>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;125<br/>
5<br/>
<hr/>
<a name=6></a>6<br/>
<hr/>
<a name=7></a><b>Introduction</b><br/>
<i>Aristote&#160;considérait&#160;les&#160;mathématiques&#160;comme&#160;une&#160;discipline,&#160;non&#160;pas&#160;tant&#160;de&#160;la&#160;vérité,&#160;que&#160;de</i><br/>
<i>la&#160;beauté.&#160;</i><a href="documents.html#127">[2]</a><br/>
<i>What&#160;is&#160;mathematics&#160;?&#160;Mathematics&#160;as&#160;an&#160;expression&#160;of&#160;the&#160;human&#160;mind&#160;reflects&#160;the&#160;active&#160;will,</i><br/>
<i>the&#160;contemplative&#160;reason,&#160;and&#160;the&#160;desire&#160;for&#160;aesthetic&#160;perfection.&#160;</i><a href="documents.html#127">[17]</a><br/>
C’est&#160;sous&#160;cet&#160;angle&#160;de&#160;l’esthétique&#160;que&#160;j’ai&#160;voulu&#160;ici&#160;modestement&#160;décrire&#160;quelques&#160;concepts<br/>
des&#160;fondements&#160;mathématiques&#160;de&#160;l’informatique.<br/>
Qu’est-ce&#160;que&#160;le&#160;<b>calcul&#160;</b>?&#160;Il&#160;est&#160;difficile&#160;d’en&#160;donner&#160;une&#160;définition&#160;abstraite.&#160;Essayons&#160;cependant<br/>
de&#160;décrire&#160;l’action&#160;de&#160;calculer,&#160;le&#160;processus&#160;du&#160;calcul.<br/>
Nous&#160;identifions&#160;deux&#160;processus&#160;bien&#160;distincts&#160;appelés&#160;la&#160;<b>réduction&#160;</b>et&#160;la&#160;<b>résolution</b>.&#160;La&#160;ré-<br/>
duction&#160;est&#160;l’action&#160;de&#160;réduire&#160;séquentiellement&#160;une&#160;expression&#160;en&#160;une&#160;autre&#160;expression&#160;plus&#160;simple<br/>au&#160;moyen&#160;de&#160;règles&#160;de&#160;réécriture.&#160;Lorsque&#160;plus&#160;aucune&#160;règle&#160;ne&#160;s’applique,&#160;l’expression&#160;calculée&#160;est<br/>alors&#160;en&#160;forme&#160;<i>normale</i>.&#160;Cette&#160;forme&#160;normale&#160;correspondra&#160;à&#160;la&#160;<i>valeur&#160;</i>de&#160;notre&#160;calcul.<br/>
(3&#160;+&#160;8)&#160;+&#160;(4&#160;−&#160;9)&#160;∗&#160;2&#160;&#160;&#160;11&#160;−&#160;5&#160;∗&#160;2&#160;&#160;&#160;11&#160;−&#160;10&#160;&#160;&#160;1<br/>
Ce&#160;processus&#160;de&#160;réduction&#160;soulève&#160;deux&#160;difficultés&#160;essentielles&#160;:<br/>—&#160;La&#160;terminaison.&#160;Est-que&#160;le&#160;processus&#160;termine&#160;en&#160;un&#160;nombre&#160;fini&#160;d’étapes&#160;?<br/>—&#160;La&#160;confluence.&#160;Si&#160;le&#160;processus&#160;termine,&#160;est-que&#160;l’expression&#160;aboutit&#160;à&#160;une&#160;forme&#160;normale<br/>
unique&#160;?<br/>
La&#160;fonction&#160;mathématique&#160;usuelle&#160;est&#160;peu&#160;adaptée&#160;à&#160;une&#160;étude&#160;du&#160;processus&#160;du&#160;calcul.&#160;Car&#160;elle<br/>repose&#160;en&#160;fait&#160;sur&#160;une&#160;définition&#160;en&#160;<i>extension&#160;</i>:&#160;une&#160;fonction&#160;mathématique&#160;est&#160;la&#160;description&#160;d’une<br/>relation&#160;d’un&#160;ensemble&#160;de&#160;départ&#160;face&#160;à&#160;son&#160;ensemble&#160;d’arrivée.<br/>
Pour&#160;modéliser&#160;notre&#160;processus&#160;de&#160;calcul,&#160;il&#160;nous&#160;faut&#160;une&#160;définition&#160;en&#160;<i>intension</i>,&#160;c’est-à-dire<br/>
avec&#160;des&#160;règles&#160;de&#160;calcul&#160;explicites.&#160;Fondé&#160;sur&#160;cette&#160;idée,&#160;le&#160;<i>λ</i>-calcul&#160;a&#160;été&#160;créé&#160;par&#160;Alonzo&#160;Church<br/>dans&#160;les&#160;années&#160;1930.&#160;Il&#160;est&#160;maintenant&#160;utilisé&#160;comme&#160;socle&#160;de&#160;tout&#160;langage&#160;fonctionnel.&#160;Même<br/>s’il&#160;est&#160;rudimentaire&#160;et&#160;basé&#160;sur&#160;un&#160;mécanisme&#160;simple&#160;de&#160;réécriture,&#160;nous&#160;verrons&#160;qu’il&#160;permet<br/>d’exprimer&#160;toutes&#160;les&#160;fonctions&#160;calculables.&#160;Sa&#160;<i>puissance&#160;</i>de&#160;calcul&#160;est&#160;similaire&#160;aux&#160;machines&#160;de<br/>Turing&#160;ou&#160;aux&#160;fonctions&#160;<i>µ</i>-récursives&#160;de&#160;Gödel.&#160;Nous&#160;l’étudierons&#160;en&#160;détails.<br/>
L’autre&#160;processus&#160;de&#160;calcul&#160;est&#160;la&#160;résolution.&#160;Nous&#160;l’utilisons&#160;chaque&#160;fois&#160;que&#160;nous&#160;devons&#160;ré-<br/>
soudre&#160;une&#160;équation.&#160;En&#160;résolvant&#160;<i>x</i>2&#160;+&#160;2<i>x&#160;</i>−&#160;15&#160;=&#160;0,&#160;nous&#160;souhaitons&#160;que&#160;notre&#160;processus&#160;soit<br/><i>complet</i>,&#160;c’est-à-dire&#160;que&#160;nous&#160;calculions&#160;l’ensemble&#160;des&#160;valeurs&#160;possibles&#160;{−5;&#160;3}.&#160;Nous&#160;étudierons<br/>également&#160;ce&#160;mécanisme,&#160;et&#160;en&#160;particulier&#160;l’algorithme&#160;d’unification.<br/>
Enfin,&#160;nous&#160;aborderons&#160;la&#160;correspondante&#160;bluffante&#160;de&#160;la&#160;programmation&#160;fonctionnelle&#160;avec&#160;la<br/>
logique.&#160;C’est&#160;la&#160;correspondance&#160;de&#160;Curry-Howard.<br/>
7<br/>
<hr/>
<a name=8></a>Avec&#160;un&#160;langage&#160;de&#160;programmation&#160;typé&#160;comme&#160;OCAML&#160;où&#160;tout&#160;terme&#160;a&#160;un&#160;type,&#160;nous&#160;pouvons<br/>considérer&#160;un&#160;terme&#160;comme&#160;étant&#160;la&#160;preuve&#160;(ou&#160;plutôt&#160;une&#160;des&#160;preuves&#160;possibles)&#160;de&#160;son&#160;type.&#160;Le<br/>mécanisme&#160;strict&#160;de&#160;typage&#160;nous&#160;assure&#160;de&#160;la&#160;cohérence&#160;du&#160;terme&#160;avec&#160;son&#160;type.&#160;Nous&#160;avons&#160;alors<br/>le&#160;rapprochement&#160;suivant&#160;:<br/>
terme<br/>
preuve<br/>
type<br/>
proposition<br/>
Nous&#160;sommes&#160;ici&#160;dans&#160;une&#160;logique&#160;constructive,&#160;démontrer&#160;une&#160;proposition&#160;revient&#160;à&#160;exhiber&#160;une<br/>preuve,&#160;c’est-à-dire&#160;un&#160;terme&#160;ayant&#160;pour&#160;type&#160;la&#160;proposition.&#160;Ainsi,&#160;le&#160;principe&#160;du&#160;tiers-exclus<br/><i>P&#160;</i>∨&#160;¬<i>P&#160;</i>ne&#160;peut&#160;être&#160;ici&#160;démontré.<br/>
Le&#160;type&#160;faux&#160;est&#160;un&#160;type&#160;inhabité,&#160;donc&#160;nous&#160;le&#160;définissons&#160;sans&#160;constructeur&#160;:&#160;type&#160;faux&#160;=&#160;|<br/>Nous&#160;pouvons&#160;par&#160;exemple&#160;prouver&#160;le&#160;théorème&#160;du&#160;modus&#160;tollens&#160;:<br/>
let&#160;modus_tollens&#160;(hfq:’q-&gt;faux)&#160;(hpq:’p-&gt;’q)&#160;(hp:’p)&#160;=&#160;hfq&#160;(hpq&#160;hp)<br/>
Le&#160;type&#160;de&#160;cette&#160;expression&#160;est&#160;(’q&#160;-&gt;&#160;faux)&#160;-&gt;&#160;(’p&#160;-&gt;&#160;’q)&#160;-&gt;&#160;’p&#160;-&gt;&#160;faux<br/>
Dans&#160;un&#160;langage&#160;proposant&#160;un&#160;système&#160;de&#160;types&#160;plus&#160;évolué&#160;comme&#160;COQ,&#160;le&#160;faux&#160;peut&#160;être<br/>
exprimé&#160;par&#160;le&#160;type&#160;∀<i>p&#160;</i>:&#160;<i>P,&#160;p</i>.&#160;Ce&#160;type&#160;est&#160;également&#160;inhabité.&#160;Supposer&#160;le&#160;faux&#160;permettra&#160;de<br/>démontrer&#160;n’importe&#160;quelle&#160;proposition.<br/>
Theorem&#160;faux&#160;:&#160;forall&#160;P:Prop,&#160;P.<br/>
Admitted.<br/>
Theorem&#160;absurdité&#160;:&#160;1=2.<br/>
Proof.<br/>
exact&#160;(faux&#160;(1=2)).<br/>
Qed.<br/>
La&#160;correspondance&#160;de&#160;Curry-Howard&#160;montre&#160;toute&#160;son&#160;étendue&#160;dans&#160;le&#160;calcul&#160;des&#160;constructions,<br/>
qui&#160;considère&#160;les&#160;types&#160;comme&#160;des&#160;termes&#160;de&#160;premier&#160;ordre&#160;et&#160;permet&#160;ainsi&#160;de&#160;modéliser&#160;des&#160;types<br/>dépendants.&#160;COQ&#160;implémente&#160;ce&#160;formalisme.&#160;Nous&#160;en&#160;montrerons&#160;plusieurs&#160;exemples&#160;significatifs.<br/>
Bonne&#160;lecture&#160;!<br/>
8<br/>
<hr/>
<a name=9></a><b>Chapitre&#160;1</b><br/>
<b>Le&#160;</b><i>λ</i><b>-calcul&#160;et&#160;la&#160;réduction</b><br/>
<b>1.1</b><br/>
<b>Définition,&#160;champ&#160;lexical&#160;et&#160;syntaxique</b><br/>
Le&#160;<i>λ</i>-calcul&#160;est&#160;un&#160;système&#160;formel&#160;très&#160;rudimentaire.&#160;Il&#160;n’utilise&#160;que&#160;peu&#160;de&#160;moyens&#160;:&#160;le&#160;symbole<br/>
<i>λ</i>,&#160;des&#160;variables&#160;et&#160;des&#160;parenthèses.&#160;Il&#160;n’a&#160;qu’une&#160;seule&#160;règle&#160;de&#160;calcul,&#160;la&#160;<i>β</i>-réduction,&#160;qui&#160;modélise<br/>le&#160;passage&#160;d’un&#160;argument&#160;à&#160;une&#160;fonction.<br/>
<b>Définition&#160;1.&#160;</b><i>Un&#160;λ-terme&#160;est&#160;défini&#160;par&#160;induction&#160;de&#160;la&#160;manière&#160;suivante&#160;:</i><br/>
<i>—&#160;Une&#160;variable&#160;x&#160;est&#160;un&#160;λ-terme.<br/>—&#160;Si&#160;t&#160;est&#160;un&#160;λ-terme,&#160;l’abstraction&#160;λx.t&#160;est&#160;un&#160;λ-terme.<br/>—&#160;Si&#160;t</i>1&#160;<i>et&#160;t</i>2&#160;<i>sont&#160;des&#160;λ-termes,&#160;l’application&#160;</i>(<i>t</i>1&#160;<i>t</i>2)&#160;<i>est&#160;un&#160;λ-terme.</i><br/>
Voici&#160;le&#160;champ&#160;lexical&#160;des&#160;<i>λ</i>-termes&#160;:<br/>
|<br/>
<i>λ</i><br/>
LAMBDA<br/>
|<br/>
’.’<br/>
POINT<br/>
token&#160;=&#160;|<br/>
[<i>a&#160;</i>−&#160;<i>z</i>][<i>a&#160;</i>−&#160;<i>z&#160;</i>0&#160;−&#160;9]&#160;*<br/>
VARIABLE<br/>
|<br/>
’(’<br/>
PARLEFT<br/>
|<br/>
’)’<br/>
PARRIGHT<br/>
Voici&#160;la&#160;grammaire&#160;des&#160;<i>λ</i>-termes,&#160;en&#160;utilisant&#160;les&#160;terminaux&#160;définis&#160;avant&#160;:<br/>
<i>terme&#160;</i>:&#160;:=<br/>
|<br/>
VARIABLE<br/>
|<br/>
PARLEFT&#160;<i>terme&#160;terme&#160;</i>PARRIGHT<br/>
|<br/>
LAMBDA&#160;VARIABLE&#160;.&#160;<i>terme</i><br/>
Nous&#160;utiliserons&#160;ocamllex&#160;et&#160;menhir,&#160;qui&#160;est&#160;la&#160;version&#160;moderne&#160;de&#160;ocamlyacc,&#160;pour&#160;l’analyse<br/>
lexical&#160;et&#160;syntaxique&#160;des&#160;termes&#160;du&#160;<i>λ</i>-calcul.<br/>
<b>1.1.1</b><br/>
<b>Analyse&#160;lexicale&#160;avec&#160;ocamllex</b><br/>
Nous&#160;définissons&#160;ici&#160;le&#160;champ&#160;lexical&#160;des&#160;différents&#160;<i>tokens&#160;</i>(<i>léxèmes</i>)&#160;du&#160;<i>λ</i>-calcul.<br/>
(*&#160;file:&#160;lambdalexical.mll&#160;*)<br/>
{<br/>
open&#160;Lambdagrammar&#160;(*&#160;Assumes&#160;the&#160;parser&#160;file&#160;is&#160;&#34;lambdagrammar.mly&#34;&#160;*)<br/>
}<br/>
9<br/>
<hr/>
<a name=10></a>let&#160;texte&#160;=&#160;[’a’-’z’]&#160;[’a’-’z’&#160;’0’-’9’]*<br/>
rule&#160;token&#160;=&#160;parse<br/>
|&#160;&#34;lambda&#34;<br/>
{&#160;LAMBDA&#160;}<br/>
|&#160;’.’&#160;{&#160;POINT&#160;}<br/>
|&#160;texte&#160;as&#160;varia<br/>
{&#160;VARIABLE&#160;(varia)&#160;}<br/>
|&#160;’(’<br/>
{&#160;PARLEFT&#160;}<br/>
|&#160;’)’<br/>
{&#160;PARRIGHT&#160;}<br/>
|&#160;_<br/>
{&#160;token&#160;lexbuf&#160;}<br/>
|&#160;eof<br/>
{&#160;raise&#160;End_of_file&#160;}<br/>
La&#160;compilation&#160;de&#160;ce&#160;fichier&#160;.mll&#160;va&#160;générer&#160;une&#160;fonction&#160;dont&#160;le&#160;nom&#160;est&#160;celui&#160;de&#160;la&#160;règle&#160;(ici<br/>
token).&#160;Cette&#160;fonction&#160;prend&#160;comme&#160;argument&#160;le&#160;type&#160;lexbuf&#160;et&#160;rend&#160;le&#160;type&#160;token.<br/>
lexbuf&#160;est&#160;un&#160;type&#160;de&#160;données&#160;abstrait&#160;défini&#160;dans&#160;le&#160;module&#160;Lexing&#160;qui&#160;permet&#160;de&#160;mémoriser<br/>
la&#160;chaîne&#160;ou&#160;le&#160;fichier&#160;en&#160;cours&#160;d’analyse.<br/>
val&#160;token&#160;:<br/>
Lexing.lexbuf<br/>
-&gt;&#160;token<br/>
<b>1.1.2</b><br/>
<b>Analyse&#160;syntaxique&#160;avec&#160;menhir</b><br/>
Nous&#160;définissons&#160;ici&#160;la&#160;grammaire&#160;du&#160;<i>λ</i>-calcul.&#160;Nous&#160;retrouvons&#160;les&#160;constructeurs&#160;du&#160;type&#160;ML<br/>
associés&#160;à&#160;chacune&#160;des&#160;règles&#160;de&#160;la&#160;grammaire.&#160;Ces&#160;constructeurs&#160;seront&#160;préenté&#160;dans&#160;la&#160;section&#160;qui<br/>suit.<br/>
/*&#160;file:&#160;lambdagrammar.mly&#160;*/<br/>
%{<br/>
open&#160;Terme<br/>
%}<br/>
%token&#160;&lt;string&gt;&#160;VARIABLE<br/>
%token&#160;LAMBDA&#160;PARLEFT&#160;PARRIGHT&#160;POINT<br/>
%token&#160;NEWLINE<br/>
%start&#160;exp<br/>
%type&#160;&lt;Terme.terme&gt;&#160;exp<br/>
%%&#160;/*&#160;Grammar&#160;rules&#160;and&#160;actions&#160;follow&#160;*/<br/>
exp:<br/>
VARIABLE<br/>
{&#160;Var($1)&#160;}<br/>
|&#160;PARLEFT&#160;exp&#160;exp&#160;PARRIGHT<br/>
{&#160;App($2,&#160;$3)}<br/>
|&#160;LAMBDA&#160;VARIABLE&#160;POINT&#160;exp<br/>
{&#160;Lam($2,&#160;$4)&#160;}<br/>
;<br/>
%%<br/>
Plus&#160;exactement,&#160;nous&#160;avons&#160;modifié&#160;cette&#160;grammaire&#160;<i>naïve&#160;</i>pour&#160;la&#160;rendre&#160;non&#160;ambiguë&#160;et<br/>
assurer&#160;l’associativité&#160;à&#160;gauche&#160;des&#160;<i>λ</i>-applications.&#160;En&#160;effet&#160;:<br/>
<i>M&#160;N&#160;OP&#160;</i>=&#160;(((<i>M&#160;N&#160;</i>)<i>O</i>)<i>P&#160;</i>)<br/>
10<br/>
<hr/>
<a name=11></a>%%<br/>
line:<br/>
exp&#160;NEWLINE&#160;{&#160;$1&#160;}<br/>
;<br/>
exp:&#160;LAMBDA&#160;VARIABLE&#160;POINT&#160;exp<br/>
{&#160;Lam($2,&#160;$4)&#160;}<br/>
|&#160;app&#160;{$1}<br/>
;<br/>
app:<br/>
atome&#160;{$1}<br/>
|&#160;app&#160;atome&#160;{&#160;App($1,&#160;$2)&#160;}<br/>
;<br/>
atome:&#160;PARLEFT&#160;exp&#160;PARRIGHT&#160;{$2}<br/>
|&#160;VARIABLE&#160;{Var($1)}<br/>
;<br/>
%%<br/>
Nous&#160;obtenons&#160;ainsi&#160;:<br/>
$&#160;./lambda.out<br/>
&gt;&gt;&#160;m&#160;n&#160;o&#160;p<br/>
App(App(App(Var&#160;&#34;m&#34;&#160;,Var&#160;&#34;n&#34;&#160;),Var&#160;&#34;o&#34;&#160;),Var&#160;&#34;p&#34;&#160;)<br/>
&gt;&gt;&#160;lambda&#160;f&#160;.&#160;(lambda&#160;x&#160;.&#160;f(x&#160;x))&#160;(lambda&#160;x.&#160;f(x&#160;x))<br/>
Lam(&#34;f&#34;,App(Lam(&#34;x&#34;,App(Var&#160;&#34;f&#34;&#160;,App(Var&#160;&#34;x&#34;&#160;,Var&#160;&#34;x&#34;&#160;))),<br/>
Lam(&#34;x&#34;,App(Var&#160;&#34;f&#34;&#160;,App(Var&#160;&#34;x&#34;&#160;,Var&#160;&#34;x&#34;&#160;)))))<br/>
La&#160;compilation&#160;de&#160;ce&#160;fichier&#160;.mly&#160;va&#160;générer&#160;une&#160;fonction&#160;dont&#160;le&#160;nom&#160;est&#160;celui&#160;de&#160;l’axiome&#160;de<br/>
notre&#160;grammaire&#160;(ici&#160;exp).&#160;Cette&#160;fonction&#160;prend&#160;deux&#160;arguments&#160;:&#160;la&#160;fonction&#160;de&#160;l’analyseur&#160;lexical<br/>qui&#160;génère&#160;les&#160;tokens&#160;et&#160;l’input.&#160;Elle&#160;rend&#160;le&#160;type&#160;des&#160;expressions&#160;utilisées&#160;commes&#160;actions&#160;dans&#160;la<br/>grammaire.<br/>
val&#160;exp&#160;:<br/>
(Lexing.lexbuf<br/>
-&gt;&#160;token)&#160;-&gt;&#160;Lexing.lexbuf&#160;-&gt;&#160;Terme.terme<br/>
Si&#160;le&#160;langage&#160;analysé&#160;n’est&#160;pas&#160;reconnu&#160;par&#160;la&#160;grammaire,&#160;l’exception&#160;Parse_error&#160;est&#160;levée.<br/>
<b>1.1.3</b><br/>
<b>Implémentation&#160;du&#160;parsing&#160;en&#160;mode&#160;<i>récursif&#160;descendant</i></b><br/>
Si&#160;nous&#160;voulons&#160;nous&#160;passer&#160;d’un&#160;outil&#160;tel&#160;que&#160;ocamlyacc&#160;ou&#160;menhir,&#160;nous&#160;pouvons&#160;très&#160;facilement<br/>
implémenter&#160;un&#160;parser&#160;de&#160;manière&#160;récursive&#160;en&#160;partant&#160;depuis&#160;la&#160;racine&#160;(l’axiome&#160;des&#160;règles&#160;de&#160;notre<br/>grammaire)&#160;et&#160;en&#160;appelant&#160;de&#160;manière&#160;récursive&#160;les&#160;régles&#160;suivantes&#160;en&#160;fonction&#160;du&#160;caractère&#160;lu.<br/>
On&#160;modifiera&#160;légèrement&#160;la&#160;grammaire&#160;comme&#160;ci-dessous&#160;pour&#160;faciliter&#160;le&#160;travail.<br/>
<i>exprule</i><br/>
::=<br/>
|&#160;VARIABLE<br/>|&#160;PARLEFT&#160;<i>parrule<br/></i>|&#160;NEWLINE<br/>
<i>parrule</i><br/>
::=<br/>
|&#160;LAMBDA&#160;<i>lambdarule<br/></i>|&#160;<i>apprule</i><br/>
<i>lambdarule</i><br/>
::=<br/>
VARIABLE&#160;POINT&#160;<i>exprule&#160;</i>PARRIGHT<br/>
<i>apprule</i><br/>
::=<br/>
<i>exprule&#160;exprule&#160;</i>PARRIGHT<br/>
11<br/>
<hr/>
<a name=12></a>Cela&#160;imposera&#160;cependant&#160;la&#160;saisie&#160;systématique&#160;des&#160;<i>λ</i>-termes&#160;avec&#160;des&#160;parenthèses&#160;autour&#160;des<br/>
abstractions&#160;et&#160;des&#160;applications.&#160;De&#160;même,&#160;nous&#160;n’aurons&#160;plus&#160;la&#160;facilité&#160;syntaxique&#160;de&#160;l’associativité<br/>à&#160;gauche&#160;des&#160;applications&#160;et&#160;de&#160;l’associativité&#160;à&#160;droite&#160;du&#160;corps&#160;des&#160;abstractions.&#160;Je&#160;ne&#160;sais&#160;pas&#160;si<br/>une&#160;telle&#160;grammaire&#160;peut&#160;être&#160;conçue&#160;pour&#160;une&#160;analyse&#160;en&#160;mode&#160;récursif&#160;descendant.&#160;Je&#160;pense&#160;que<br/>non&#160;(après&#160;m’être&#160;un&#160;peu&#160;cassé&#160;les&#160;cheveux&#160;là-dessus...&#160;).<br/>
Voici&#160;le&#160;code&#160;associé.<br/>
exception&#160;Fin<br/>
exception&#160;Erreur&#160;of&#160;string<br/>
let&#160;_&#160;=<br/>
let&#160;lexbuf&#160;=&#160;Lexing.from_channel&#160;stdin&#160;in<br/>
let&#160;rec&#160;exprule&#160;courant&#160;=<br/>
match&#160;courant&#160;with<br/>
|&#160;VARIABLE(x)&#160;-&gt;&#160;Var(x)<br/>
|&#160;PARLEFT&#160;-&gt;&#160;parrule&#160;(lexana&#160;lexbuf)<br/>
|&#160;NEWLINE&#160;-&gt;&#160;raise&#160;Fin<br/>
|&#160;_&#160;-&gt;<br/>
raise&#160;(Erreur&#160;&#34;exprule&#34;)<br/>
and&#160;parrule&#160;courant&#160;=<br/>
match&#160;courant&#160;with<br/>
|&#160;LAMBDA&#160;-&gt;&#160;lambdarule&#160;courant<br/>
|&#160;_&#160;-&gt;&#160;apprule&#160;courant<br/>
and&#160;apprule&#160;courant&#160;=<br/>
let&#160;op1&#160;=&#160;exprule&#160;courant&#160;in<br/>
let&#160;op2&#160;=&#160;exprule&#160;(lexana&#160;lexbuf)&#160;in<br/>
let&#160;suivant&#160;=&#160;lexana&#160;lexbuf&#160;in&#160;(*&#160;consume&#160;PARRIGHT*)<br/>
match&#160;suivant&#160;with<br/>
|&#160;PARRIGHT&#160;-&gt;<br/>
App(op1,&#160;op2)<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;(Erreur&#160;&#34;apprule&#34;)<br/>
and&#160;lambdarule&#160;courant&#160;=<br/>
let&#160;var&#160;=&#160;lexana&#160;lexbuf&#160;in<br/>
let&#160;_&#160;=&#160;lexana&#160;lexbuf&#160;in<br/>
(*&#160;consume&#160;POINT&#160;*)<br/>
let&#160;corps&#160;=&#160;exprule(lexana&#160;lexbuf)&#160;in<br/>
let&#160;_&#160;=<br/>
lexana&#160;lexbuf&#160;(*&#160;consume&#160;PARRIGHT&#160;*)&#160;in<br/>
match&#160;var&#160;with<br/>
|&#160;VARIABLE(x)&#160;-&gt;&#160;Lam(x,&#160;corps)<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;(Erreur&#160;&#34;lambdarule&#34;)<br/>
in&#160;(betaNormalPrint&#160;(exprule&#160;(lexana&#160;lexbuf));&#160;flush&#160;stdout)<br/>
12<br/>
<hr/>
<a name=13></a><b>1.2</b><br/>
<b>Représentation&#160;en&#160;ML</b><br/>
type&#160;terme&#160;=<br/>
|&#160;Var&#160;of&#160;string<br/>
|&#160;App&#160;of&#160;terme&#160;*&#160;terme<br/>
|&#160;Lam&#160;of&#160;variable&#160;*&#160;terme<br/>
Un&#160;terme&#160;du&#160;<i>λ</i>-calcul&#160;est&#160;donc&#160;un&#160;type&#160;ML&#160;composé,&#160;avec&#160;les&#160;constructeurs&#160;<i>V&#160;ar</i>,&#160;<i>App&#160;</i>et&#160;<i>Lam</i>.<br/>Par&#160;exemple,&#160;le&#160;terme&#160;<i>λx.</i>(<i>xy</i>)<i>z&#160;</i>est&#160;representé&#160;par&#160;la&#160;structure&#160;:<br/>
App&#160;((Lam&#160;(&#34;x&#34;,&#160;(App&#160;((Var&#160;&#34;x&#34;),&#160;(Var&#160;&#34;y&#34;))))),&#160;(Var&#160;&#34;z&#34;))<br/>C’est&#160;un&#160;peu&#160;verbeux.&#160;Voici&#160;cependant&#160;sa&#160;représentation&#160;sous&#160;la&#160;forme&#160;d’un&#160;arbre&#160;syntaxique.<br/>
Le&#160;symbole&#160;@&#160;représente&#160;ici&#160;l’application.<br/>
@<br/>
<i>λ</i><br/>
z<br/>
x<br/>
@<br/>
x<br/>
y<br/>
Pour&#160;dessiner&#160;cet&#160;arbre,&#160;nous&#160;utilisons&#160;le&#160;très&#160;bon&#160;package&#160;TIKZ&#160;qui&#160;permet&#160;facilement&#160;de<br/>
représenter&#160;les&#160;arbres&#160;avec&#160;une&#160;syntaxe&#160;très&#160;simple.<br/>
\node{@}<br/>
child&#160;{&#160;node&#160;{$\lambda&#160;$}<br/>
child&#160;{&#160;node&#160;{x}&#160;}<br/>
child&#160;{&#160;node&#160;{@}<br/>
child&#160;{&#160;node&#160;{x}&#160;}<br/>
child&#160;{&#160;node&#160;{y}&#160;}<br/>
}<br/>
}<br/>
child&#160;{&#160;node&#160;{z}&#160;};<br/>
On&#160;implémente&#160;deux&#160;fonctions&#160;CAML&#160;qui&#160;permettent&#160;d’afficher&#160;une&#160;expression&#160;de&#160;type&#160;<i>λ</i>-terme<br/>
en&#160;code&#160;LATEX&#160;ou&#160;en&#160;code&#160;TIKZ.<br/>
La&#160;fonction&#160;varLibres&#160;retourne&#160;les&#160;variables&#160;libres&#160;(ie.&#160;non&#160;liées)&#160;d’un&#160;<i>λ</i>-terme.<br/>
let&#160;rec&#160;varLibres&#160;lambdaTerm&#160;=<br/>
match&#160;lambdaTerm&#160;with<br/>
|&#160;Var&#160;x&#160;-&gt;&#160;[&#160;x&#160;]<br/>
|&#160;App&#160;(n,&#160;m)&#160;-&gt;&#160;union&#160;(varLibres&#160;n)&#160;(varLibres&#160;m)<br/>
|&#160;Lam&#160;(x,&#160;m)&#160;-&gt;&#160;remove&#160;x&#160;(varLibres&#160;m)<br/>
Par&#160;exemple&#160;:&#160;(<i>λx.yxw</i>)(<i>λu.uv</i>)&#160;7−→&#160;<i>y,&#160;w,&#160;v</i><br/>
let&#160;exemple&#160;=&#160;App&#160;(Lam&#160;(&#34;x&#34;,&#160;App&#160;(Var(&#34;y&#34;),&#160;App&#160;(Var(&#34;x&#34;),Var(&#34;w&#34;)))),<br/>
Lam&#160;(&#34;u&#34;,&#160;App&#160;(Var&#160;(&#34;u&#34;),&#160;Var&#160;(&#34;v&#34;))))&#160;;;<br/>
varLibres&#160;exemple&#160;;;<br/>
-&#160;:&#160;variable&#160;list&#160;=&#160;[&#34;y&#34;;&#160;&#34;w&#34;;&#160;&#34;v&#34;]<br/>
13<br/>
<hr/>
<a name=14></a><b>Définition&#160;2.&#160;</b><i>Un&#160;redex&#160;ou&#160;radical&#160;est&#160;un&#160;terme&#160;de&#160;la&#160;forme&#160;</i>(<i>λx.M&#160;</i>)<i>N</i><br/>
On&#160;a&#160;déjà&#160;distingué&#160;deux&#160;formes&#160;possible&#160;sur&#160;les&#160;<i>λ</i>-termes&#160;:&#160;les&#160;<i>abstractions&#160;λx.M&#160;</i>et&#160;les&#160;<i>appli-</i><br/>
<i>cations&#160;</i>(<i>M&#160;N&#160;</i>).&#160;Un&#160;<i>redex&#160;</i>qui&#160;est&#160;de&#160;la&#160;forme&#160;(<i>λx.M&#160;</i>)<i>N&#160;</i>est&#160;la&#160;rencontre&#160;d’une&#160;abstraction&#160;et&#160;d’une<br/>application.&#160;Voici&#160;son&#160;implémentation.<br/>
ML<br/>
SCHEME<br/>
(function&#160;x&#160;-&gt;&#160;M)&#160;N<br/>
((lambda&#160;(x)&#160;M)&#160;N)<br/>
let&#160;x&#160;=&#160;N&#160;in&#160;M<br/>
(let&#160;((x&#160;N))&#160;M)<br/>
M&#160;where&#160;x&#160;=&#160;N<br/>
La&#160;dernière&#160;syntaxe&#160;M&#160;where&#160;x&#160;=&#160;N&#160;a&#160;disparu&#160;en&#160;OCAML.&#160;C’est&#160;dommage&#160;car&#160;elle&#160;est&#160;très&#160;élégante.<br/>Nous&#160;essayerons&#160;de&#160;la&#160;reprendre&#160;pour&#160;notre&#160;interprète&#160;maison&#160;MiniML.<br/>
<b>Définition&#160;3.&#160;</b><i>La&#160;β-réduction&#160;est&#160;une&#160;opération&#160;de&#160;substitution.&#160;Elle&#160;consiste&#160;à&#160;substituer&#160;dans&#160;le<br/>redex&#160;</i>(<i>λx.M&#160;</i>)<i>N&#160;les&#160;occurrences&#160;libres&#160;de&#160;x&#160;dans&#160;M&#160;par&#160;l’argument&#160;N.&#160;On&#160;la&#160;formalise&#160;par&#160;la&#160;notation<br/>suivante&#160;:</i><br/>
((<i>λx.M&#160;</i>)<i>N&#160;</i>)&#160;→<i>β&#160;M&#160;</i>[<i>x&#160;</i>←&#160;<i>N&#160;</i>]<br/>
Nous&#160;pouvons&#160;la&#160;décrire&#160;par&#160;les&#160;quatre&#160;règles&#160;d’inférence&#160;ci-dessous&#160;:<br/>
(<b>redex</b>)&#160;:&#160;((<i>λx.M</i>)<i>N</i>)&#160;→&#160;<i>M</i>[<i>x&#160;</i>←&#160;<i>N</i>]<br/>
<i>M&#160;</i>→&#160;<i>M</i>1<br/>
<i>M&#160;</i>→&#160;<i>M</i>1<br/>
<i>N&#160;</i>→&#160;<i>N</i>1<br/>
(<b>abstraction</b>)&#160;:<br/>
(<b>1</b>)&#160;:<br/>
(<b>2</b>)&#160;:<br/>
<i>λx.M&#160;</i>→&#160;(<i>λx.M</i>1)<br/>
(<i>M&#160;N&#160;</i>)&#160;→&#160;(<i>M</i>1<i>N&#160;</i>)<br/>
(<i>M&#160;N&#160;</i>)&#160;→&#160;(<i>M&#160;N</i>1)<br/>
Pour&#160;l’implémentation,&#160;nous&#160;nous&#160;sommes&#160;appuyés&#160;sur&#160;le&#160;code&#160;de&#160;l’excellent&#160;livre&#160;<i>Programmer</i><br/>
<i>avec&#160;Scheme&#160;</i>de&#160;Jacques&#160;Chazarain&#160;<a href="documents.html#127">[4].&#160;</a>Nous&#160;avons&#160;adapté&#160;son&#160;code&#160;SCHEME&#160;en&#160;OCAML.&#160;En<br/>comparant&#160;les&#160;deux&#160;versions,&#160;on&#160;s’aperçoit&#160;finalement&#160;que&#160;la&#160;version&#160;OCAML,&#160;même&#160;si&#160;un&#160;peu<br/>plus&#160;concise&#160;que&#160;la&#160;version&#160;SCHEME&#160;grâce&#160;l’utilisation&#160;du&#160;<i>pattern&#160;matching</i>,&#160;reste&#160;très&#160;proche&#160;de<br/>l’original&#160;SCHEME.<br/>
La&#160;fonction&#160;substituer&#160;permet&#160;de&#160;substituer&#160;la&#160;variable&#160;var&#160;par&#160;le&#160;terme&#160;terme&#160;dans&#160;l’expres-<br/>
sion&#160;exp.<br/>
let&#160;rec&#160;substituer&#160;exp&#160;var&#160;terme&#160;=<br/>
match&#160;exp&#160;with<br/>
|&#160;Var&#160;x&#160;-&gt;&#160;if&#160;x&#160;=&#160;var&#160;then&#160;terme&#160;else&#160;exp<br/>
|&#160;App&#160;(n,&#160;m)&#160;-&gt;&#160;App&#160;((substituer&#160;n&#160;var&#160;terme),&#160;(substituer&#160;m&#160;var&#160;terme))<br/>
|&#160;Lam&#160;(x,&#160;m)&#160;-&gt;&#160;(*&#160;pas&#160;d’occurence&#160;libre&#160;on&#160;en&#160;fait&#160;rien&#160;*)<br/>
if&#160;not&#160;(mem&#160;var&#160;(varLibres&#160;exp))<br/>
then&#160;exp<br/>
else&#160;(*&#160;si&#160;capture&#160;on&#160;renome&#160;*)<br/>
if&#160;mem&#160;x&#160;(varLibres&#160;terme)<br/>
then<br/>
(let&#160;newV&#160;=&#160;renomme&#160;x&#160;(varLibres&#160;terme)&#160;in<br/>
14<br/>
<hr/>
<a name=15></a>let&#160;newCorps&#160;=&#160;substituer&#160;m&#160;x&#160;(Var&#160;newV)<br/>
in&#160;Lam&#160;(newV,&#160;(substituer&#160;newCorps&#160;var&#160;terme)))<br/>
else<br/>
Lam&#160;(x,&#160;(substituer&#160;m&#160;var&#160;terme))<br/>
Avant&#160;de&#160;substituer&#160;une&#160;variable&#160;par&#160;une&#160;autre,&#160;nous&#160;devons&#160;nous&#160;assurer&#160;qu’il&#160;n’y&#160;aura&#160;pas<br/>
de&#160;phénomène&#160;de&#160;capture,&#160;ie.&#160;nous&#160;assurer&#160;qu’une&#160;variable&#160;libre&#160;ne&#160;deviendra&#160;pas&#160;liée,&#160;après&#160;sub-<br/>stitution.&#160;Dans&#160;l’exemple&#160;suivant,&#160;la&#160;variable&#160;x&#160;qui&#160;était&#160;libre&#160;dans&#160;(<i>zx</i>)&#160;se&#160;retrouve&#160;capturée&#160;par<br/><i>λ</i><br/>
<i>λx.</i>(<i>xy</i>)[<i>y&#160;</i>←&#160;(<i>zx</i>)]&#160;=&#160;<i>λx.</i>(<i>x</i>(<i>zx</i>))<br/>
Pour&#160;éviter&#160;cela,&#160;il&#160;faut&#160;avant&#160;substitution&#160;opérer&#160;un&#160;renommage&#160;de&#160;la&#160;variable&#160;liée&#160;:<br/>
<i>λx</i>1<i>.</i>(<i>x</i>1<i>y</i>)[<i>y&#160;</i>←&#160;(<i>zx</i>)]&#160;=&#160;<i>λx</i>1<i>.</i>(<i>x</i>1(<i>zx</i>))<br/>
Ce&#160;renommage&#160;est&#160;appelé&#160;<i>α</i>-conversion.&#160;On&#160;dit&#160;que&#160;deux&#160;termes&#160;<i>M&#160;</i>et&#160;<i>N&#160;</i>sont&#160;équivalents&#160;modulo<br/><i>α</i>.&#160;On&#160;écrira&#160;<i>M&#160;</i>=<i>α&#160;N</i><br/>
(**&#160;renommer&#160;var&#160;*)<br/>
let&#160;renomme&#160;var&#160;listeVar&#160;=<br/>
let&#160;rec&#160;renommeAux&#160;j&#160;=<br/>
let&#160;varj&#160;=&#160;var&#160;^&#160;(string_of_int&#160;j)<br/>
in&#160;if&#160;mem&#160;varj&#160;listeVar&#160;then&#160;renommeAux&#160;(j&#160;+&#160;1)&#160;else&#160;varj<br/>
in&#160;renommeAux&#160;0<br/>
La&#160;fonction&#160;reduc1Normale&#160;réduit&#160;le&#160;terme&#160;en&#160;appliquant&#160;la&#160;stratégie&#160;de&#160;réduction&#160;normale,<br/>
c’est-à-dire&#160;en&#160;commencant&#160;la&#160;réduction&#160;par&#160;le&#160;redex&#160;extèrieur,&#160;plus&#160;précisément&#160;le&#160;plus&#160;à&#160;gauche<br/>des&#160;extèrieurs.<br/>
let&#160;rec&#160;reduc1Normale&#160;terme&#160;=<br/>
match&#160;terme&#160;with<br/>
|&#160;Var&#160;x&#160;-&gt;&#160;raise&#160;IRREDUCTIBLE<br/>
|&#160;Lam&#160;(x,&#160;m)&#160;-&gt;&#160;Lam&#160;(x,&#160;(reduc1Normale&#160;m))<br/>
|&#160;App&#160;(n,&#160;m)&#160;-&gt;<br/>
if&#160;estRedex&#160;terme<br/>
then&#160;betaReducRedex&#160;terme<br/>
else<br/>
try&#160;App&#160;((reduc1Normale&#160;n),&#160;m)<br/>
with&#160;IRREDUCTIBLE<br/>
-&gt;&#160;App&#160;(n,&#160;(reduc1Normale&#160;m))<br/>
Enfin,&#160;nous&#160;avons&#160;une&#160;fonction&#160;fullReduc&#160;qui&#160;permet&#160;d’itérer&#160;l’opération&#160;de&#160;<i>β</i>-réduction&#160;jusqu’à<br/>
trouver&#160;la&#160;forme&#160;normale,&#160;ou&#160;boucler&#160;s’il&#160;n’y&#160;a&#160;pas&#160;de&#160;forme&#160;formale.&#160;On&#160;lui&#160;impose&#160;donc&#160;maximum<br/>1000&#160;réductions.&#160;Elle&#160;prend&#160;en&#160;argument&#160;la&#160;méthode&#160;(ie.&#160;la&#160;stratégie&#160;de&#160;réduction)&#160;à&#160;utiliser.<br/>
let&#160;rec&#160;fullReduc&#160;terme&#160;methode<br/>
=<br/>
let&#160;rec&#160;loop&#160;terme<br/>
iter&#160;=<br/>
try<br/>
let&#160;newterme&#160;=&#160;methode&#160;terme&#160;in<br/>
if&#160;(newterme&#160;=&#160;terme&#160;||&#160;iter&#160;=&#160;0)&#160;then&#160;newterme<br/>
15<br/>
<hr/>
<a name=16></a>else&#160;loop&#160;newterme&#160;(iter&#160;-&#160;1)<br/>
with&#160;IRREDUCTIBLE&#160;-&gt;&#160;terme<br/>
in&#160;loop&#160;terme&#160;1000<br/>
let&#160;betaNormal&#160;t&#160;=&#160;fullReduc&#160;t&#160;reduc1Normale<br/>
<b>Théorème&#160;1.&#160;</b><i>La&#160;réduction&#160;normale&#160;appliquée&#160;à&#160;un&#160;terme&#160;normalisable&#160;aboutit&#160;toujours&#160;à&#160;la&#160;forme<br/>irréductible&#160;du&#160;terme.</i><br/>
Nous&#160;avons&#160;en&#160;plus&#160;le&#160;théorème&#160;suivant&#160;(plus&#160;précisément&#160;son&#160;corollaire)&#160;qui&#160;nous&#160;assure&#160;que<br/>
toutes&#160;les&#160;réductions&#160;d’un&#160;<i>λ</i>-terme&#160;(qui&#160;terminent)&#160;aboutissent&#160;au&#160;même&#160;terme&#160;irréductible.<br/>
<b>Théorème&#160;2.&#160;</b><i>Théorème&#160;de&#160;Church-Rosser&#160;:&#160;la&#160;β-réduction&#160;est&#160;confluente.</i><br/>
<i>M</i><br/>
∗<br/>
∗<br/>
∗<br/>
∗<br/>
si&#160;<i>M&#160;</i>−→<br/>
−→<br/>
<i>M</i><br/>
<i>β&#160;M</i>1&#160;et&#160;<i>M</i><br/>
<i>β&#160;M</i>2&#160;alors&#160;∃&#160;<i>M&#160;</i>0&#160;tel&#160;que<br/>
1<br/>
<i>M</i>2<br/>
∗<br/>
∗<br/>
<i>M&#160;</i>−→<br/>
−→<br/>
∗<br/>
∗<br/>
1<br/>
<i>β&#160;M&#160;</i>0&#160;et&#160;<i>M</i>2<br/>
<i>β&#160;M&#160;</i>0<br/>
<i>M&#160;</i>0<br/>
<b>Théorème&#160;3.&#160;</b><i>Corollaire&#160;du&#160;théorème&#160;de&#160;Church-Rosser</i><br/>
∗<br/>
<i>Si&#160;M&#160;est&#160;normalisable,&#160;il&#160;existe&#160;un&#160;unique&#160;terme&#160;normal,&#160;noté&#160;M&#160;tel&#160;que&#160;M&#160;</i>−→<i>β&#160;M</i><br/>
Un&#160;corollaire&#160;ne&#160;devrait&#160;pas&#160;nécessiter&#160;de&#160;preuve&#160;car&#160;supposée&#160;évidente.&#160;La&#160;voici&#160;cependant&#160;:<br/>
<i>M</i><br/>
∗<br/>
Si&#160;<i>M&#160;</i>est&#160;normalisable,&#160;alors&#160;il&#160;existe&#160;<i>M</i><br/>
−→<br/>
∗<br/>
∗<br/>
1&#160;normal&#160;tel&#160;que&#160;<i>M</i><br/>
<i>β&#160;M</i>1&#160;;<br/>
∗<br/>
si&#160;<i>M&#160;</i>−→<br/>
<i>M</i><br/>
<i>β&#160;M</i>2&#160;avec&#160;<i>M</i>2&#160;normal,&#160;alors&#160;par&#160;confluence&#160;il&#160;existe&#160;<i>M</i>3&#160;tel<br/>
1<br/>
=<br/>
<i>M</i>2<br/>
=<br/>
∗<br/>
∗<br/>
∗<br/>
∗&#160;=<br/>
que&#160;<i>M&#160;</i>1&#160;−→<i>β&#160;M</i>3&#160;et&#160;<i>M&#160;</i>2&#160;−→<i>β&#160;M</i>3.&#160;Or&#160;<i>M</i>1&#160;et&#160;<i>M</i>2&#160;sont&#160;normaux&#160;donc<br/><i>M</i>1&#160;=&#160;<i>M</i>3&#160;et&#160;<i>M</i>2&#160;=&#160;<i>M</i>3&#160;donc&#160;<i>M</i>1&#160;=&#160;<i>M</i>2&#160;.<br/>
<i>M&#160;</i>3<br/>
let&#160;t1&#160;=&#160;App&#160;(Lam&#160;(&#34;x&#34;,App&#160;(Lam&#160;(&#34;y&#34;,&#160;App&#160;(Var&#160;(&#34;x&#34;),&#160;Var&#160;(&#34;y&#34;))),Var&#160;(&#34;u&#34;))),&#160;Var&#160;(&#34;z&#34;))&#160;;;<br/>
#&#160;fullReduc&#160;t1&#160;;;<br/>
--&gt;&#160;((lambda&#160;x&#160;.&#160;((lambda&#160;y&#160;.&#160;(xy))u))z)<br/>
--&gt;&#160;((lambda&#160;y&#160;.&#160;(zy))u)<br/>
--&gt;&#160;(zu)<br/>
-&#160;:&#160;unit&#160;-&gt;&#160;unit&#160;=&#160;&lt;fun&gt;<br/>
(<i>λx.</i>(<i>λy.xy</i>)<i>u</i>)<i>z&#160;</i>→<i>β&#160;</i>(<i>λy.zy</i>)<i>u&#160;</i>→<i>β&#160;</i>(<i>zu</i>)<br/>
16<br/>
<hr/>
<a name=17></a>(<i>λx.</i>(<i>λy.xy</i>)<i>u</i>)<i>z</i><br/>
(<i>λy.zy</i>)<i>u</i><br/>
(<i>zu</i>)<br/>
@<br/>
<i>λ</i><br/>
z<br/>
x<br/>
@<br/>
@<br/>
<i>λ</i><br/>
u<br/>
<i>λ</i><br/>
u<br/>
y<br/>
@<br/>
y<br/>
@<br/>
@<br/>
x<br/>
y<br/>
z<br/>
y<br/>
z<br/>
u<br/>
Voici&#160;un&#160;exemple&#160;de&#160;terme&#160;qui&#160;ne&#160;termine&#160;pas&#160;et&#160;qui&#160;enfle.<br/>
(<i>λx.xxx</i>)(<i>λx.xxx</i>)&#160;→<i>β&#160;</i>(<i>λx.xxx</i>)(<i>λx.xxx</i>)(<i>λx.xxx</i>)&#160;→<i>β&#160;</i>(<i>λx.xxx</i>)(<i>λx.xxx</i>)(<i>λx.xxx</i>)(<i>λx.xxx</i>)&#160;→<i>β&#160;.&#160;.&#160;.</i><br/>
<b>1.3</b><br/>
<b>La&#160;</b><i>β</i><b>-réduction&#160;faible&#160;avec&#160;appel&#160;par&#160;valeur</b><br/>
Dans&#160;un&#160;langage&#160;fonctionnel&#160;comme&#160;SCHEME&#160;ou&#160;ML,&#160;il&#160;est&#160;important&#160;de&#160;noter&#160;que&#160;contraire-<br/>
ment&#160;au&#160;<i>λ</i>-calcul,&#160;le&#160;corps&#160;de&#160;la&#160;lambda&#160;n’est&#160;pas&#160;évalué.&#160;On&#160;parle&#160;de&#160;<i>β</i>-réduction&#160;faible.&#160;Autrement<br/>dit,&#160;la&#160;règle&#160;suivante&#160;n’est&#160;pas&#160;utilisée&#160;:<br/>
<i>M&#160;</i>→&#160;<i>M</i>1<br/>
(<b>abstraction</b>)&#160;:&#160;<i>λx.M&#160;</i>→&#160;(<i>λx.M</i>1)<br/>
Nous&#160;pourrons&#160;utiliser&#160;cette&#160;absence&#160;d’évaluation&#160;du&#160;corps&#160;des&#160;lambda&#160;expressions&#160;pour&#160;geler&#160;l’éva-<br/>luation&#160;de&#160;nos&#160;expressions&#160;:&#160;(delay&#160;exp)&#160;=&#160;(lambda&#160;()&#160;exp)<br/>
L’appel&#160;par&#160;valeur&#160;signifie&#160;que&#160;les&#160;arguments&#160;sont&#160;évalué&#160;en&#160;premier.&#160;Les&#160;règles&#160;d’inférence<br/>
appliquées&#160;sont&#160;donc&#160;dans&#160;cet&#160;ordre&#160;:<br/>
<i>N&#160;</i>→&#160;<i>N</i>1<br/>
<i>M&#160;</i>→&#160;<i>M</i>1<br/>
(<b>1</b>)&#160;:<br/>
(<b>2</b>)&#160;:<br/>
(<b>3</b>)&#160;:<br/>
(<i>M&#160;N&#160;</i>)&#160;→&#160;(<i>M&#160;N</i>1)<br/>
(<i>M&#160;N&#160;</i>)&#160;→&#160;(<i>M</i>1<i>N&#160;</i>)<br/>
((<i>λx.M&#160;</i>)<i>N&#160;</i>)&#160;→&#160;<i>M&#160;</i>[<i>x&#160;</i>←&#160;<i>N&#160;</i>]<br/>
Voici&#160;la&#160;fonction&#160;ML&#160;qui&#160;implémente&#160;cet&#160;ordre&#160;:<br/>
let&#160;rec&#160;reduc1Valeur&#160;terme&#160;=<br/>
match&#160;terme&#160;with<br/>
|&#160;Var&#160;x&#160;-&gt;&#160;raise&#160;IRREDUCTIBLE<br/>
|&#160;Lam&#160;(x,&#160;m)&#160;-&gt;&#160;raise&#160;IRREDUCTIBLE<br/>
|&#160;App&#160;(n,&#160;m)&#160;-&gt;<br/>
(try&#160;App&#160;(n,&#160;(reduc1Valeur&#160;m))<br/>
with<br/>
|&#160;IRREDUCTIBLE&#160;-&gt;<br/>
(try&#160;App&#160;((reduc1Valeur&#160;n),&#160;m)<br/>
17<br/>
<hr/>
<a name=18></a><img src="document-18_1.jpg"/><br/>
with<br/>
|&#160;IRREDUCTIBLE&#160;-&gt;<br/>
(try&#160;betaReducRedex&#160;terme<br/>
with&#160;|&#160;NOTREDEX&#160;-&gt;&#160;raise&#160;IRREDUCTIBLE)))<br/>
Par&#160;exemple,&#160;nous&#160;aurons&#160;les&#160;réductions&#160;successives&#160;suivantes&#160;:<br/>
—&#160;réduction&#160;normale,&#160;qui&#160;aboutit&#160;toujours&#160;à&#160;la&#160;forme&#160;irréductibre<br/>
(<i>λx.y</i>)((<i>λx.xx</i>)(<i>λx.xx</i>))&#160;→<i>β&#160;y</i><br/>
—&#160;réduction&#160;par&#160;valeur<br/>
(<i>λx.y</i>)((<i>λx.xx</i>)(<i>λx.xx</i>))<br/>
→<i>β</i><br/>
(<i>λx.y</i>)((<i>λx.xx</i>)(<i>λx.xx</i>))<br/>
→<i>β</i><br/>
(<i>λx.y</i>)((<i>λx.xx</i>)(<i>λx.xx</i>))<br/>
→<i>β&#160;</i>(<i>λx.y</i>)((<i>λx.xx</i>)(<i>λx.xx</i>)))<br/>→<i>β</i><br/>
<i>.&#160;.&#160;.</i><br/>
<b>1.4</b><br/>
<b>La&#160;récursivité,&#160;le&#160;point&#160;fixe&#160;et&#160;la&#160;diagonale&#160;de&#160;Cantor</b><br/>
What&#160;else&#160;is&#160;a&#160;loop&#160;but&#160;a&#160;way&#160;of&#160;representing&#160;an&#160;endless&#160;process&#160;in&#160;a&#160;finite&#160;way&#160;?&#160;<a href="documents.html#127">[9]</a><br/>
√2&#160;=&#160;1&#160;+&#160;1√<br/>
1+<br/>
2<br/>
En&#160;analyse,&#160;le&#160;point&#160;fixe&#160;d’une&#160;fonction&#160;<i>f&#160;</i>est&#160;sa&#160;valeur&#160;<i>x&#160;</i>telle&#160;que&#160;<i>f&#160;</i>(<i>x</i>)&#160;=&#160;<i>x</i><br/>
Cela&#160;permet&#160;de&#160;définir&#160;<i>x&#160;</i>en&#160;fonction&#160;de&#160;lui-même.<br/>
Cette&#160;simple&#160;expression&#160;<i>x&#160;</i>=&#160;<i>f&#160;</i>(<i>x</i>)&#160;est&#160;finalement&#160;très&#160;étrange&#160;et&#160;déroutante.&#160;C’est&#160;la&#160;force&#160;de&#160;la<br/>
récursivité&#160;:&#160;<i>x&#160;</i>=&#160;<i>f&#160;</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>f&#160;.&#160;.&#160;.&#160;</i>(<i>x</i>)&#160;<i>.&#160;.&#160;.</i>))))))<br/>
√<br/>
Un&#160;exemple&#160;est&#160;la&#160;valeur<br/>
2&#160;exprimée&#160;sous&#160;forme&#160;d’une&#160;fraction&#160;continue,&#160;expression&#160;trou-<br/>
vée&#160;je&#160;crois&#160;par&#160;Euler.&#160;Je&#160;la&#160;décris&#160;ci-dessous&#160;pour&#160;le&#160;plaisir&#160;d’écrire&#160;(et&#160;lire)&#160;de&#160;belles&#160;formules<br/>mathématiques&#160;en&#160;LATE<a href="documents.html#127">X[13]</a><br/>
√<br/>
√<br/>
√<br/>
√<br/>
(&#160;2&#160;−&#160;1)(&#160;2&#160;+&#160;1)<br/>
1<br/>
2&#160;=&#160;1&#160;+<br/>
2&#160;−&#160;1&#160;=&#160;1&#160;+<br/>
√<br/>
=&#160;1&#160;+<br/>
√<br/>
2&#160;+&#160;1<br/>
1&#160;+<br/>
2<br/>
18<br/>
<hr/>
<a name=19></a><i>y</i><br/>
<i>y&#160;</i>=&#160;<i>x</i><br/>
√<br/>
1<br/>
2&#160;=&#160;1&#160;+<br/>
1<br/>
2&#160;+<br/>
√<br/>
1<br/>
2<br/>
<i>y&#160;</i>=&#160;1&#160;+&#160;1<br/>
2&#160;+<br/>
1+<i>x</i><br/>
1<br/>
2&#160;+<br/>
1<br/>
<i>x</i><br/>
2&#160;+<br/>
√<br/>
.&#160;.<br/>
2<br/>
.<br/>
En&#160;posant&#160;<i>f&#160;</i>(<i>x</i>)&#160;=&#160;1&#160;+&#160;1&#160;,&#160;la&#160;résolution&#160;de&#160;l’équation&#160;<i>x&#160;</i>=&#160;<i>f&#160;</i>(<i>x</i>)&#160;nous&#160;permet&#160;de&#160;calculer&#160;la&#160;valeur<br/>
1+<i>x</i><br/>
√<br/>
√<br/>
de<br/>
2.&#160;Nous&#160;utilisons&#160;aussi&#160;le&#160;fait&#160;que<br/>
2&#160;est&#160;un&#160;point&#160;fixe&#160;attractif&#160;de&#160;notre&#160;fonction&#160;<i>f&#160;</i>.&#160;C’est-à-dire<br/>
√<br/>
qu’il&#160;existe&#160;un&#160;<i>voisinage&#160;</i>de<br/>
2&#160;tel&#160;que&#160;la&#160;suite&#160;<i>x</i>0<i>,&#160;f&#160;</i>(<i>x</i>0)<i>,&#160;f&#160;</i>(<i>f&#160;</i>(<i>x</i>0))<i>,&#160;f&#160;</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>x</i>0)))<i>,&#160;.&#160;.&#160;.&#160;</i>converge&#160;vers<br/>
√2<br/>
En&#160;CAML,&#160;la&#160;fonction&#160;qui&#160;itère&#160;cette&#160;fraction&#160;continue&#160;peut&#160;être&#160;codée&#160;comme&#160;suit.&#160;Nous&#160;partons<br/>
ici&#160;de&#160;<i>x</i>0&#160;=&#160;1.&#160;La&#160;fraction&#160;continue&#160;converge&#160;très&#160;rapidement.<br/>
let&#160;rec&#160;square2&#160;iter&#160;=<br/>
if&#160;(iter&#160;=&#160;1)&#160;then&#160;1.<br/>
else<br/>
1.&#160;+.&#160;(&#160;1.&#160;/.&#160;(&#160;1.&#160;+.&#160;square2&#160;(iter&#160;-&#160;1)));;<br/>
val&#160;square2&#160;:&#160;int&#160;-&gt;&#160;float&#160;=&#160;&lt;fun&gt;<br/>
#&#160;square2&#160;30&#160;;;<br/>
-&#160;:&#160;float&#160;=&#160;1.4142135623730951<br/>
#&#160;sqrt&#160;2.&#160;;;<br/>
-&#160;:&#160;float&#160;=&#160;1.41421356237309512.<br/>
En&#160;<i>λ</i>-calcul,&#160;nous&#160;avons&#160;un&#160;combinateur&#160;<a href="documents.html#19">1&#160;</a>qui&#160;nous&#160;permet&#160;de&#160;calculer&#160;le&#160;point&#160;fixe&#160;de&#160;n’importe<br/>
quel&#160;<i>λ</i>-terme.&#160;Ce&#160;combinateur&#160;s’appelle&#160;<i>Y&#160;</i>.&#160;Il&#160;est&#160;défini&#160;par<br/>
<i>Y&#160;</i>=&#160;<i>λf.</i>(<i>λx.f&#160;</i>(<i>xx</i>))(<i>λx.f&#160;</i>(<i>xx</i>))<br/>
Ce&#160;n’est&#160;pas&#160;le&#160;seul&#160;combinateur&#160;de&#160;point&#160;fixe.&#160;Voici&#160;un&#160;autre&#160;dû&#160;à&#160;Turing&#160;:<br/>
Θ&#160;=&#160;(<i>λx.λy.</i>(<i>y</i>(<i>xxy</i>)))(<i>λx.λy.</i>(<i>y</i>(<i>xxy</i>)))<br/>
Voici&#160;l’arbre&#160;syntaxique&#160;de&#160;<i>Y&#160;</i>:<br/>
1.&#160;Un&#160;combinateur&#160;est&#160;un&#160;<i>λ</i>-terme&#160;comprenant&#160;uniquement&#160;des&#160;variables&#160;liées<br/>
19<br/>
<hr/>
<a name=20></a><i>λ</i><br/>
f<br/>
@<br/>
<i>λ</i><br/>
<i>λ</i><br/>
x<br/>
@<br/>
x<br/>
@<br/>
f<br/>
@<br/>
f<br/>
@<br/>
x<br/>
x<br/>
x<br/>
x<br/>
Quel&#160;que&#160;soit&#160;le&#160;terme&#160;<i>M&#160;</i>,&#160;nous&#160;aurons&#160;(<i>Y&#160;M&#160;</i>)&#160;=<i>β&#160;M&#160;</i>(<i>Y&#160;M&#160;</i>)<br/>
Essayons&#160;ceci&#160;avec&#160;notre&#160;notre&#160;fonction&#160;fullReduc&#160;en&#160;CAML.&#160;Réduisons&#160;<i>Y&#160;M&#160;</i>:<br/>
<i>λf.</i>(<i>λx.</i>(<i>f&#160;</i>(<i>xx</i>)))(<i>λx.</i>(<i>f&#160;</i>(<i>xx</i>)))<i>M<br/></i>→<i>β&#160;</i>(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>)))(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>)))<br/>→<i>β&#160;</i>(<i>M&#160;</i>(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>)))(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>))))&#160;<i>.&#160;</i>[2]<br/>→<i>β&#160;</i>(<i>M&#160;M&#160;</i>(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>)))(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>))))<br/>→<i>β&#160;</i>(<i>M&#160;M&#160;M&#160;</i>(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>)))(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>))))<br/>→<i>β&#160;</i>(<i>M&#160;M&#160;M&#160;M&#160;</i>(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>)))(<i>λx.</i>(<i>M&#160;</i>(<i>xx</i>))))<br/>→<i>β&#160;.&#160;.&#160;.</i><br/>
La&#160;deuxième&#160;<i>β</i>-réduction&#160;est&#160;bien&#160;égale&#160;à&#160;<i>M&#160;</i>(<i>Y&#160;M&#160;</i>)&#160;Nous&#160;voyons&#160;ici&#160;le&#160;mécanisme&#160;d’appel&#160;récursif<br/>
à&#160;M.<br/>
Détaillons&#160;cela&#160;avec&#160;une&#160;fonction&#160;exprimée&#160;en&#160;pseudo-code&#160;d’un&#160;<i>λ</i>-calcul&#160;étendu.&#160;Nous&#160;nous<br/>
inspirons&#160;pour&#160;cela&#160;du&#160;très&#160;bon&#160;article&#160;de&#160;wikipedia&#160;<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_<br/>calculus.</a><br/>
Soit&#160;<i>M&#160;</i>=&#160;(<i>λf&#160;λn.</i>(<i>if&#160;n&#160;</i>=&#160;0&#160;<i>then&#160;</i>1&#160;<i>else&#160;n&#160;</i>∗&#160;<i>f&#160;</i>(<i>n&#160;</i>−&#160;1)))<br/>
(<i>Y&#160;M&#160;</i>)&#160;4<br/>
→<i>β&#160;M&#160;</i>(<i>Y&#160;M&#160;</i>)&#160;4<br/>→<i>β&#160;</i>(<i>λf&#160;λn.</i>(<i>if&#160;n&#160;</i>=&#160;0&#160;<i>then&#160;</i>1&#160;<i>else&#160;n&#160;</i>∗&#160;<i>f&#160;</i>(<i>n&#160;</i>−&#160;1)))(<i>Y&#160;M&#160;</i>)&#160;4<br/>→<i>β&#160;</i>(<i>λn.</i>(<i>if&#160;n&#160;</i>=&#160;0&#160;<i>then&#160;</i>1&#160;<i>else&#160;n&#160;</i>∗&#160;((<i>Y&#160;M&#160;</i>)(<i>n&#160;</i>−&#160;1))))&#160;4<br/>→<i>β&#160;</i>(<i>if&#160;</i>4&#160;=&#160;0&#160;<i>then&#160;</i>1&#160;<i>else&#160;</i>4&#160;∗&#160;((<i>Y&#160;M&#160;</i>)&#160;(4&#160;−&#160;1)))<br/>→<i>β&#160;</i>4&#160;∗&#160;((<i>Y&#160;M&#160;</i>)&#160;3)<br/>→<i>β&#160;</i>4&#160;∗&#160;(<i>M&#160;</i>(<i>Y&#160;M&#160;</i>)&#160;3)<br/>...<br/>→<i>β&#160;</i>4&#160;∗&#160;3&#160;∗&#160;2&#160;∗&#160;1<br/>
Ici&#160;encore,&#160;nous&#160;avons&#160;utilisé&#160;la&#160;stratégie&#160;de&#160;<i>β</i>-réduction&#160;normale.&#160;Mais&#160;avec&#160;une&#160;réduction&#160;par<br/>
valeur,&#160;le&#160;terme&#160;en&#160;argument&#160;(<i>Y&#160;M&#160;</i>)&#160;aura&#160;été&#160;réduit&#160;indéfiniment&#160;en&#160;<i>M&#160;</i>(<i>M&#160;</i>(<i>M&#160;</i>(<i>M&#160;</i>(<i>M&#160;.&#160;.&#160;.&#160;Y&#160;M&#160;</i>)&#160;<i>.&#160;.&#160;.</i>))),<br/>sans&#160;réduire&#160;le&#160;redex&#160;<i>M&#160;x</i><br/>
En&#160;utilisant&#160;notre&#160;programme&#160;OCAML,&#160;voyons&#160;cela&#160;avec&#160;en&#160;prenant&#160;<i>M&#160;</i>=&#160;<i>λa.</i>(<i>λb.b</i>)&#160;:<br/>
#&#160;betaNormal&#160;ym&#160;;;<br/>
(<i>λf.</i>(<i>λx.</i>(<i>f&#160;</i>(<i>xx</i>))<i>λx.</i>(<i>f&#160;</i>(<i>xx</i>)))<i>λa.λb.b</i>)<br/>
→<i>β&#160;</i>(<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>)))<br/>
<i>.</i>[2]<br/>
→<i>β&#160;</i>(<i>λa.λb.b</i>(<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))))&#160;<i>.</i>[3]<br/>→<i>β&#160;λb.b</i><br/>
20<br/>
<hr/>
<a name=21></a>#&#160;betaValeur&#160;ym&#160;;;<br/>
(<i>λf.</i>(<i>λx.</i>(<i>f&#160;</i>(<i>xx</i>))<i>λx.</i>(<i>f&#160;</i>(<i>xx</i>)))<i>λa.λb.b</i>)<br/>
→<i>β&#160;</i>(<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>)))<br/>
<i>.</i>[2]<br/>
→<i>β&#160;</i>(<i>λa.λb.b</i>(<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))))<br/>
<i>.</i>[3]<br/>
→<i>β&#160;</i>(<i>λa.λb.b</i>(<i>λa.λb.b</i>(<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>)))))<br/>→<i>β&#160;</i>(<i>λa.λb.b</i>(<i>λa.λb.b</i>(<i>λa.λb.b</i>(<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))))))<br/>→<i>β&#160;</i>(<i>λa.λb.b</i>(<i>λa.λb.b</i>(<i>λa.λb.b</i>(<i>λa.λb.b</i>(<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>))<i>λx.</i>(<i>λa.λb.b</i>(<i>xx</i>)))))))<br/>
Les&#160;étapes&#160;<i>.</i>[2]&#160;et&#160;<i>.</i>[3]&#160;sont&#160;bien&#160;les&#160;mêmes&#160;sur&#160;les&#160;deux&#160;stratégies.&#160;Puis&#160;la&#160;<i>β</i>-réduction&#160;par&#160;valeur<br/>va&#160;continuer&#160;à&#160;réduire&#160;l’argument&#160;(<i>Y&#160;M&#160;</i>),&#160;là&#160;où&#160;la&#160;<i>β</i>-réduction&#160;normale&#160;va&#160;d’abord&#160;réduire&#160;le&#160;redex<br/><i>M&#160;x</i><br/>
Avec&#160;la&#160;réduction&#160;par&#160;valeur,&#160;il&#160;nous&#160;faut&#160;donc&#160;utiliser&#160;un&#160;autre&#160;combinateur&#160;de&#160;point&#160;fixe&#160;<a href="documents.html#21">2&#160;</a>que<br/>
nous&#160;appelerons&#160;<i>Z</i><br/>
<i>Z&#160;</i>=&#160;<i>λf.</i>(<i>λx.f&#160;</i>(<i>λv.xxv</i>))(<i>λx.f&#160;</i>(<i>λv.xxv</i>))<br/>
On&#160;constate&#160;que&#160;Z&#160;est&#160;<i>η</i>-équivalent&#160;à&#160;<i>Y&#160;</i>.&#160;Nous&#160;rappelons&#160;la&#160;définition&#160;suivante&#160;:<br/>
<b>Définition&#160;4.&#160;</b><i>Les&#160;termes&#160;</i>(<i>λx.M&#160;x</i>)&#160;<i>et&#160;M&#160;sont&#160;η-équivalents.&#160;On&#160;écrira&#160;</i>(<i>λx.M&#160;x</i>)&#160;=<i>η&#160;M</i><br/>
<i>En&#160;ML,&#160;nous&#160;pouvons&#160;par&#160;exemple&#160;dire&#160;que&#160;</i>let&#160;g&#160;x&#160;=&#160;f&#160;x&#160;<i>est&#160;η-équivalent&#160;à&#160;</i>let&#160;g&#160;=&#160;f<br/>
Appliquons&#160;à&#160;nouveau&#160;notre&#160;exemple&#160;avec&#160;ce&#160;combinateur&#160;<i>Z&#160;</i>appliqué&#160;à&#160;<i>M&#160;</i>=&#160;<i>λa.λb.b&#160;</i>:<br/>
#&#160;betaValeur&#160;zm&#160;;;<br/>
((<i>λf.</i>((<i>λx.</i>(<i>f&#160;</i>(<i>λv.</i>((<i>xx</i>)<i>v</i>))))(<i>λx.</i>(<i>f&#160;</i>(<i>λv.</i>((<i>xx</i>)<i>v</i>))))))(<i>λa.</i>(<i>λb.b</i>)))<br/>
→<i>β&#160;</i>((<i>λx.</i>((<i>λa.</i>(<i>λb.b</i>))(<i>λv.</i>((<i>xx</i>)<i>v</i>))))(<i>λx.</i>((<i>λa.</i>(<i>λb.b</i>))(<i>λv.</i>((<i>xx</i>)<i>v</i>)))))<br/>→<i>β&#160;</i>((<i>λa.</i>(<i>λb.b</i>))(<i>λv.</i>(((<i>λx.</i>((<i>λa.</i>(<i>λb.b</i>))(<i>λv.</i>((<i>xx</i>)<i>v</i>))))(<i>λx.</i>((<i>λa.</i>(<i>λb.b</i>))(<i>λv.</i>((<i>xx</i>)<i>v</i>)))))<i>v</i>)))<br/>→<i>β&#160;</i>(<i>λb.b</i>)<br/>
Nous&#160;avons&#160;le&#160;même&#160;réultat&#160;et&#160;les&#160;même&#160;étapes&#160;de&#160;réduction&#160;avec&#160;betaNormal&#160;zm&#160;;;<br/>En&#160;SCHEME,&#160;nous&#160;pourrons&#160;implémenter&#160;ce&#160;combinateur&#160;<i>Z&#160;</i>:<br/>
(define&#160;Z<br/>
(lambda(f)<br/>
(lambda&#160;(x)&#160;(lambda(v)&#160;((f&#160;(x&#160;x)&#160;v))))<br/>
(lambda&#160;(x)&#160;(lambda(v)&#160;((f&#160;(x&#160;x)&#160;v))))))<br/>
En&#160;ML,&#160;le&#160;typage&#160;ne&#160;nous&#160;permettra&#160;pas&#160;de&#160;coder&#160;un&#160;combinateur&#160;comme&#160;<i>Y&#160;</i>ou&#160;<i>Z</i>.<br/>Essayons&#160;cependant&#160;d’écrire&#160;:<br/>
#&#160;let&#160;rec&#160;fix&#160;f&#160;=&#160;f&#160;(fix&#160;f)&#160;;;<br/>
val&#160;fix&#160;:&#160;(’a&#160;-&gt;&#160;’a)&#160;-&gt;&#160;’a&#160;=&#160;&lt;fun&gt;<br/>
let&#160;factabs&#160;fact&#160;=&#160;function<br/>
|&#160;0&#160;-&gt;&#160;1<br/>
|&#160;n&#160;-&gt;&#160;n&#160;*&#160;fact&#160;(n&#160;-&#160;1)&#160;;;<br/>
2.&#160;Nous&#160;insistons&#160;là-dessus&#160;car&#160;nous&#160;rappelons&#160;que&#160;les&#160;interprètes&#160;MiniScheme&#160;et&#160;MiniML&#160;que&#160;nous&#160;implémenterons<br/>
utiliseront&#160;la&#160;<i>β</i>-réduction&#160;faible&#160;par&#160;valeur.<br/>
21<br/>
<hr/>
<a name=22></a>val&#160;factabs&#160;:&#160;(int&#160;-&gt;&#160;int)&#160;-&gt;&#160;int&#160;-&gt;&#160;int&#160;=&#160;&lt;fun&gt;<br/>
#&#160;(fix&#160;factabs)&#160;5&#160;;;<br/>
Stack&#160;overflow&#160;during&#160;evaluation&#160;(looping&#160;recursion?).<br/>
ML&#160;est&#160;bien&#160;un&#160;langage&#160;<i>strict&#160;</i>:&#160;les&#160;arguments&#160;d’une&#160;fonction&#160;sont&#160;évalués&#160;en&#160;premier&#160;comme&#160;on&#160;l’a<br/>vu&#160;dans&#160;la&#160;<i>β</i>-réduction&#160;faible&#160;avec&#160;appel&#160;par&#160;valeur.<br/>
Pour&#160;éviter&#160;la&#160;boucle&#160;infinie&#160;<i>f&#160;</i>(<i>f&#160;.&#160;.&#160;.&#160;</i>(<i>f&#160;</i>(<i>f&#160;ixf&#160;</i>))&#160;<i>.&#160;.&#160;.</i>),&#160;une&#160;astuce&#160;que&#160;j’ai&#160;pu&#160;lire&#160;est&#160;d’introduire<br/>
une&#160;variable&#160;supplémentaire&#160;:<br/>
#&#160;let&#160;rec&#160;fix&#160;f&#160;x&#160;=&#160;f&#160;(fix&#160;f)&#160;x&#160;;;<br/>
val&#160;fix&#160;:&#160;((’a&#160;-&gt;&#160;’b)&#160;-&gt;&#160;’a&#160;-&gt;&#160;’b)&#160;-&gt;&#160;’a&#160;-&gt;&#160;’b&#160;=&#160;&lt;fun&gt;<br/>
#&#160;(fix&#160;factabs)&#160;5&#160;;;<br/>
-&#160;:&#160;int&#160;=&#160;120<br/>
Ici&#160;aussi,&#160;le&#160;mécanisme&#160;de&#160;la&#160;“<i>η</i>-expansion”&#160;est&#160;utilisé.&#160;Je&#160;suis&#160;surpris&#160;cependant&#160;de&#160;voir&#160;que&#160;fix<br/>prenant&#160;deux&#160;arguments&#160;est&#160;correctement&#160;évalué&#160;lors&#160;de&#160;son&#160;appel&#160;(fix&#160;f).&#160;Je&#160;ne&#160;peux&#160;reproduire<br/>cela&#160;en&#160;SCHEME&#160;:<br/>
(define&#160;factabs<br/>
(lambda&#160;(f)<br/>
(lambda&#160;(n)<br/>
(if&#160;(eq?&#160;n&#160;0)<br/>
1<br/>
(*&#160;n&#160;(f&#160;(-&#160;n&#160;1)))))))<br/>
(define&#160;y<br/>
(lambda&#160;(f&#160;x)<br/>
(f&#160;(y&#160;f)&#160;x)))<br/>
(y&#160;factabs&#160;5)<br/>
=&gt;&#160;y:&#160;arity&#160;mismatch;&#160;the&#160;expected&#160;number&#160;of&#160;arguments&#160;does&#160;not&#160;match<br/>
expected:&#160;2<br/>
given:&#160;1<br/>
Le&#160;théorème&#160;de&#160;Cantor&#160;nous&#160;dit&#160;qu’il&#160;n’y&#160;a&#160;pas&#160;de&#160;fonction&#160;surjective&#160;<i>f&#160;</i>:&#160;N&#160;→&#160;(N&#160;→&#160;B).&#160;Autre-<br/>
ment&#160;dit,&#160;le&#160;cardinal&#160;des&#160;parties&#160;de&#160;N&#160;est&#160;strictement&#160;plus&#160;grand&#160;que&#160;le&#160;cardinal&#160;de&#160;N.&#160;Démontrons<br/>cela.<br/>Soient&#160;<i>X</i>0<i>,&#160;X</i>1<i>,&#160;.&#160;.&#160;.&#160;,&#160;Xn&#160;</i>les&#160;parties&#160;de&#160;N<br/>Soit&#160;<i>f&#160;</i>(<i>m,&#160;n</i>)&#160;=&#160;<i>true&#160;</i>si&#160;<i>m&#160;</i>∈&#160;<i>Xn&#160;</i>et&#160;<i>f&#160;alse&#160;</i>sinon.<br/>Soit&#160;<i>g&#160;</i>:&#160;B&#160;→&#160;B&#160;la&#160;fonction&#160;sans&#160;point&#160;fixe&#160;telle&#160;que&#160;<i>g</i>(<i>f&#160;alse</i>)&#160;=&#160;<i>true&#160;</i>et&#160;<i>g</i>(<i>true</i>)&#160;=&#160;<i>f&#160;alse</i>.<br/>Considérons&#160;la&#160;fonction&#160;<i>h&#160;</i>:&#160;N&#160;→&#160;B&#160;telle&#160;que&#160;<i>h</i>(<i>x</i>)&#160;=&#160;<i>g</i>(<i>f&#160;</i>(<i>x,&#160;x</i>))&#160;Supposons&#160;<i>f&#160;</i>surjective&#160;donc<br/>∃<i>a,&#160;f&#160;</i>(<i>a</i>)&#160;=&#160;<i>h&#160;</i>⇔&#160;<i>f&#160;</i>(<i>a,&#160;a</i>)&#160;=&#160;<i>h</i>(<i>a</i>)&#160;=&#160;<i>g</i>(<i>f&#160;</i>(<i>a,&#160;a</i>))&#160;Cela&#160;est&#160;impossible&#160;car&#160;<i>g&#160;</i>n’admet&#160;pas&#160;de&#160;point<br/>fixe&#160;par&#160;définition.<br/>
Ainsi&#160;<i>f&#160;</i>n’est&#160;pas&#160;surjective.<br/>
Voici&#160;la&#160;représentation&#160;matricielle&#160;de&#160;la&#160;fonction&#160;<i>f&#160;</i>(<i>x,&#160;y</i>).&#160;Les&#160;valeurs&#160;<i>true&#160;</i>et&#160;<i>f&#160;alse&#160;</i>sont&#160;repré-<br/>
sentées&#160;par&#160;1&#160;et&#160;0.&#160;La&#160;colonne&#160;est&#160;la&#160;valeur&#160;de&#160;<i>x&#160;</i>et&#160;la&#160;ligne&#160;est&#160;la&#160;valeur&#160;de&#160;<i>y</i>.<br/>
22<br/>
<hr/>
<a name=23></a>0<br/>
1<br/>
2<br/>
3<br/>
4<br/>
5<br/>
6<br/>
7<br/>
<i>...</i><br/>
<br/>
0<br/>
1<br/>
2<br/>
3<br/>
4<br/>
5<br/>
6<br/>
7<br/>
<i>...</i><br/>
<br/>
<b>1</b><br/>
0<br/>
0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
<i>...</i><br/>
<i>X</i>0<br/>
<b>0</b><br/>
0<br/>
0<br/>
1<br/>
0<br/>
1<br/>
0<br/>
1<br/>
<i>...</i><br/>
<i>X</i>0<br/>
<br/>
<br/>
<br/>
<br/>
0<br/>
<b>0</b><br/>
0<br/>
1<br/>
0<br/>
0<br/>
0<br/>
0<br/>
<i>...</i><br/>
<i>X</i>1<br/>
0<br/>
<b>1</b><br/>
0<br/>
1<br/>
0<br/>
0<br/>
0<br/>
0<br/>
<i>...</i><br/>
<i>X</i>1<br/>
<br/>
<br/>
<br/>
<br/>
1<br/>
0<br/>
<b>1</b><br/>
1<br/>
1<br/>
1<br/>
1<br/>
0<br/>
<i>...</i><br/>
<i>X&#160;</i><br/>
1<br/>
0<br/>
<b>0</b><br/>
1<br/>
1<br/>
1<br/>
1<br/>
0<br/>
<i>...</i><br/>
<i>X&#160;</i><br/>
<br/>
2<br/>
<br/>
2<br/>
1<br/>
0<br/>
0<br/>
<b>1</b><br/>
0<br/>
1<br/>
0<br/>
0<br/>
<i>...</i><br/>
<i>X&#160;</i><br/>
1<br/>
0<br/>
0<br/>
<b>0</b><br/>
0<br/>
1<br/>
0<br/>
0<br/>
<i>...</i><br/>
<i>X&#160;</i><br/>
<br/>
3<br/>
<br/>
3<br/>
<br/>
&#160;⇒<br/>
<br/>
<br/>
0<br/>
0<br/>
0<br/>
1<br/>
<b>0</b><br/>
1<br/>
0<br/>
0<br/>
<i>...</i><br/>
<i>X</i>4<br/>
<i>g</i>(<i>f&#160;</i>(<i>x,x</i>))&#160;0<br/>
0<br/>
0<br/>
1<br/>
<b>1</b><br/>
1<br/>
0<br/>
0<br/>
<i>...</i><br/>
<i>X</i>4<br/>
<br/>
<br/>
<br/>
<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
<b>1</b><br/>
0<br/>
1<br/>
<i>...</i><br/>
<i>X</i>5<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
<b>0</b><br/>
0<br/>
1<br/>
<i>...</i><br/>
<i>X</i>5<br/>
<br/>
<br/>
<br/>
<br/>
0<br/>
0<br/>
0<br/>
1<br/>
1<br/>
0<br/>
<b>1</b><br/>
0<br/>
<i>...</i><br/>
<i>X&#160;</i><br/>
0<br/>
0<br/>
0<br/>
1<br/>
1<br/>
0<br/>
<b>0</b><br/>
0<br/>
<i>...</i><br/>
<i>X&#160;</i><br/>
<br/>
6<br/>
<br/>
6<br/>
<br/>
<br/>
<br/>
<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
<b>0</b><br/>
<i>...</i><br/>
<i>X</i>7<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
<b>1</b><br/>
<i>...</i><br/>
<i>X</i>7<br/>
<br/>
.<br/>
<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.&#160;.<br/>
..<br/>
.&#160;.<br/>
Voici&#160;la&#160;démonstration&#160;formelle&#160;en&#160;COQ.<br/>
Require&#160;Import&#160;<i>Bool</i>.<br/>
Section&#160;<i>Cantor</i>.<br/>
Lemma&#160;<i>negb&#160;prop&#160;</i>:&#160;∀&#160;<i>a&#160;</i>:<i>bool</i>,&#160;<i>negb&#160;a&#160;</i>=<i>a&#160;</i>→&#160;<i>False</i>.<br/>
Proof.<br/>
intros.<br/>
unfold&#160;<i>negb&#160;</i>in&#160;<i>H</i>.<br/>
induction&#160;<i>a</i>.&#160;inversion&#160;<i>H</i>.&#160;inversion&#160;<i>H</i>.<br/>
Qed.<br/>
Definition&#160;<i>surjective&#160;</i>{<i>X&#160;</i>:Type}&#160;(<i>f&#160;</i>:&#160;<i>nat&#160;</i>→&#160;<i>X&#160;</i>)&#160;:&#160;Prop&#160;:=&#160;∀&#160;<i>y</i>,&#160;∃&#160;<i>x</i>,&#160;<i>f&#160;x&#160;</i>=&#160;<i>y</i>.<br/>
Theorem&#160;<i>cantor&#160;</i>:&#160;¬&#160;∃&#160;<i>f&#160;</i>:&#160;<i>nat&#160;</i>→&#160;<i>nat&#160;</i>→&#160;<i>bool</i>,&#160;<i>surjective&#160;f</i>.<br/>
Proof.<br/>
intros&#160;[<i>f&#160;SURJ&#160;</i>].<br/>
pose&#160;(<i>g&#160;</i>:=&#160;fun&#160;<i>b&#160;</i>⇒&#160;<i>negb&#160;b&#160;</i>).<br/>
soit&#160;<i>h&#160;</i>la&#160;diagonalisation&#160;négative&#160;de&#160;la&#160;mort<br/>
pose&#160;(<i>h&#160;</i>:=&#160;fun&#160;<i>x&#160;</i>⇒&#160;<i>g&#160;</i>(<i>f&#160;x&#160;x&#160;</i>)).<br/>
on&#160;applique&#160;l’hypothèse&#160;de&#160;surjection&#160;de&#160;<i>f&#160;</i>sur&#160;<i>h</i><br/>
destruct&#160;(<i>SURJ&#160;h</i>)&#160;as&#160;[<i>x&#160;B</i>].<br/>
assert&#160;(<i>C&#160;</i>:&#160;<i>h&#160;x&#160;</i>=&#160;<i>f&#160;x&#160;x&#160;</i>).<br/>{<br/>
rewrite&#160;<i>B</i>.&#160;reflexivity.<br/>
}<br/>
unfold&#160;<i>h&#160;</i>in&#160;<i>C</i>.<br/>
unfold&#160;<i>g&#160;</i>in&#160;<i>C</i>.<br/>
apply&#160;<i>negb&#160;prop&#160;</i>in&#160;<i>C</i>.<br/>
assumption.<br/>
Qed.<br/>
End&#160;<i>Cantor</i>.<br/>
23<br/>
<hr/>
<a name=24></a>Que&#160;vient&#160;faire&#160;Cantor&#160;sur&#160;ce&#160;chapitre&#160;décrivant&#160;les&#160;opérateurs&#160;de&#160;point&#160;fixes&#160;du&#160;<i>λ</i>-calcul&#160;?&#160;Le&#160;mé-<br/>
canisme&#160;de&#160;la&#160;diagonalisation&#160;nous&#160;permet&#160;de&#160;retrouver&#160;l’opérateur&#160;de&#160;point&#160;fixe&#160;<i>λg.</i>(<i>λ.g</i>(<i>xx</i>))(<i>λ.g</i>(<i>xx</i>)<br/>Nous&#160;pourrons&#160;nous&#160;reférer&#160;à&#160;l’ouvrage&#160;de&#160;Jean-Yves&#160;Girard,&#160;<i>Le&#160;Point&#160;Aveugle&#160;</i><a href="documents.html#127">[8]</a><br/>
Voyons&#160;cela.<br/>Prenons&#160;la&#160;fonction&#160;identité&#160;<i>f&#160;</i>=&#160;<i>λx.x</i>.&#160;Considérons&#160;cette&#160;fonction&#160;identité&#160;pouvant&#160;prendre<br/>
en&#160;argument&#160;une&#160;abstraction&#160;et&#160;rendant&#160;une&#160;abstraction&#160;pour&#160;se&#160;rapprocher&#160;de&#160;notre&#160;fonction&#160;<i>f<br/></i>précédente&#160;de&#160;type&#160;<i>A&#160;</i>→&#160;(<i>A&#160;</i>→&#160;<i>B</i>)<br/>
Cette&#160;fonction&#160;est&#160;bien&#160;surjective.&#160;Donc&#160;par&#160;la&#160;contraposée&#160;du&#160;théorème&#160;de&#160;Cantor,&#160;quel&#160;que<br/>
soit&#160;<i>h</i>,&#160;nous&#160;aurons&#160;un&#160;<i>a&#160;</i>tel&#160;que&#160;<i>f&#160;a&#160;</i>=&#160;<i>h</i>,&#160;et&#160;ce&#160;<i>a&#160;</i>pourra&#160;être&#160;<i>h</i>.&#160;Par&#160;diagonalisation&#160;:&#160;<i>f&#160;aa&#160;</i>=&#160;<i>ha&#160;</i>=&#160;<i>hh</i><br/>
Considérons&#160;<i>h&#160;</i>=&#160;<i>λx.g</i>((<i>f&#160;x</i>)<i>x</i>)&#160;pour&#160;un&#160;terme&#160;<i>g&#160;</i>quelconque.&#160;<i>f&#160;</i>est&#160;la&#160;fonction&#160;identité,&#160;donc<br/>
<i>h&#160;</i>=&#160;<i>λx.g</i>(<i>xx</i>)<br/>
<i>hh&#160;</i>=&#160;<i>λx.g</i>(<i>xx</i>)<i>λx.g</i>(<i>xx</i>)<br/>
<i>hh&#160;</i>=&#160;<i>g</i>(<i>hh</i>)<br/>
L’opérateur&#160;de&#160;point&#160;fixe&#160;est&#160;ainsi&#160;<i>Y&#160;</i>=&#160;<i>λg.</i>(<i>λx.g</i>(<i>xx</i>)<i>λx.g</i>(<i>xx</i>)).&#160;Aucun&#160;terme&#160;n’est&#160;donc&#160;sans&#160;point<br/>fixe&#160;dans&#160;le&#160;<i>λ</i>-calcul&#160;à&#160;la&#160;différence&#160;de&#160;l’exemple&#160;précédent&#160;où&#160;notre&#160;fonction&#160;de&#160;B&#160;→&#160;B&#160;n’avait&#160;pas<br/>de&#160;point&#160;fixe.<br/>
<b>1.5</b><br/>
<i><b>Church&#160;</b></i><b>encoding.&#160;Les&#160;entiers&#160;et&#160;les&#160;booléens&#160;en&#160;</b><i>λ</i><b>-calcul</b><br/>
<b>1.5.1</b><br/>
<b>Les&#160;entiers&#160;<i>Church</i></b><br/>
Les&#160;entiers&#160;peuvent&#160;être&#160;représenté&#160;de&#160;la&#160;manière&#160;suivante&#160;:<br/>
0&#160;≡&#160;<i>λf.λx.x<br/></i>1&#160;≡&#160;<i>λf.λx.f&#160;x<br/></i>2&#160;≡&#160;<i>λf.λx.f&#160;</i>(<i>f&#160;x</i>)<br/>3&#160;≡&#160;<i>λf.λx.f&#160;</i>(<i>f&#160;</i>(<i>f&#160;x</i>))<br/>
La&#160;fonction&#160;successeur&#160;se&#160;définira&#160;<i>SU&#160;CC&#160;</i>≡&#160;<i>λn.λf.λx.f&#160;</i>(<i>nf&#160;x</i>)&#160;Avec&#160;notre&#160;représentation&#160;ML&#160;:<br/>
Lam(&#34;n&#34;,&#160;Lam(&#34;f&#34;,&#160;Lam(&#34;x&#34;,App(Var&#160;&#34;f&#34;,&#160;App(App(Var&#160;&#34;n&#34;,&#160;Var&#160;&#34;f&#34;),&#160;Var&#160;&#34;x&#34;)))))<br/>Exécutons&#160;avec&#160;la&#160;stratégie&#160;normale,&#160;puis&#160;avec&#160;la&#160;stratégie&#160;de&#160;réduction&#160;faible&#160;par&#160;valeur&#160;:<br/>
#&#160;betaNormalPrint&#160;(App(succ,&#160;un))&#160;;;<br/>
(<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))<i>λf.λx.</i>(<i>f&#160;x</i>))<br/>
→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>((<i>λf.λx.</i>(<i>f&#160;x</i>)<i>f&#160;</i>)<i>x</i>))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>λx.</i>(<i>f&#160;x</i>)<i>x</i>))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;x</i>))<br/>
<i>Exception&#160;</i>:&#160;<i>IRREDU&#160;CT&#160;IBLE.</i><br/>
#&#160;betaValeurPrint&#160;(App(succ,&#160;un))&#160;;;<br/>
(<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))<i>λf.λx.</i>(<i>f&#160;x</i>))<br/>
→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>((<i>λf.λx.</i>(<i>f&#160;x</i>)<i>f&#160;</i>)<i>x</i>))<br/>
<i>Exception&#160;</i>:&#160;<i>IRREDU&#160;CT&#160;IBLE.</i><br/>
Nous&#160;n’aboutissons&#160;pas&#160;au&#160;terme&#160;<i>λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;x</i>))&#160;avec&#160;la&#160;stratégie&#160;par&#160;valeur.&#160;Nous&#160;voyons&#160;que&#160;le<br/>corps&#160;de&#160;la&#160;lambda&#160;n’est&#160;pas&#160;évalué.&#160;Je&#160;suis&#160;cependant&#160;surpris&#160;car&#160;je&#160;pensais&#160;cette&#160;stratégie&#160;(même<br/>si&#160;appelée&#160;<i>faible</i>)&#160;parvenait&#160;à&#160;calculer&#160;la&#160;forme&#160;normale.<br/>
Nous&#160;pouvons&#160;écrire&#160;en&#160;OCAML&#160;la&#160;fonction&#160;qui&#160;convertit&#160;des&#160;entiers&#160;vers&#160;les&#160;terms&#160;<i>Church&#160;</i>:<br/>
24<br/>
<hr/>
<a name=25></a>let&#160;rec&#160;int2Church&#160;=&#160;function<br/>
|&#160;0&#160;-&gt;&#160;Lam(&#34;f&#34;,&#160;Lam(&#34;x&#34;,&#160;Var&#160;&#34;x&#34;))<br/>
|&#160;n&#160;-&gt;&#160;App(succ,&#160;int2Church&#160;(n-1))<br/>
#&#160;betaNormal&#160;(int2Church&#160;3)&#160;;;<br/>
(<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))(<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))(<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))<i>λf.λx.x</i>)))<br/>
→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(((<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))(<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))<i>λf.λx.x</i>))<i>f&#160;</i>)<i>x</i>))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>((<i>λf.λx.</i>(<i>f&#160;</i>(((<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))<i>λf.λx.x</i>)<i>f&#160;</i>)<i>x</i>))<i>f&#160;</i>)<i>x</i>))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>λx.</i>(<i>f&#160;</i>(((<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))<i>λf.λx.x</i>)<i>f&#160;</i>)<i>x</i>))<i>x</i>))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;</i>(((<i>λn.λf.λx.</i>(<i>f&#160;</i>((<i>nf&#160;</i>)<i>x</i>))<i>λf.λx.x</i>)<i>f&#160;</i>)<i>x</i>)))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;</i>((<i>λf.λx.</i>(<i>f&#160;</i>((<i>λf.λx.xf&#160;</i>)<i>x</i>))<i>f&#160;</i>)<i>x</i>)))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>λx.</i>(<i>f&#160;</i>((<i>λf.λx.xf&#160;</i>)<i>x</i>))<i>x</i>)))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>f&#160;</i>((<i>λf.λx.xf&#160;</i>)<i>x</i>))))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>λx.xx</i>))))<br/>→<i>β&#160;λf.λx.</i>(<i>f&#160;</i>(<i>f&#160;</i>(<i>f&#160;x</i>)))<br/>
<i>Exception&#160;</i>:&#160;<i>IRREDU&#160;CT&#160;IBLE.</i><br/>
L’addition&#160;peut&#160;être&#160;exprimée&#160;par&#160;le&#160;combinateur&#160;<i>λm.λn.λf.λx.mf&#160;</i>(<i>nf&#160;x</i>)<i>x<br/></i>La&#160;multiplication&#160;peut&#160;être&#160;exprimée&#160;par&#160;le&#160;combinateur&#160;<i>λm.λn.λf.λx.m</i>(<i>nf&#160;</i>)<i>x<br/></i>Le&#160;prédecesseur&#160;peut&#160;être&#160;exprimé&#160;par&#160;le&#160;combinateur&#160;<i>λn.λf.λx.n&#160;</i>(<i>λg.λh.h&#160;</i>(<i>g&#160;f&#160;</i>))&#160;(<i>λu.x</i>)&#160;(<i>λu.u</i>)<br/>Après&#160;avoir&#160;défini&#160;les&#160;termes&#160;succ&#160;et&#160;pred,&#160;nous&#160;pouvons&#160;écrire&#160;les&#160;deux&#160;fonctions&#160;suivantes&#160;qui<br/>
“jonglent”&#160;entre&#160;les&#160;entiers&#160;ML&#160;et&#160;les&#160;entiers&#160;Church.<br/>
let&#160;int2Church&#160;n&#160;=<br/>
let&#160;rec&#160;aux&#160;=&#160;function<br/>
|&#160;0&#160;-&gt;&#160;Lam(&#34;f&#34;,&#160;Lam(&#34;x&#34;,&#160;Var&#160;&#34;x&#34;))<br/>
|&#160;n&#160;-&gt;&#160;App(succ,&#160;aux&#160;(n-1))<br/>
in&#160;betaNormal&#160;(aux&#160;n)<br/>
let&#160;rec&#160;church2Int<br/>
terme&#160;=<br/>
match&#160;terme&#160;with<br/>
|&#160;Lam(&#34;f&#34;,&#160;Lam(&#34;x&#34;,&#160;Var&#160;&#34;x&#34;))&#160;-&gt;&#160;0<br/>
|&#160;_&#160;-&gt;&#160;1&#160;+&#160;church2Int&#160;(betaNormal(App(pred,&#160;terme)))<br/>
#&#160;church2Int&#160;(int2Church&#160;10);;<br/>
-&#160;:&#160;int&#160;=&#160;10<br/>
Egalement,&#160;nous&#160;pouvons&#160;représenter&#160;directement&#160;en&#160;ML&#160;les&#160;entiers&#160;<i>Church&#160;</i>sous&#160;forme&#160;de<br/>
fonctionnelles&#160;:<br/>
let&#160;zero&#160;f&#160;x&#160;=&#160;x<br/>
let&#160;un&#160;f&#160;x&#160;=&#160;f&#160;x<br/>
let&#160;deux&#160;f&#160;x&#160;=&#160;f&#160;(f&#160;x)<br/>
let&#160;succ&#160;n&#160;f&#160;x&#160;=&#160;f&#160;(n&#160;f&#160;x)<br/>
let&#160;add&#160;n&#160;m&#160;f&#160;x&#160;=&#160;n&#160;f&#160;(m&#160;f&#160;x)<br/>
25<br/>
<hr/>
<a name=26></a>let&#160;to_int&#160;n&#160;=&#160;n&#160;(function&#160;k&#160;-&gt;&#160;k&#160;+&#160;1)&#160;0<br/>
let&#160;rec&#160;to_church&#160;=&#160;function<br/>
|&#160;0&#160;-&gt;&#160;zero<br/>
|&#160;n&#160;-&gt;&#160;succ&#160;(to_church&#160;(n-1))<br/>
#to_int&#160;(add&#160;deux&#160;(succ&#160;(to_church&#160;5)))&#160;;;<br/>
-&#160;:&#160;int&#160;=&#160;8<br/>
<b>1.5.2</b><br/>
<b>Les&#160;booléens</b><br/>
Nous&#160;pourrons&#160;les&#160;représenter&#160;de&#160;la&#160;façon&#160;suivante.&#160;On&#160;y&#160;ajoute&#160;le&#160;prédicat&#160;IsZero.<br/>
true<br/>
≡&#160;<i>λa.λb.a</i><br/>
false<br/>
≡&#160;<i>λa.λb.b</i><br/>
and<br/>
≡&#160;<i>λp.λq.p&#160;q&#160;p</i><br/>
or<br/>
≡&#160;<i>λp.λq.p&#160;p&#160;q</i><br/>
not<br/>
≡&#160;<i>λp.p&#160;</i>(<i>λa.λb.b</i>)&#160;(<i>λa.λb.a</i>)&#160;=&#160;<i>λp.p&#160;</i>false&#160;true<br/>
if<br/>
≡&#160;<i>λp.λa.λb.p&#160;a&#160;b</i><br/>
IsZero<br/>
≡&#160;<i>λn.n&#160;</i>(<i>λx.&#160;</i>false)&#160;true<br/>
<b>1.5.3</b><br/>
<b>La&#160;fonction&#160;factorielle</b><br/>
Nous&#160;pouvons&#160;l’exprimer&#160;de&#160;manière&#160;assez&#160;simple.&#160;La&#160;difficulté&#160;est&#160;de&#160;manipuler&#160;toujours&#160;les<br/>
applications&#160;avec&#160;un&#160;seul&#160;argument,&#160;en&#160;version&#160;<i>curryfiées</i>.&#160;Nous&#160;appliquons&#160;le&#160;combinateur&#160;<i>Y&#160;</i>associé<br/>à&#160;la&#160;stratégie&#160;de&#160;réduction&#160;normale.&#160;Attention&#160;à&#160;ne&#160;pas&#160;réduire&#160;telle&#160;quelle&#160;la&#160;fonction&#160;fact.&#160;La<br/>réduction&#160;serait&#160;infinie&#160;comme&#160;on&#160;l’a&#160;vu&#160;précedemment.&#160;Seul&#160;la&#160;présence&#160;d’un&#160;argument&#160;permet<br/>d’aboutir&#160;à&#160;la&#160;forme&#160;normale.<br/>
Cette&#160;forme&#160;normale&#160;constitue&#160;notre&#160;<i>valeur&#160;</i>(au&#160;sens&#160;d’un&#160;langage&#160;interprété).<br/>
let&#160;fact&#160;=<br/>
App&#160;(y,<br/>
(Lam&#160;(&#34;f&#34;,<br/>
(Lam&#160;(&#34;n&#34;,<br/>
(App&#160;((App&#160;((App&#160;(si,&#160;(App&#160;(isZero,&#160;(Var&#160;&#34;n&#34;))))),&#160;un)),<br/>
(App&#160;((App&#160;(mult,&#160;(Var&#160;&#34;n&#34;))),<br/>
(App&#160;((Var&#160;&#34;f&#34;),&#160;(App&#160;(pred,&#160;(Var&#160;&#34;n&#34;))))))))))))))<br/>
#&#160;church2Int&#160;(betaNormal&#160;(App(fact,&#160;int2Church&#160;4)));;<br/>
-&#160;:&#160;int&#160;=&#160;24<br/>
Nous&#160;n’afficherons&#160;pas&#160;les&#160;réductions&#160;ici.&#160;Le&#160;calcul&#160;de&#160;la&#160;factorielle&#160;de&#160;3&#160;nécessite&#160;705&#160;<i>β</i>-réductions.<br/>La&#160;factorielle&#160;de&#160;5&#160;en&#160;nécessite&#160;plus&#160;de&#160;28000.&#160;.&#160;.<br/>
<b>1.6</b><br/>
<b>La&#160;notation&#160;de&#160;<i>de&#160;Bruijn</i></b><br/>
<i>What’s&#160;in&#160;a&#160;name&#160;?&#160;That&#160;which&#160;we&#160;call&#160;a&#160;rose<br/>By&#160;any&#160;other&#160;name&#160;would&#160;smell&#160;as&#160;sweet.</i><a href="documents.html#127">[18]<br/></a>Citation&#160;reprise&#160;par&#160;Xavier&#160;Leroy&#160;dans&#160;son&#160;excellent&#160;cours&#160;au&#160;collège&#160;de&#160;France<br/>
26<br/>
<hr/>
<a name=27></a>Le&#160;mécanisme&#160;de&#160;capture&#160;d’une&#160;variable&#160;libre&#160;par&#160;une&#160;lambda,&#160;qui&#160;nous&#160;oblige&#160;à&#160;faire&#160;de&#160;manière<br/>
fastidieuse&#160;du&#160;renommage&#160;ponctuel&#160;de&#160;variables,&#160;est&#160;dû&#160;au&#160;fait&#160;qu’il&#160;y&#160;a&#160;un&#160;partage&#160;possible&#160;entre<br/>les&#160;noms&#160;des&#160;variables&#160;libres&#160;et&#160;des&#160;variables&#160;liées.<br/>
Pour&#160;éviter&#160;cela,&#160;nous&#160;pouvons&#160;utiliser&#160;une&#160;autre&#160;représentation&#160;du&#160;<i>λ</i>-terme.&#160;Le&#160;principe&#160;est&#160;de<br/>
nommer&#160;les&#160;variables&#160;liées&#160;par&#160;un&#160;indice&#160;indiquant&#160;la&#160;profondeur&#160;de&#160;leurs&#160;liens&#160;(ou&#160;autrement&#160;dit<br/>la&#160;hauteur&#160;de&#160;leurs&#160;liaisons).<br/>
L’arbre&#160;syntaxique&#160;sera&#160;alors&#160;défini&#160;par&#160;:<br/>
1.&#160;les&#160;feuilles&#160;qui&#160;correspondent&#160;à&#160;des&#160;variables&#160;libres&#160;ou&#160;liées,&#160;représentées&#160;par&#160;un&#160;indice<br/>
2.&#160;le&#160;noeud&#160;unaire&#160;<i>λ</i><br/>
3.&#160;le&#160;noeud&#160;binaire&#160;@<br/>
type&#160;tbruijn&#160;=<br/>
|&#160;Va&#160;of&#160;int<br/>
|&#160;La&#160;of&#160;tbruijn<br/>
|&#160;Ap&#160;of&#160;tbruijn&#160;*&#160;tbruijn<br/>
Soit&#160;le&#160;terme&#160;<i>M&#160;</i>=&#160;<i>λx.x</i>(<i>λy.yx</i>),&#160;indiquons&#160;en&#160;exposant&#160;la&#160;hauteur&#160;de&#160;la&#160;liaison&#160;de&#160;chaque<br/>
variable&#160;liée&#160;:&#160;<i>M&#160;</i>=&#160;<i>λx.x</i>0(<i>λy.y</i>0<i>x</i>1)<br/>
Figure&#160;1.1&#160;–&#160;Représentation&#160;du&#160;terme&#160;<i>λx.x</i>(<i>λy.yx</i>)<br/>
<i>λ</i><br/>
@<br/>
0<br/>
<i>λ</i><br/>
@<br/>
0<br/>
1<br/>
Pour&#160;les&#160;variables&#160;libres,&#160;nous&#160;pouvons&#160;aussi&#160;utiliser&#160;un&#160;indice&#160;pour&#160;les&#160;nommer.&#160;Soit&#160;un&#160;ensemble<br/>
de&#160;variables&#160;libres&#160;<i>x</i>1<i>,&#160;x</i>2<i>,&#160;x</i>3<i>,&#160;.&#160;.&#160;.&#160;,&#160;xn&#160;</i>nous&#160;les&#160;nommerons&#160;en&#160;ajoutant&#160;à&#160;leur&#160;indice&#160;<i>i&#160;</i>la&#160;profondeur<br/>jusqu’à&#160;la&#160;racine.&#160;Les&#160;indices&#160;des&#160;variables&#160;libres&#160;seront&#160;donc&#160;toujours&#160;supérieur&#160;à&#160;ceux&#160;des&#160;variables<br/>liées&#160;sur&#160;leurs&#160;branches.&#160;Cependant,&#160;avec&#160;cette&#160;notation&#160;une&#160;même&#160;variable&#160;libre&#160;avec&#160;plusieurs<br/>occurences&#160;dans&#160;un&#160;terme&#160;pourra&#160;avoir&#160;des&#160;indices&#160;différents.<br/>
Nous&#160;avons&#160;maintenant&#160;une&#160;représentation&#160;<i>canonique&#160;</i>:&#160;deux&#160;termes&#160;sont&#160;<i>α</i>-équivalents&#160;si&#160;et<br/>
seulement&#160;si&#160;leurs&#160;représentations&#160;en&#160;de&#160;de&#160;Bruijn&#160;sont&#160;égales.<br/>
Voici&#160;une&#160;fonction&#160;d’implémentation&#160;t2b&#160;transformant&#160;des&#160;termes&#160;en&#160;termes&#160;de&#160;de&#160;Bruijn.<br/>
let&#160;reste&#160;s&#160;=&#160;int_of_string(sub&#160;s&#160;1&#160;((String.length&#160;s)-1))&#160;;;<br/>
let&#160;add_env&#160;var&#160;env&#160;=<br/>
(var,0)::map&#160;(fun&#160;pp&#160;-&gt;&#160;(fst(pp),(1&#160;+&#160;snd(pp))))&#160;env&#160;;;<br/>
let&#160;t2b&#160;terme&#160;=<br/>
let&#160;l&#160;=&#160;varLibres&#160;terme&#160;in<br/>
let&#160;rec&#160;terme_to_bruijn&#160;t&#160;env&#160;hauteur&#160;=<br/>
27<br/>
<hr/>
<a name=28></a>match&#160;t&#160;with<br/>
|&#160;Var&#160;x&#160;-&gt;&#160;if&#160;(mem&#160;x&#160;l)&#160;then&#160;Va((reste&#160;x)&#160;+&#160;hauteur)&#160;else&#160;Va(assoc&#160;x&#160;env)<br/>
|&#160;App&#160;(n1,&#160;n2)&#160;-&gt;&#160;Ap&#160;(terme_to_bruijn&#160;n1&#160;env&#160;hauteur,&#160;terme_to_bruijn&#160;n2&#160;env&#160;hauteur)<br/>
|&#160;Lam&#160;(x,&#160;c)&#160;-&gt;&#160;La&#160;(terme_to_bruijn&#160;c&#160;(add_env&#160;x&#160;env)&#160;(hauteur+1)&#160;)<br/>
in&#160;terme_to_bruijn&#160;terme&#160;[]&#160;0<br/>
let&#160;decalage&#160;d&#160;t&#160;=<br/>
let&#160;rec&#160;aux&#160;p&#160;=&#160;function<br/>
|&#160;Ap&#160;(t1,t2)&#160;-&gt;&#160;Ap&#160;(aux&#160;p&#160;t1,&#160;aux&#160;p&#160;t2)<br/>
|&#160;La&#160;(t)&#160;-&gt;&#160;La&#160;(aux&#160;(p+1)&#160;t)<br/>
|&#160;Va&#160;(i)&#160;when&#160;i&lt;p&#160;-&gt;&#160;Va(i)<br/>
|&#160;Va(i)&#160;-&gt;&#160;Va&#160;(i+d)<br/>
in&#160;aux&#160;0&#160;t<br/>
let&#160;beta_b&#160;(La&#160;u)&#160;t&#160;=<br/>
let&#160;rec&#160;aux&#160;p&#160;=&#160;function<br/>
|&#160;Ap&#160;(u1,u2)&#160;-&gt;&#160;Ap&#160;(aux&#160;p&#160;u1,&#160;aux&#160;p&#160;u2)<br/>
|&#160;La&#160;(v)&#160;-&gt;&#160;La&#160;(aux&#160;(p+1)&#160;v)<br/>
|&#160;Va&#160;(i)<br/>
when&#160;i=p&#160;-&gt;&#160;decalage&#160;p&#160;t&#160;(*on&#160;rend&#160;t&#160;décalé&#160;de&#160;la&#160;profondeur&#160;d’abstr&#160;p*)<br/>
|&#160;Va&#160;(i)<br/>
when&#160;i&lt;p&#160;-&gt;&#160;Va&#160;(i)&#160;(*i&#160;est&#160;lié,&#160;on&#160;la&#160;rend&#160;tel&#160;quel&#160;*)<br/>
|&#160;Va&#160;(i)&#160;-&gt;&#160;Va&#160;(i-1)&#160;(*&#160;on&#160;décrèmente&#160;la&#160;variable&#160;libre&#160;car&#160;la&#160;betareduc&#160;supprime&#160;une&#160;lamdda*)<br/>
in&#160;aux&#160;0&#160;u&#160;;;<br/>
let&#160;rec&#160;normale_bruijn<br/>
=&#160;function<br/>
|&#160;Va&#160;x&#160;-&gt;&#160;raise&#160;IRREDUCTIBLE<br/>
|&#160;La&#160;n&#160;-&gt;&#160;La&#160;(normale_bruijn&#160;n)<br/>
|&#160;Ap&#160;(La&#160;n,&#160;m)&#160;-&gt;&#160;beta_b&#160;(La&#160;n)&#160;m<br/>
|&#160;Ap&#160;(n,m)&#160;-&gt;&#160;try&#160;Ap&#160;(normale_bruijn<br/>
n,&#160;m)<br/>
with&#160;IRREDUCTIBLE&#160;-&gt;&#160;Ap&#160;(n,&#160;normale_bruijn<br/>
m)<br/>
let&#160;rec&#160;reduc_bruijn&#160;t&#160;=<br/>
try&#160;reduc_bruijn&#160;(normale_bruijn&#160;t)<br/>
with&#160;IRREDUCTIBLE&#160;-&gt;&#160;t<br/>
Représenter&#160;l’ensemble&#160;des&#160;variables&#160;(libres&#160;et&#160;liées)&#160;par&#160;un&#160;indice&#160;de&#160;profondeur&#160;rend&#160;le&#160;terme<br/>
très&#160;peu&#160;lisible.&#160;La&#160;représentation&#160;la&#160;plus&#160;commode&#160;semble&#160;finalement&#160;être&#160;d’utiliser&#160;la&#160;notation&#160;de<br/><i>de&#160;Bruijn&#160;</i>pour&#160;les&#160;variables&#160;liées&#160;et&#160;continuer&#160;à&#160;nommer&#160;les&#160;variables&#160;libres&#160;par&#160;des&#160;lettres.<br/>
Cela&#160;impose&#160;dans&#160;la&#160;définition&#160;inductive&#160;du&#160;terme&#160;de&#160;distinguer&#160;les&#160;variables&#160;libres&#160;des&#160;variables<br/>
liées.<br/>
Par&#160;exemple&#160;en&#160;COQ&#160;:<br/>
Inductive&#160;terme&#160;:&#160;Set&#160;:=<br/>
|&#160;bvar&#160;:&#160;nat&#160;-&gt;&#160;terme<br/>
|&#160;fvar&#160;:&#160;string&#160;-&gt;&#160;terme<br/>
|&#160;abs<br/>
:&#160;terme&#160;-&gt;&#160;terme<br/>
|&#160;app<br/>
:&#160;terme&#160;-&gt;&#160;terme&#160;-&gt;&#160;terme.<br/>
28<br/>
<hr/>
<a name=29></a><b>Chapitre&#160;2</b><br/>
<b>Le&#160;</b><i>λ</i><b>-calcul&#160;simplement&#160;typé&#160;et&#160;les<br/>Pure&#160;Type&#160;Systems</b><br/>
<b>2.1</b><br/>
<b>Le&#160;</b><i>λ</i><b>-calcul&#160;simplement&#160;typé</b><br/>
<b>2.1.1</b><br/>
<b>Présentation</b><br/>
Un&#160;terme&#160;comme&#160;<i>λx.xx&#160;</i>n’a&#160;pas&#160;de&#160;sens&#160;en&#160;mathématiques.&#160;Comment&#160;<i>x&#160;</i>peut&#160;être&#160;à&#160;la&#160;fois&#160;un<br/>
argument&#160;et&#160;la&#160;fonction&#160;qu’on&#160;lui&#160;applique&#160;?&#160;Le&#160;<i>λ</i>-calcul&#160;typé&#160;introduit&#160;des&#160;types&#160;simples&#160;permettant<br/>de&#160;distinguer&#160;les&#160;fonctions&#160;des&#160;variables.<br/>
Un&#160;contexte,&#160;ou&#160;environnement&#160;de&#160;typage&#160;Γ,&#160;est&#160;un&#160;ensemble&#160;de&#160;paires&#160;de&#160;la&#160;forme&#160;(<i>x,&#160;τ&#160;</i>)&#160;où&#160;<i>x</i><br/>
est&#160;une&#160;variable&#160;et&#160;<i>τ&#160;</i>un&#160;type.&#160;Un&#160;jugement&#160;de&#160;typage&#160;est&#160;un&#160;triplet&#160;Γ&#160;`&#160;<i>t&#160;</i>:&#160;<i>τ</i><br/>
Le&#160;terme&#160;<i>t&#160;</i>sera&#160;bien&#160;typé&#160;dans&#160;Γ&#160;par&#160;les&#160;règles&#160;de&#160;jugement&#160;suivantes&#160;:<br/>
si&#160;(<i>x,&#160;τ&#160;</i>)&#160;∈&#160;Γ<i>,&#160;</i>alors&#160;Γ&#160;`&#160;<i>x&#160;</i>:&#160;<i>τ</i><br/>
si&#160;Γ&#160;∪&#160;(<i>x,&#160;τ</i>1)&#160;`&#160;<i>u&#160;</i>:&#160;<i>τ</i>2<i>,&#160;</i>alors&#160;Γ&#160;`&#160;<i>λx&#160;</i>:&#160;<i>τ</i>1<i>.u&#160;</i>:&#160;<i>τ</i>1&#160;→&#160;<i>τ</i>2<br/>
si&#160;Γ&#160;`&#160;<i>u&#160;</i>:&#160;<i>τ</i>1&#160;→&#160;<i>τ</i>2&#160;et&#160;Γ&#160;`&#160;<i>v&#160;</i>:&#160;<i>τ</i>1<i>,&#160;</i>alors&#160;Γ&#160;`&#160;<i>uv&#160;</i>:&#160;<i>τ</i>2<br/>
<b>2.1.2</b><br/>
<b>Implémentation&#160;en&#160;COQ</b><br/>
<b>Représentation&#160;des&#160;types&#160;et&#160;des&#160;termes</b><br/>
Pour&#160;les&#160;types,&#160;nous&#160;avons&#160;deux&#160;constructeurs,&#160;un&#160;pour&#160;les&#160;types&#160;de&#160;variable&#160;and&#160;un&#160;pour&#160;les<br/>
types&#160;des&#160;abstractions&#160;:&#160;le&#160;type&#160;flèche&#160;de&#160;la&#160;forme&#160;<i>T</i>1&#160;→&#160;<i>T</i>2.<br/>
Inductive&#160;typ&#160;:&#160;Set&#160;:=<br/>
|&#160;typ_var<br/>
:&#160;string&#160;-&gt;&#160;typ<br/>
|&#160;typ_arrow&#160;:&#160;typ&#160;-&gt;&#160;typ&#160;-&gt;&#160;typ.<br/>
Pour&#160;les&#160;termes,&#160;nous&#160;utilisons&#160;la&#160;<i>locally&#160;namless&#160;representation&#160;</i>Les&#160;variables&#160;liées&#160;sont&#160;repré-<br/>
sentées&#160;par&#160;les&#160;indices&#160;de&#160;<i>de&#160;Bruijn&#160;</i>et&#160;les&#160;variables&#160;libres&#160;par&#160;des&#160;chaînes&#160;de&#160;caractères.<br/>
29<br/>
<hr/>
<a name=30></a>Inductive&#160;terme&#160;:&#160;Set&#160;:=<br/>
|&#160;bvar&#160;:&#160;nat&#160;-&gt;&#160;terme<br/>
|&#160;fvar&#160;:&#160;string&#160;-&gt;&#160;terme<br/>
|&#160;abs<br/>
:&#160;terme&#160;-&gt;&#160;terme<br/>
|&#160;app<br/>
:&#160;terme&#160;-&gt;&#160;terme&#160;-&gt;&#160;terme.<br/>
Coercion&#160;bvar&#160;:&#160;nat&#160;&gt;-&gt;&#160;terme.<br/>
Coercion&#160;fvar&#160;:&#160;string&#160;&gt;-&gt;&#160;terme.<br/>
Voici&#160;un&#160;exemple&#160;avec&#160;le&#160;terme&#160;<i>t</i>2&#160;=&#160;<i>λx.λy.</i>(<i>yx</i>))<br/>
Definition&#160;t2&#160;:=&#160;abs&#160;(abs&#160;(app&#160;0&#160;1)).<br/>
<b>Opening</b><br/>
L’<i>opening&#160;</i>remplace&#160;un&#160;indice&#160;par&#160;un&#160;terme.&#160;Cela&#160;correspond&#160;à&#160;la&#160;substitution&#160;d’une&#160;variable<br/>
liée,&#160;telle&#160;qu’appliquée&#160;lors&#160;de&#160;la&#160;<i>β</i>-réduction.<br/>
Fixpoint&#160;open_rec&#160;(k&#160;:&#160;nat)&#160;(u&#160;:&#160;terme)&#160;(t&#160;:&#160;terme)&#160;{struct&#160;t}&#160;:&#160;terme&#160;:=<br/>
match&#160;t&#160;with<br/>
|&#160;bvar&#160;i<br/>
=&gt;&#160;if&#160;k&#160;=?&#160;i&#160;then&#160;u&#160;else&#160;(bvar&#160;i)<br/>
|&#160;fvar&#160;x<br/>
=&gt;&#160;fvar&#160;x<br/>
|&#160;abs&#160;t1<br/>
=&gt;&#160;abs&#160;(open_rec&#160;(S&#160;k)&#160;u&#160;t1)<br/>
|&#160;app&#160;t1&#160;t2&#160;=&gt;&#160;app&#160;(open_rec&#160;k&#160;u&#160;t1)&#160;(open_rec&#160;k&#160;u&#160;t2)<br/>
end.<br/>
Definition&#160;open&#160;t&#160;u&#160;:=&#160;open_rec&#160;0&#160;u&#160;t.<br/>
Notation&#160;&#34;{&#160;k&#160;~&gt;&#160;u&#160;}&#160;t&#34;&#160;:=&#160;(open_rec&#160;k&#160;u&#160;t)&#160;(at&#160;level&#160;67).<br/>
Notation&#160;&#34;t&#160;^^&#160;u&#34;&#160;:=&#160;(open&#160;t&#160;u)&#160;(at&#160;level&#160;67).<br/>
Notation&#160;&#34;t&#160;^&#160;x&#34;&#160;:=&#160;(open&#160;t&#160;(fvar&#160;x)).<br/>
Lemma&#160;demo_open&#160;:<br/>
open&#160;(app&#160;(abs&#160;(app&#160;1&#160;0))&#160;0)&#160;&#34;Y&#34;&#160;=<br/>
(app&#160;(abs&#160;(app&#160;&#34;Y&#34;&#160;0))&#160;&#34;Y&#34;).<br/>
Proof.<br/>
unfold&#160;open.&#160;unfold&#160;open_rec.&#160;auto.<br/>
Qed.<br/>
<b>La&#160;sémantique</b><br/>
Nous&#160;définissons&#160;la&#160;sémantique&#160;de&#160;la&#160;réduction&#160;avec&#160;appel&#160;par&#160;valeur.<br/>
Inductive&#160;valeur&#160;:&#160;terme&#160;-&gt;&#160;Prop&#160;:=<br/>
|&#160;valeur_abs&#160;:&#160;forall&#160;(t1:&#160;terme),&#160;valeur&#160;(abs&#160;t1).<br/>
Inductive&#160;red&#160;:&#160;terme&#160;-&gt;&#160;terme&#160;-&gt;&#160;Prop&#160;:=<br/>
|&#160;red_beta&#160;:&#160;forall&#160;(t1&#160;t2:terme),<br/>
30<br/>
<hr/>
<a name=31></a>valeur&#160;t2&#160;-&gt;<br/>
red&#160;(app&#160;(abs&#160;t1)&#160;t2)&#160;(t1&#160;^^&#160;t2)<br/>
|&#160;red_app_1&#160;:&#160;forall&#160;t1&#160;t1’&#160;t2&#160;:terme,<br/>
red&#160;t1&#160;t1’&#160;-&gt;<br/>
red&#160;(app&#160;t1&#160;t2)&#160;(app&#160;t1’&#160;t2)<br/>
|&#160;red_app_2&#160;:&#160;forall&#160;t1&#160;t2&#160;t2’&#160;:terme,<br/>
valeur&#160;t1&#160;-&gt;<br/>
red&#160;t2&#160;t2’&#160;-&gt;<br/>
red&#160;(app&#160;t1&#160;t2)&#160;(app&#160;t1&#160;t2’).<br/>
Nous&#160;utilisons&#160;la&#160;notation&#160;t&#160;--&gt;&#160;t’&#160;pour&#160;la&#160;réduction&#160;en&#160;une&#160;étape.<br/>
Notation&#160;&#34;t&#160;--&gt;&#160;t’&#34;&#160;:=&#160;(red&#160;t&#160;t’)&#160;(at&#160;level&#160;68).<br/>
<b>La&#160;gestion&#160;de&#160;l’environnement&#160;et&#160;du&#160;contexte</b><br/>
Definition&#160;ctx&#160;:=&#160;list&#160;(string&#160;*&#160;typ).<br/>
Open&#160;Scope&#160;list_scope.<br/>
Module&#160;ListNotations.<br/>
Notation&#160;&#34;&#160;[&#160;]&#160;&#34;&#160;:=&#160;nil&#160;:&#160;list_scope.<br/>
Notation&#160;&#34;&#160;[&#160;x&#160;]&#160;&#34;&#160;:=&#160;(cons&#160;x&#160;nil)&#160;:&#160;list_scope.<br/>
Notation&#160;&#34;&#160;[&#160;x&#160;;&#160;..&#160;;&#160;y&#160;]&#160;&#34;&#160;:=&#160;(cons&#160;x&#160;..&#160;(cons&#160;y&#160;nil)&#160;..)&#160;:&#160;list_scope.<br/>
Notation&#160;&#34;&#160;s1&#160;&amp;&#160;s2&#160;&#34;&#160;:=&#160;(Datatypes.app&#160;s1&#160;s2)&#160;(at&#160;level&#160;67)<br/>
:&#160;list_scope.<br/>
End&#160;ListNotations.<br/>
Import&#160;ListNotations.<br/>
Definition&#160;e1&#160;:ctx&#160;:=&#160;[&#160;(&#34;v1&#34;,&#160;typ_var&#160;&#34;entier&#34;)&#160;].<br/>
Definition&#160;e2&#160;:ctx&#160;:=&#160;[&#160;(&#34;v2&#34;,&#160;typ_var&#160;&#34;entier&#34;)&#160;].<br/>
Compute&#160;e1&#160;&amp;&#160;e2&#160;.<br/>
<b>Le&#160;typage</b><br/>
If&#160;<i>E&#160;</i>and&#160;<i>F&#160;</i>are&#160;two&#160;contexts,&#160;then&#160;<i>E&#160;</i>&amp;<i>F&#160;</i>denotes&#160;their&#160;concatenation.&#160;If&#160;<i>x&#160;</i>is&#160;a&#160;variable&#160;and&#160;<i>T&#160;</i>is<br/>
a&#160;type,&#160;then&#160;(<i>x&#160;T&#160;</i>)&#160;denotes&#160;a&#160;singleton&#160;environment&#160;where&#160;<i>x&#160;</i>is&#160;bound&#160;to&#160;<i>T&#160;</i>.&#160;In&#160;particular,&#160;<i>E&#160;</i>&amp;<i>x&#160;T<br/></i>denotes&#160;a&#160;context&#160;<i>E&#160;</i>extended&#160;with&#160;a&#160;binding&#160;from&#160;<i>x&#160;</i>to&#160;<i>T&#160;</i>.&#160;The&#160;empty&#160;environment&#160;is&#160;called&#160;<i>empty</i>.<br/>
The&#160;ternary&#160;predicate&#160;<i>binds&#160;</i>holds&#160;when&#160;a&#160;given&#160;binding&#160;is&#160;present&#160;in&#160;an&#160;environment.<br/>
Fixpoint&#160;binds&#160;(x:string)&#160;(T:typ)&#160;(E:ctx)&#160;{struct&#160;E}&#160;:&#160;Prop&#160;:=<br/>
match&#160;E&#160;with<br/>
|&#160;[]&#160;=&gt;&#160;False<br/>
|&#160;(v,t)&#160;::&#160;r&#160;=&gt;&#160;(x=v&#160;/\&#160;T=t)&#160;\/&#160;binds&#160;x&#160;T&#160;r<br/>
end.<br/>
Compute&#160;binds&#160;&#34;v1&#34;&#160;(typ_var&#160;&#34;entier&#34;)&#160;e1.<br/>
Compute&#160;e1.<br/>
31<br/>
<hr/>
<a name=32></a>Theorem&#160;b1&#160;:&#160;binds&#160;&#34;v1&#34;&#160;(typ_var&#160;&#34;entier&#34;)&#160;e1.<br/>
Proof.<br/>
simpl.<br/>
left.<br/>
auto.<br/>
Qed.<br/>
Reserved&#160;Notation&#160;&#34;E&#160;|=&#160;t&#160;~:&#160;T&#34;&#160;(at&#160;level&#160;69).<br/>
Inductive&#160;typing&#160;:&#160;ctx&#160;-&gt;&#160;terme&#160;-&gt;&#160;typ&#160;-&gt;&#160;Prop&#160;:=<br/>
|&#160;typing_var&#160;:&#160;forall&#160;E&#160;x&#160;T,<br/>
binds&#160;x&#160;T&#160;E&#160;-&gt;<br/>
E&#160;|=&#160;(fvar&#160;x)&#160;~:&#160;T<br/>
|&#160;typing_abs&#160;:&#160;forall<br/>
E&#160;U&#160;T&#160;t1,<br/>
forall&#160;x,<br/>
(E&#160;&amp;&#160;[(x&#160;,&#160;U)]&#160;|=&#160;t1&#160;^&#160;x&#160;~:&#160;T)&#160;-&gt;<br/>
E&#160;|=&#160;(abs&#160;t1)&#160;~:&#160;(typ_arrow&#160;U&#160;T)<br/>
|&#160;typing_app&#160;:&#160;forall&#160;S&#160;T&#160;E&#160;t1&#160;t2,<br/>
E&#160;|=&#160;t1&#160;~:&#160;(typ_arrow&#160;S&#160;T)&#160;-&gt;<br/>
E&#160;|=&#160;t2&#160;~:&#160;S&#160;-&gt;<br/>
E&#160;|=&#160;(app&#160;t1&#160;t2)&#160;~:&#160;T<br/>
where&#160;&#34;E&#160;|=&#160;t&#160;~:&#160;T&#34;&#160;:=&#160;(typing&#160;E&#160;t&#160;T).<br/>
<b>Théorème&#160;de&#160;préservation</b><br/>
Nous&#160;définissons&#160;le&#160;théorème&#160;de&#160;préservation&#160;du&#160;type.<br/>
Definition&#160;preservation_statement&#160;:=&#160;forall&#160;E&#160;t&#160;t’&#160;T,<br/>
E&#160;|=&#160;t&#160;~:&#160;T&#160;-&gt;<br/>
t&#160;--&gt;&#160;t’&#160;-&gt;<br/>
E&#160;|=&#160;t’&#160;~:&#160;T.<br/>
<b>Théorème&#160;de&#160;la&#160;progression</b><br/>
Le&#160;théorème&#160;de&#160;la&#160;progression&#160;nous&#160;dit&#160;que&#160;si&#160;un&#160;terme&#160;ne&#160;se&#160;réduit&#160;plus,&#160;alors&#160;c’est&#160;une&#160;<i>valeur</i>.<br/>
Definition&#160;progress_statement&#160;:=&#160;forall&#160;t&#160;T,<br/>
nil&#160;|=&#160;t&#160;~:&#160;T&#160;-&gt;<br/>
valeur&#160;t<br/>
\/&#160;exists&#160;t’,&#160;t&#160;--&gt;&#160;t’.<br/>
<b>La&#160;substitution</b><br/>
Fixpoint&#160;mem<br/>
(x:string)&#160;(l:list&#160;string)&#160;:&#160;bool&#160;:=<br/>
match&#160;l&#160;with<br/>
|&#160;nil&#160;=&gt;&#160;false<br/>
32<br/>
<hr/>
<a name=33></a>|&#160;h::t&#160;=&gt;&#160;if&#160;h=?x&#160;then&#160;true&#160;else&#160;mem&#160;x&#160;t<br/>
end.<br/>
Fixpoint&#160;union&#160;(l1&#160;l2:&#160;list&#160;string)&#160;:&#160;list&#160;string&#160;:=<br/>
match&#160;l1&#160;with<br/>
|&#160;a1::r1&#160;=&gt;&#160;if&#160;mem&#160;a1&#160;l2&#160;then&#160;union&#160;r1&#160;l2<br/>
else<br/>
a1&#160;::&#160;(union&#160;r1&#160;l2)<br/>
|&#160;nil&#160;=&gt;&#160;l2<br/>
end.<br/>
Fixpoint&#160;fv&#160;(t&#160;:&#160;terme)&#160;{struct&#160;t}&#160;:&#160;list&#160;string&#160;:=<br/>
match&#160;t&#160;with<br/>
|&#160;bvar&#160;i<br/>
=&gt;&#160;nil<br/>
|&#160;fvar&#160;x<br/>
=&gt;&#160;[x]<br/>
|&#160;abs&#160;t1<br/>
=&gt;&#160;(fv&#160;t1)<br/>
|&#160;app&#160;t1&#160;t2&#160;=&gt;&#160;(union&#160;(fv&#160;t1)&#160;(fv&#160;t2))<br/>
end.<br/>
Fixpoint&#160;subst&#160;(z&#160;:&#160;string)&#160;(u&#160;:&#160;terme)&#160;(t&#160;:&#160;terme)&#160;{struct&#160;t}&#160;:&#160;terme&#160;:=<br/>
match&#160;t&#160;with<br/>
|&#160;bvar&#160;i<br/>
=&gt;&#160;bvar&#160;i<br/>
|&#160;fvar&#160;x<br/>
=&gt;&#160;if&#160;x&#160;=?&#160;z&#160;then&#160;u&#160;else&#160;(fvar&#160;x)<br/>
|&#160;abs&#160;t1<br/>
=&gt;&#160;abs&#160;(subst&#160;z&#160;u&#160;t1)<br/>
|&#160;app&#160;t1&#160;t2&#160;=&gt;&#160;app&#160;(subst&#160;z&#160;u&#160;t1)&#160;(subst&#160;z&#160;u&#160;t2)<br/>
end.<br/>
Notation&#160;&#34;[&#160;z&#160;~&gt;&#160;u&#160;]&#160;t&#34;&#160;:=&#160;(subst&#160;z&#160;u&#160;t)&#160;(at&#160;level&#160;68).<br/>
Lemma&#160;demo_subst1:<br/>
[&#34;Y&#34;&#160;~&gt;&#160;&#34;Z&#34;]&#160;(abs&#160;(app&#160;0&#160;&#34;Y&#34;))&#160;=&#160;(abs&#160;(app&#160;0&#160;&#34;Z&#34;)).<br/>
Proof.<br/>
simpl.<br/>
auto.<br/>
Qed.<br/>
<b>2.1.3</b><br/>
<b>Inférence&#160;de&#160;type</b><br/>
Pour&#160;présenter&#160;un&#160;système&#160;d’inférence&#160;de&#160;type,&#160;nous&#160;introduisons&#160;la&#160;constante&#160;de&#160;type&#160;Int&#160;à<br/>
notre&#160;<i>lambda</i>-calcul&#160;simplement&#160;typé.<br/>
type&#160;ltype&#160;=<br/>
|&#160;Int<br/>
|&#160;Vart&#160;of&#160;string<br/>
|&#160;Fleche&#160;of&#160;ltype*ltype<br/>
De&#160;même,&#160;nous&#160;enrichissons&#160;notre&#160;définition&#160;de&#160;terme&#160;avec&#160;le&#160;constructeur&#160;Const&#160;of&#160;int&#160;et&#160;la<br/>
fonction&#160;binaire&#160;Plus<br/>
33<br/>
<hr/>
<a name=34></a>type&#160;terme&#160;=<br/>
|&#160;Var&#160;of&#160;string<br/>
|&#160;App&#160;of&#160;terme&#160;*&#160;terme<br/>
|&#160;Lam&#160;of&#160;string&#160;*&#160;terme<br/>
|&#160;Const&#160;of&#160;int<br/>
|&#160;Plus&#160;of&#160;terme&#160;*&#160;terme<br/>
Prenons&#160;l’exemple&#160;du&#160;terme&#160;apply&#160;≡&#160;<i>λf.λx.f&#160;x<br/></i>L’algorithme&#160;d’inférence&#160;se&#160;déroule&#160;en&#160;quatre&#160;temps.<br/>
1.&#160;Assignation&#160;préliminaire&#160;de&#160;types&#160;ou&#160;variables&#160;de&#160;types&#160;à&#160;chaque&#160;sous-terme&#160;de&#160;l’expression.<br/>
Pour&#160;cela,&#160;nous&#160;parcourons&#160;l’arbre&#160;du&#160;terme&#160;en&#160;y&#160;affectant&#160;à&#160;chaque&#160;variable&#160;liée&#160;une&#160;variable<br/>de&#160;type,&#160;ainsi&#160;qu’à&#160;chaque&#160;sous-terme.&#160;Ce&#160;parcours&#160;nous&#160;rend&#160;en&#160;sortie&#160;une&#160;aliste&#160;comprenant<br/>l’occurence&#160;et&#160;la&#160;variable&#160;de&#160;type&#160;associée&#160;<i>αi</i><br/>
<i>λ</i><br/>
(0<i>,&#160;α</i>1)<br/>
<i>f</i><br/>
<i>λ</i><br/>
(1<i>,&#160;αf&#160;</i>)<br/>
(2<i>,&#160;α</i>2)<br/>
<i>x</i><br/>
@<br/>
(21<i>,&#160;αx</i>)<br/>
(22<i>,&#160;α</i>3)<br/>
<i>f</i><br/>
<i>x</i><br/>
(221<i>,&#160;αf&#160;</i>)<br/>
(222<i>,&#160;αx</i>)<br/>
D<br/>
2.&#160;Collecte&#160;des&#160;contraintes&#160;avec&#160;la&#160;fonction&#160;<i>T&#160;</i>:&#160;terme&#160;7→&#160;type<br/>
D<br/>
—&#160;Pour&#160;une&#160;abstraction&#160;:&#160;<i>e&#160;</i>=&#160;<i>λx.e</i>1<br/>
<i>T&#160;</i>(<i>e</i>)&#160;=&#160;<i>T&#160;</i>(<i>x</i>)&#160;→&#160;<i>T&#160;</i>(<i>e</i>1)<br/>
—&#160;Pour&#160;une&#160;application&#160;:&#160;<i>e&#160;</i>=&#160;<i>e</i>1<i>e</i>2<br/>
<i>T&#160;</i>(<i>e</i>1)&#160;=&#160;<i>T&#160;</i>(<i>e</i>2)&#160;→&#160;<i>T&#160;</i>(<i>e</i>)<br/>
—&#160;Pour&#160;l’application&#160;de&#160;l’addition&#160;:&#160;<i>e&#160;</i>=&#160;<i>e</i>1&#160;+&#160;<i>e</i>2<br/>
<i>T&#160;</i>(<i>e</i>)&#160;=&#160;<i>T&#160;</i>(<i>e</i>1)&#160;=&#160;<i>T&#160;</i>(<i>e</i>2)&#160;=&#160;int<br/>
utop#<br/>
t&#160;;;<br/>
-&#160;:&#160;terme&#160;=&#160;Lam&#160;(&#34;f&#34;,&#160;Lam&#160;(&#34;x&#34;,&#160;App&#160;(Var&#160;&#34;f&#34;,&#160;Var&#160;&#34;x&#34;)))<br/>
utop#&#160;hm&#160;t&#160;;;<br/>
-&#160;:&#160;(ltype&#160;*&#160;ltype)&#160;list&#160;=<br/>
[(Vart&#160;&#34;alpha_1&#34;,&#160;Fleche&#160;(Vart&#160;&#34;alpha_f&#34;,&#160;Vart&#160;&#34;alpha_2&#34;));<br/>
(Vart&#160;&#34;alpha_f&#34;,&#160;Vart&#160;&#34;alpha_f&#34;);<br/>
(Vart&#160;&#34;alpha_2&#34;,&#160;Fleche&#160;(Vart&#160;&#34;alpha_x&#34;,&#160;Vart&#160;&#34;alpha_3&#34;));<br/>
(Vart&#160;&#34;alpha_x&#34;,&#160;Vart&#160;&#34;alpha_x&#34;);<br/>
(Vart&#160;&#34;alpha_f&#34;,&#160;Fleche&#160;(Vart&#160;&#34;alpha_x&#34;,&#160;Vart&#160;&#34;alpha_3&#34;));<br/>
(Vart&#160;&#34;alpha_f&#34;,&#160;Vart&#160;&#34;alpha_f&#34;);&#160;(Vart&#160;&#34;alpha_x&#34;,&#160;Vart&#160;&#34;alpha_x&#34;)]<br/>
3.&#160;Unification&#160;de&#160;ces&#160;constraintes&#160;afin&#160;de&#160;trouver&#160;la&#160;substitution&#160;la&#160;plus&#160;générale&#160;si&#160;l’expression<br/>
est&#160;typable.&#160;Dans&#160;le&#160;cas&#160;contraire,&#160;échec.&#160;Nous&#160;utilisons&#160;l’algorithme&#160;d’unification&#160;que&#160;nous<br/>détaillerons&#160;dans&#160;un&#160;chapitre&#160;suivant.<br/>
4.&#160;Nous&#160;appliquons&#160;cette&#160;substitution&#160;à&#160;la&#160;variable&#160;de&#160;type&#160;initialement&#160;affectée&#160;au&#160;terme&#160;<i>t</i>,&#160;à<br/>
l’étape&#160;1.<br/>
-&#160;:&#160;ltype&#160;=&#160;Fleche&#160;(Fleche&#160;(Vart&#160;&#34;alpha_x&#34;,&#160;Vart&#160;&#34;alpha_3&#34;),<br/>
Fleche&#160;(Vart&#160;&#34;alpha_x&#34;,&#160;Vart&#160;&#34;alpha_3&#34;))<br/>
34<br/>
<hr/>
<a name=35></a><b>2.2</b><br/>
<b>Les&#160;<i>Pure&#160;Type&#160;Systems</i></b><br/>
<b>2.2.1</b><br/>
<b>Introduction</b><br/>
Le&#160;<i>λ</i>-calcul&#160;simplement&#160;typé&#160;que&#160;nous&#160;nommons&#160;<i>λ</i>→&#160;ne&#160;permet&#160;de&#160;représenter&#160;des&#160;fonctions&#160;que<br/>
des&#160;termes&#160;vers&#160;les&#160;termes.&#160;De&#160;manière&#160;générale,&#160;nous&#160;souhaiterions&#160;pouvoir&#160;modéliser&#160;:<br/>
—&#160;Fonction&#160;des&#160;termes&#160;vers&#160;les&#160;termes<br/>—&#160;Fonction&#160;des&#160;types&#160;vers&#160;les&#160;termes&#160;pour&#160;permettre&#160;le&#160;polymorphisme<br/>—&#160;Fonction&#160;des&#160;types&#160;vers&#160;les&#160;types&#160;pour&#160;avoir&#160;des&#160;constructeurs&#160;de&#160;type<br/>—&#160;Fonction&#160;des&#160;termes&#160;vers&#160;les&#160;types&#160;pour&#160;avoir&#160;des&#160;types&#160;dépendants<br/>
Nous&#160;reprenons&#160;ici&#160;le&#160;très&#160;bon&#160;formalisme&#160;de&#160;Barendregt&#160;<a href="documents.html#127">[3]</a><br/>
<b>Définition&#160;5.&#160;</b><i>La&#160;syntaxe&#160;est&#160;la&#160;suivante&#160;:</i><br/>
T&#160;::=&#160;<i>V&#160;</i>|&#160;<i>C&#160;</i>|&#160;T&#160;|&#160;T&#160;|&#160;<i>λV&#160;</i>:&#160;T&#160;<i>.</i>T&#160;|&#160;Π<i>V&#160;</i>:&#160;T&#160;<i>.</i>T<br/>
<i>C&#160;est&#160;l’ensemble&#160;des&#160;deux&#160;constantes&#160;:&#160;</i>∗&#160;<i>et&#160;</i><br/><i>V&#160;est&#160;un&#160;ensemble&#160;fini&#160;de&#160;variables<br/>λ&#160;est&#160;l’opération&#160;d’abstraction<br/></i>Π&#160;<i>est&#160;l’opérateur&#160;produit&#160;permettant&#160;de&#160;matérialiser&#160;le&#160;type&#160;dépendant</i><br/>
Il&#160;n’y&#160;a&#160;donc&#160;pas&#160;de&#160;distinction&#160;entre&#160;les&#160;termes&#160;et&#160;les&#160;types.&#160;Chaque&#160;terme&#160;est&#160;typé,&#160;chaque<br/>
type&#160;est&#160;typé,&#160;avec&#160;un&#160;système&#160;pyramidal&#160;infini.<br/>
Nous&#160;utiliserons&#160;le&#160;formalisme&#160;<i>à&#160;la&#160;Church</i>.&#160;Chaque&#160;terme&#160;est&#160;annoté&#160;de&#160;son&#160;type,&#160;contrairement<br/>
au&#160;<i>λ</i>-calcul&#160;simplement&#160;typé&#160;<i>à&#160;la&#160;Curry&#160;</i>que&#160;nous&#160;avons&#160;présenté&#160;précedemment&#160;où&#160;les&#160;termes&#160;étaient<br/>libres&#160;de&#160;type&#160;et&#160;un&#160;mécanisme&#160;d’inférence&#160;de&#160;type&#160;permettait&#160;ensuite&#160;d’associer&#160;à&#160;chaque&#160;terme<br/>un&#160;type.<br/>
L’environnement&#160;de&#160;type&#160;Γ&#160;est&#160;défini&#160;par&#160;:<br/>
Γ&#160;::=&#160;∅&#160;|&#160;Γ<i>,&#160;x&#160;</i>:&#160;T<br/>
Nous&#160;avons&#160;les&#160;règles&#160;de&#160;réduction&#160;suivantes&#160;:<br/>
(<i>λx&#160;</i>:&#160;<i>A.B</i>)&#160;<i>C&#160;</i>→<i>β&#160;B</i>[<i>C/x</i>]<br/>
<i>B&#160;</i>→<i>β&#160;B</i>0<br/>
<i>λx&#160;</i>:&#160;<i>A.B&#160;</i>→<i>β&#160;λx&#160;</i>:&#160;<i>A.B</i>0<br/>
<i>A&#160;</i>→<i>β&#160;A</i>0<br/>
<i>λx&#160;</i>:&#160;<i>A.B&#160;</i>→<i>β&#160;λx&#160;</i>:&#160;<i>A</i>0<i>.B</i><br/>
<i>B&#160;</i>→<i>β&#160;B</i>0<br/>
Π<i>x&#160;</i>:&#160;<i>A.B&#160;</i>→<i>β&#160;</i>Π<i>x&#160;</i>:&#160;<i>A.B</i>0<br/>
<i>A&#160;</i>→<i>β&#160;A</i>0<br/>
Π<i>x&#160;</i>:&#160;<i>A.B&#160;</i>→<i>β&#160;</i>Π<i>x&#160;</i>:&#160;<i>A</i>0<i>.B</i><br/>
35<br/>
<hr/>
<a name=36></a>Nous&#160;avons&#160;les&#160;règles&#160;de&#160;typage&#160;suivantes.<br/>
(Axiom)<br/>
`&#160;∗&#160;:&#160;<br/>
Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>s</i><br/>
<i>x&#160;</i>does&#160;not&#160;occur&#160;in&#160;Γ<br/>
(Start)<br/>
Γ<i>,&#160;x&#160;</i>:&#160;<i>A&#160;</i>`&#160;<i>x&#160;</i>:&#160;<i>A</i><br/>
Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>B</i><br/>
Γ&#160;`&#160;<i>C&#160;</i>:&#160;<i>s</i><br/>
(Weakening)<br/>
Γ<i>,&#160;x&#160;</i>:&#160;<i>C&#160;</i>`&#160;<i>A&#160;</i>:&#160;<i>B</i><br/>
Γ&#160;`&#160;<i>C&#160;</i>:&#160;Π<i>x&#160;</i>:&#160;<i>A.B</i><br/>
Γ&#160;`&#160;<i>a&#160;</i>:&#160;<i>A</i><br/>
(Application)<br/>
Γ&#160;`&#160;<i>Ca&#160;</i>:&#160;<i>B</i>[<i>a/x</i>]<br/>
Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>B</i><br/>
<i>B&#160;</i>=<i>β&#160;B</i>0<br/>
Γ&#160;`&#160;<i>B</i>0&#160;:&#160;<i>s</i><br/>
(Conversion)<br/>
Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>B</i>0<br/>
Soit&#160;la&#160;paire&#160;(<i>s</i>1<i>,&#160;s</i>2),&#160;nous&#160;avons&#160;les&#160;deux&#160;règles&#160;ci-dessous&#160;:<br/>
Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>s</i>1<br/>
Γ<i>,&#160;x&#160;</i>:&#160;<i>A&#160;</i>`&#160;<i>B&#160;</i>:&#160;<i>s</i>2<br/>
(Product)<br/>
Γ&#160;`&#160;Π<i>x&#160;</i>:&#160;<i>A.B&#160;</i>:&#160;<i>s</i>2<br/>
Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>s</i>1<br/>
Γ<i>,&#160;x&#160;</i>:&#160;<i>A&#160;</i>`&#160;<i>b&#160;</i>:&#160;<i>B</i><br/>
Γ<i>,&#160;x&#160;</i>:&#160;<i>A&#160;</i>`&#160;<i>B&#160;</i>:&#160;<i>s</i>2<br/>
(Abstraction)<br/>
Γ&#160;`&#160;<i>λx&#160;</i>:&#160;<i>A.b&#160;</i>:&#160;Π<i>x&#160;</i>:&#160;<i>A.B</i><br/>
Le&#160;système&#160;<i>PTS&#160;</i>respecte&#160;les&#160;propriétés&#160;suivantes&#160;:<br/>
1.&#160;La&#160;propriété&#160;de&#160;Church-Rosser&#160;:&#160;<i>M&#160;</i>→<i>β&#160;N&#160;</i>et&#160;<i>M&#160;</i>→<i>β&#160;N&#160;</i>0&#160;alors&#160;il&#160;existe&#160;<i>N&#160;</i>00&#160;tel&#160;que<br/>
<i>N&#160;</i>→∗&#160;<i>N&#160;</i>00&#160;et&#160;<i>N&#160;</i>0&#160;→∗&#160;<i>N&#160;</i>00<br/>
<i>β</i><br/>
<i>β</i><br/>
2.&#160;La&#160;propriété&#160;de&#160;réduction&#160;:&#160;Γ&#160;`&#160;<i>M&#160;</i>:&#160;<i>T&#160;</i>et&#160;<i>M&#160;</i>→<i>β&#160;M&#160;</i>0&#160;alors&#160;Γ&#160;`&#160;<i>M&#160;</i>0&#160;:&#160;<i>T</i><br/>
3.&#160;L’unicité&#160;des&#160;types&#160;:&#160;Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>B&#160;</i>et&#160;Γ&#160;`&#160;<i>A&#160;</i>:&#160;<i>B</i>0&#160;alors&#160;<i>B&#160;</i>=<i>β&#160;B</i>0<br/>
Pour&#160;pouvoir&#160;éprouver&#160;notre&#160;système&#160;PTS,&#160;nous&#160;ajoutons&#160;les&#160;constantes&#160;suivantes&#160;à&#160;notre&#160;envi-<br/>
ronnement&#160;Γ<br/>
Γ&#160;=&#160;{(∗&#160;:&#160;);&#160;(nat&#160;:&#160;∗);&#160;(<i>O&#160;</i>:&#160;<i>nat</i>);&#160;(succ&#160;:&#160;Π<i>x&#160;</i>:&#160;nat<i>.</i>nat)}<br/>
Voici&#160;quelques&#160;exemples&#160;interprétés&#160;par&#160;OCAML&#160;ci-dessous.&#160;Nous&#160;avons&#160;simplifié&#160;l’affichage&#160;du<br/>
type&#160;Π<i>x&#160;</i>:&#160;<i>A.B&#160;</i>par&#160;<i>A&#160;</i>→&#160;<i>B&#160;</i>si&#160;<i>x&#160;</i>n’est&#160;pas&#160;une&#160;variable&#160;libre&#160;de&#160;<i>B</i>.<br/>
Nous&#160;utilisons&#160;pour&#160;l’affichage&#160;OCAML&#160;les&#160;caractères&#160;UTF-8&#160;:&#160;λ,&#160;π,&#160;→<br/>
36<br/>
<hr/>
<a name=37></a>(*<br/>
Polymorphisme<br/>
*)<br/>
let&#160;id&#160;=&#160;Lam(&#34;A&#34;,&#160;C&#160;&#34;*&#34;,&#160;Lam(&#34;x&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;x&#34;))&#160;;;<br/>
let&#160;id_nat&#160;=&#160;App(id,&#160;C&#160;&#34;nat&#34;)&#160;;;<br/>
let&#160;zero&#160;=&#160;App(id_nat,&#160;C&#160;&#34;O&#34;)&#160;;;<br/>
id&#160;=&#160;λA:*.λx:A.x<br/>
id&#160;nat&#160;=&#160;λA:*.λx:A.x&#160;nat<br/>
print_terme&#160;(typage&#160;id&#160;env0)<br/>
πA:*.A→A<br/>
print_terme&#160;(reduc&#160;id_nat)&#160;;;<br/>
λx:nat.x<br/>
print_terme&#160;zero&#160;;;<br/>
λA:*.λx:A.x&#160;nat&#160;O<br/>
print_terme&#160;zero&#160;;;<br/>
print_terme&#160;(typage&#160;zero&#160;env0)&#160;;;<br/>
nat<br/>
print_terme&#160;(fullReduc&#160;zero)&#160;;;<br/>
O<br/>
(*&#160;Les&#160;entiers&#160;*)<br/>
let&#160;entiers&#160;=&#160;Prod&#160;(&#34;X&#34;,&#160;C&#160;&#34;*&#34;,<br/>
Prod&#160;(&#34;x&#34;,&#160;V&#160;&#34;X&#34;,&#160;Prod&#160;(&#34;y&#34;,&#160;Prod&#160;(&#34;z&#34;,&#160;V&#160;&#34;X&#34;,&#160;V&#160;&#34;X&#34;),&#160;V&#160;&#34;X&#34;)))<br/>
utop&#160;#&#160;print_terme&#160;entiers;;<br/>
πX:*.(X→((X→X)→X))<br/>
let&#160;zero&#160;=<br/>
Lam(&#34;X&#34;,&#160;C&#160;&#34;*&#34;,&#160;Lam(&#34;x&#34;,&#160;V&#160;&#34;X&#34;,&#160;Lam&#160;(&#34;y&#34;,&#160;Prod(&#34;z&#34;,&#160;V&#160;&#34;X&#34;,&#160;V&#160;&#34;X&#34;),&#160;V&#160;&#34;x&#34;)))<br/>
let&#160;succ&#160;=&#160;Lam&#160;(&#34;n&#34;,&#160;entiers,&#160;Lam&#160;(&#34;X&#34;,&#160;C&#160;&#34;*&#34;,&#160;Lam&#160;(&#34;x&#34;,&#160;V&#160;&#34;X&#34;,&#160;Lam&#160;(&#34;y&#34;,&#160;Prod(&#34;z&#34;,&#160;V&#160;&#34;X&#34;,&#160;V&#160;&#34;X&#34;),<br/>
App(V&#160;&#34;y&#34;,&#160;App&#160;(App(App(V&#160;&#34;n&#34;,&#160;V&#160;&#34;X&#34;),&#160;V&#160;&#34;x&#34;),&#160;V&#160;&#34;y&#34;)&#160;)))))<br/>
utop&#160;#&#160;print_terme&#160;(fullReduc&#160;trois)&#160;;;<br/>
λX:*.λx:X.λy:(X→X).y&#160;(y&#160;(y&#160;x)&#160;)<br/>
(*twice*)<br/>
utop&#160;#&#160;print_terme&#160;twice&#160;;;<br/>
λA:*.λf:(A→A).λa:A.f&#160;(f&#160;a)<br/>
utop&#160;#&#160;print_terme&#160;(typage&#160;twice&#160;env0)&#160;;;<br/>
πA:*.((A→A)→(A→A))<br/>
let&#160;plus2<br/>
=&#160;App(App(twice,&#160;entiers),&#160;succ)&#160;;;<br/>
print_terme&#160;(fullReduc&#160;(App(plus2,&#160;trois)))&#160;;<br/>
37<br/>
<hr/>
<a name=38></a>λX:*.λx:X.λy:(X→X).y&#160;(y&#160;(y&#160;(y&#160;(y&#160;x)&#160;)&#160;)&#160;)<br/>
Le&#160;type&#160;produit&#160;pourra&#160;être&#160;défini&#160;de&#160;la&#160;manière&#160;suivante&#160;:<br/>
Si&#160;<i>U&#160;</i>et&#160;<i>V&#160;</i>sont&#160;des&#160;types,&#160;alors<br/>
<i>U&#160;</i>×&#160;<i>V&#160;</i>=&#160;Π<i>X.</i>(<i>U&#160;</i>→&#160;<i>V&#160;</i>→&#160;<i>X</i>)&#160;→&#160;<i>X</i><br/>
<i>&lt;&#160;u,&#160;v&#160;&gt;</i>=&#160;<i>λX&#160;</i>:&#160;∗<i>.λx&#160;</i>:&#160;(<i>U&#160;</i>→&#160;<i>V&#160;</i>→&#160;<i>X</i>)<i>.xuv</i><br/>
Prenons&#160;par&#160;exemple&#160;le&#160;couple&#160;d’entiers&#160;<i>&lt;&#160;</i>100<i>,&#160;</i>101&#160;<i>&gt;</i>,&#160;nous&#160;le&#160;modélisons&#160;par<br/>
let&#160;prod_100_101&#160;=<br/>
Lam(&#34;X&#34;,&#160;C&#160;&#34;nat&#34;,<br/>
Lam(&#34;x&#34;,&#160;Prod(&#34;z&#34;,&#160;C&#160;&#34;nat&#34;,<br/>
:w<br/>
(Prod&#160;(&#34;w&#34;,&#160;C&#160;&#34;nat&#34;,&#160;V&#160;&#34;X&#34;&#160;))),App&#160;(App&#160;(V&#160;&#34;x&#34;,&#160;N&#160;100),&#160;N&#160;101)))&#160;;;<br/>
print&#160;(typage&#160;prod_100_101&#160;env0)&#160;;;<br/>
πX:nat.((nat→(nat→X))→X)<br/>
Les&#160;projections&#160;sont&#160;définies&#160;par<br/>
<i>π</i>1<i>t&#160;</i>=&#160;<i>t&#160;U&#160;</i>(<i>λx&#160;</i>:&#160;<i>U.λy&#160;</i>:&#160;<i>V.x</i>)&#160;et&#160;<i>π</i>2<i>t&#160;</i>=&#160;<i>t&#160;U&#160;</i>(<i>λx&#160;</i>:&#160;<i>U.λy&#160;</i>:&#160;<i>V.y</i>)<br/>
let&#160;proj1&#160;=<br/>
Lam(&#34;t&#34;,&#160;(typage&#160;prod_uv&#160;env0),<br/>
App(App(V&#160;&#34;t&#34;,&#160;V&#160;&#34;U&#34;),&#160;Lam&#160;(&#34;x&#34;,&#160;V&#160;&#34;U&#34;,&#160;Lam&#160;(&#34;y&#34;,&#160;V&#160;&#34;V&#34;,&#160;V&#160;&#34;x&#34;))))<br/>
in&#160;print&#160;(fullReduc&#160;(App&#160;(proj1,&#160;prod_100_101)))<br/>
let&#160;proj2&#160;=<br/>
Lam(&#34;t&#34;,&#160;(typage&#160;prod_uv&#160;env0),<br/>
App(App(V&#160;&#34;t&#34;,&#160;V&#160;&#34;U&#34;),&#160;Lam&#160;(&#34;x&#34;,&#160;V&#160;&#34;U&#34;,&#160;Lam&#160;(&#34;y&#34;,&#160;V&#160;&#34;V&#34;,&#160;V&#160;&#34;y&#34;))))<br/>
in&#160;print&#160;(fullReduc&#160;(App&#160;(proj2,&#160;prod_uv)))<br/>
<b>2.2.2</b><br/>
<b>MiniCOQ</b><br/>
Nous&#160;nous&#160;éloignons&#160;de&#160;la&#160;simplicité&#160;du&#160;<i>Pure&#160;Type&#160;System&#160;</i>en&#160;surchargeant&#160;notre&#160;terme&#160;algé-<br/>
brique&#160;des&#160;types&#160;suivants&#160;:<br/>
—&#160;Le&#160;type&#160;Nat&#160;avec&#160;ses&#160;constructeurs&#160;0&#160;et&#160;S<br/>—&#160;Le&#160;type&#160;de&#160;l’égalité&#160;Eq&#160;avec&#160;son&#160;unique&#160;constructeur&#160;Eq_refl<br/>—&#160;Le&#160;type&#160;And&#160;avec&#160;son&#160;unique&#160;constructeur&#160;Conj&#160;et&#160;ses&#160;fonctions&#160;Proj1&#160;et&#160;Proj2.&#160;L’affichage<br/>
du&#160;type&#160;And&#160;se&#160;fera&#160;avec&#160;les&#160;caractères&#160;/\<br/>
—&#160;Le&#160;type&#160;Or&#160;avec&#160;ses&#160;constructeurs&#160;Or_introl&#160;et&#160;Or_intror&#160;et&#160;sa&#160;fonction&#160;Case.&#160;L’affichage<br/>
de&#160;ce&#160;type&#160;se&#160;fera&#160;avec&#160;les&#160;caractères&#160;\/<br/>
—&#160;Le&#160;type&#160;False&#160;sans&#160;constructeur,&#160;mais&#160;avec&#160;la&#160;fonction&#160;False_ind(t1,t2)&#160;qui&#160;se&#160;réduit&#160;en<br/>
t1&#160;si&#160;le&#160;type&#160;de&#160;t2&#160;est&#160;égal&#160;à&#160;False&#160;(<i>ex&#160;falso&#160;quodlibet</i>)<br/>
Démontrons&#160;le&#160;théorème&#160;simple&#160;décrit&#160;en&#160;COQ&#160;comme&#160;ci-dessous.<br/>
Theorem&#160;<i>imp&#160;</i>:&#160;∀&#160;(<i>a&#160;b&#160;c&#160;</i>:&#160;Prop),&#160;((<i>a</i>→<i>b</i>)&#160;∧&#160;(<i>a</i>→<i>c</i>))&#160;→&#160;<i>a</i>→&#160;(<i>b</i>∧<i>c</i>).<br/>
Proof.<br/>
38<br/>
<hr/>
<a name=39></a>intros&#160;<i>a&#160;b&#160;c&#160;H</i>.<br/>
intro&#160;<i>Ha</i>.<br/>
split.<br/>
destruct&#160;<i>H&#160;</i>as&#160;(<i>H1&#160;</i>&amp;&#160;<i>H2&#160;</i>).<br/>
apply&#160;<i>H1</i>.&#160;assumption.<br/>
destruct&#160;<i>H&#160;</i>as&#160;(<i>H1&#160;</i>&amp;&#160;<i>H2&#160;</i>).<br/>
apply&#160;<i>H2</i>.&#160;assumption.<br/>
Qed.<br/>
Nous&#160;pouvons&#160;représenter&#160;la&#160;preuve&#160;du&#160;théorème&#160;avec&#160;la&#160;dérivation&#160;suivante&#160;:<br/>
[(<i>A&#160;</i>⇒&#160;<i>B</i>)&#160;∧&#160;(<i>A&#160;</i>⇒&#160;<i>C</i>)]<br/>
[(<i>A&#160;</i>⇒&#160;<i>B</i>)&#160;∧&#160;(<i>A&#160;</i>⇒&#160;<i>C</i>)]<br/>
<i>destruct&#160;H&#160;as&#160;</i>(<i>H</i>1<i>,&#160;H</i>2)<br/>
<i>destruct&#160;H&#160;as&#160;</i>(<i>H</i>1<i>,&#160;H</i>2)<br/>
<i>A&#160;</i>⇒&#160;<i>B</i><br/>
[<i>A</i>]<br/>
<i>A&#160;</i>⇒&#160;<i>C</i><br/>
[<i>A</i>]<br/>
<i>apply&#160;H</i>1<br/>
<i>apply&#160;H</i>2<br/>
<i>B</i><br/>
<i>C&#160;split</i><br/>
<i>B&#160;</i>∧&#160;<i>C</i><br/>
<i>intros&#160;Ha</i><br/>
<i>A&#160;</i>⇒&#160;(<i>B&#160;</i>∧&#160;<i>C</i>)<br/>
<i>intros&#160;a&#160;b&#160;c&#160;H</i><br/>
((<i>A&#160;</i>⇒&#160;<i>B</i>)&#160;∧&#160;(<i>A&#160;</i>⇒&#160;<i>C</i>))&#160;⇒&#160;(<i>A&#160;</i>⇒&#160;(<i>B&#160;</i>∧&#160;<i>C</i>))<br/>
Avec&#160;notre&#160;système&#160;PTS,&#160;nous&#160;codons&#160;cela&#160;de&#160;la&#160;manière&#160;suivante&#160;:<br/>
let&#160;imp&#160;=&#160;Prod(&#34;A&#34;,&#160;C&#160;&#34;Type&#34;,&#160;Prod&#160;(&#34;B&#34;,&#160;C&#160;&#34;Type&#34;,&#160;Prod&#160;(&#34;C&#34;,&#160;C&#160;&#34;Type&#34;,<br/>
Prod&#160;(&#34;z&#34;,&#160;And(Prod(&#34;x&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;B&#34;),&#160;Prod&#160;(&#34;y&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;C&#34;)),<br/>
Prod&#160;(&#34;w&#34;,&#160;V&#160;&#34;A&#34;,&#160;And&#160;(V&#160;&#34;B&#34;,&#160;V&#160;&#34;C&#34;))))))<br/>
in&#160;print&#160;imp&#160;;;<br/>
&gt;&#160;πA:Type.πB:Type.π:Type.((A→B)/\(A→C)→(A→B/\C))<br/>
let&#160;preuve_imp_pts&#160;=<br/>
Lam(&#34;A&#34;,&#160;Type,<br/>
Lam(&#34;B&#34;,&#160;Type,<br/>
Lam(&#34;C&#34;,&#160;Type,<br/>
Lam(&#34;h&#34;,&#160;And(Prod(&#34;x&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;B&#34;),&#160;Prod(&#34;y&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;C&#34;)),<br/>
Lam&#160;(&#34;x&#34;,&#160;V&#160;&#34;A&#34;,&#160;Conj&#160;(App(Proj1&#160;(V&#160;&#34;h&#34;),&#160;V&#160;&#34;x&#34;),&#160;App(Proj2&#160;(V&#160;&#34;h&#34;),&#160;V&#160;&#34;x&#34;)))))))<br/>
in&#160;(print&#160;preuve_imp_pts;&#160;print_string&#160;&#34;\n&#34;;&#160;print&#160;(check&#160;preuve_imp_pts&#160;env0))<br/>
;;<br/>
&gt;&#160;λA:Type.λB:Type.λC:Type.λh:(A→B)/\(A→C).λx:A.conj((proj1(h)&#160;x),(proj2(h)&#160;x))<br/>
πA:Type.πB:Type.πC:Type.((A→B)/\(A→C)→(A→B/\C))<br/>
Nous&#160;retrouvons&#160;en&#160;OCAML&#160;la&#160;dualité&#160;entre&#160;le&#160;type&#160;produit&#160;*&#160;et&#160;le&#160;∧&#160;logique,&#160;ainsi&#160;qu’entre&#160;la<br/>flèche&#160;fonctionnelle&#160;-&gt;&#160;et&#160;l’implication&#160;logique&#160;⇒.&#160;OCAML&#160;infère&#160;correctement&#160;le&#160;type&#160;(théorème)<br/>depuis&#160;le&#160;terme&#160;(la&#160;preuve).<br/>
let&#160;preuve_imp_ocaml&#160;=&#160;function&#160;h&#160;-&gt;&#160;(function&#160;x&#160;-&gt;&#160;((fst&#160;h)&#160;x,&#160;(snd&#160;h)&#160;x))&#160;;;<br/>
val&#160;preuve_imp_ocaml&#160;:&#160;(’a&#160;-&gt;&#160;’b)&#160;*&#160;(’a&#160;-&gt;&#160;’c)&#160;-&gt;&#160;’a&#160;-&gt;&#160;’b&#160;*&#160;’c<br/>
Voici&#160;un&#160;autre&#160;exemple&#160;très&#160;simple&#160;illustrant&#160;le&#160;type&#160;∧&#160;et&#160;les&#160;fonctions&#160;de&#160;construction&#160;And&#160;et<br/>
de&#160;projections&#160;Proj1/2<br/>Theorem&#160;<i>et&#160;refl&#160;</i>:&#160;∀&#160;(<i>a&#160;b&#160;</i>:Prop),&#160;<i>a</i>∧<i>b&#160;</i>→&#160;<i>b</i>∧<i>a&#160;</i>.<br/>
Proof.<br/>
intros&#160;<i>a&#160;b&#160;H</i>.<br/>
split.<br/>
39<br/>
<hr/>
<a name=40></a>destruct&#160;<i>H&#160;</i>as&#160;[<i>Ha&#160;Hb</i>].<br/>
assumption.<br/>
destruct&#160;<i>H&#160;</i>as&#160;[<i>Ha&#160;Hb</i>].<br/>
assumption.<br/>
Qed.<br/>
Print&#160;<i>et&#160;refl</i>.<br/>
let&#160;preuve_et_refl&#160;=<br/>
Lam(&#34;A&#34;,&#160;Type,<br/>
Lam(&#34;B&#34;,&#160;Type,<br/>
Lam(&#34;h&#34;,&#160;And(V&#160;&#34;A&#34;,&#160;V&#160;&#34;B&#34;),&#160;Conj(Proj2&#160;(V&#160;&#34;h&#34;),&#160;Proj1&#160;(V&#160;&#34;h&#34;)))))<br/>
in&#160;(&#160;print&#160;preuve_et_refl&#160;;&#160;print_string&#160;&#34;\n&#34;;&#160;print(check&#160;preuve_et_refl&#160;env0))&#160;;;<br/>
&gt;&#160;λA:Type.λB:Type.λh:A/\B.conj(proj2(h)&#160;,proj1(h))<br/>
πA:Type.πB:Type.(A/\B→B/\A)<br/>
Ou&#160;tout&#160;simplement&#160;en&#160;OCAML&#160;avec&#160;l’inférence&#160;de&#160;type&#160;:<br/>
utop&#160;#&#160;let&#160;preuve_et_refl&#160;=&#160;function&#160;h&#160;-&gt;&#160;(snd&#160;h,&#160;fst&#160;h)&#160;;;<br/>
val&#160;preuve_et_refl&#160;:&#160;’a&#160;*&#160;’b&#160;-&gt;&#160;’b&#160;*&#160;’a&#160;=&#160;&lt;fun&gt;<br/>
<b>2.2.3</b><br/>
<b>Le&#160;</b>∨&#160;<b>logique</b><br/>
Theorem&#160;<i>or&#160;elim&#160;</i>:&#160;∀&#160;(<i>a&#160;b&#160;c&#160;</i>:Prop),&#160;(<i>a</i>→<i>c</i>)-&gt;(<i>b</i>→<i>c</i>)-&gt;(<i>a</i>∨<i>b</i>)-&gt;<i>c</i>.<br/>
Proof.<br/>
intros&#160;<i>a&#160;b&#160;c&#160;h1&#160;h2&#160;h3</i>.<br/>
destruct&#160;<i>h3&#160;</i>as&#160;[<i>ha&#160;</i>|&#160;<i>hb</i>].<br/>
apply&#160;<i>h1</i>.&#160;exact&#160;<i>ha</i>.<br/>
apply&#160;<i>h2</i>.&#160;exact&#160;<i>hb</i>.<br/>
Qed.<br/>
(*&#160;fonction&#160;générée&#160;en&#160;COQ&#160;*)<br/>
or_elim&#160;=<br/>
fun&#160;(a&#160;b&#160;c&#160;:&#160;Prop)&#160;(h1&#160;:&#160;a&#160;-&gt;&#160;c)&#160;(h2&#160;:&#160;b&#160;-&gt;&#160;c)&#160;(h3&#160;:&#160;a&#160;\/&#160;b)&#160;=&gt;<br/>
match&#160;h3&#160;with<br/>
|&#160;or_introl&#160;ha&#160;=&gt;&#160;h1&#160;ha<br/>
|&#160;or_intror&#160;hb&#160;=&gt;&#160;h2&#160;hb<br/>
end<br/>
:&#160;forall&#160;a&#160;b&#160;c&#160;:&#160;Prop,&#160;(a&#160;-&gt;&#160;c)&#160;-&gt;&#160;(b&#160;-&gt;&#160;c)&#160;-&gt;&#160;a&#160;\/&#160;b&#160;-&gt;&#160;c<br/>
(*&#160;fonction&#160;OCAML&#160;*)<br/>
let&#160;preuve_or_elim&#160;=<br/>
Lam(&#34;A&#34;,&#160;Type,<br/>
Lam(&#34;B&#34;,&#160;Type,<br/>
Lam&#160;(&#34;C&#34;,&#160;Type,<br/>
Lam(&#34;h1&#34;,&#160;Prod(&#34;x&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;C&#34;),<br/>
Lam(&#34;h2&#34;,&#160;Prod(&#34;y&#34;,&#160;V&#160;&#34;B&#34;,&#160;V&#160;&#34;C&#34;),<br/>
Lam(&#34;h3&#34;,&#160;Or(V&#160;&#34;A&#34;,&#160;V&#160;&#34;B&#34;),<br/>
40<br/>
<hr/>
<a name=41></a>Case(V&#160;&#34;h3&#34;,&#160;V&#160;&#34;h1&#34;,&#160;V&#160;&#34;h2&#34;)))))))<br/>
in&#160;(print&#160;preuve_or_elim&#160;;&#160;print_newline()&#160;;<br/>
print&#160;(check&#160;preuve_or_elim&#160;env0))&#160;;;<br/>
&gt;&#160;λA:Type.λB:Type.λC:Type.λh1:(A→C).λh2:(B→C).λh3:A\/B.case(h3,&#160;h1,&#160;h2)<br/>
πA:Type.πB:Type.πC:Type.((A→C)→((B→C)→(A\/B→C)))<br/>
En&#160;OCAML,&#160;nous&#160;introduisons&#160;le&#160;type&#160;algébrique&#160;ci-dessous&#160;pour&#160;matérialiser&#160;le&#160;or&#160;logique<br/>
type&#160;(’a,&#160;’b)&#160;ou&#160;=&#160;Left&#160;of&#160;’a&#160;|&#160;Right&#160;of&#160;’b<br/>
let&#160;or_elim&#160;=&#160;fun&#160;h1&#160;h2&#160;h3&#160;-&gt;<br/>
match&#160;h3&#160;with<br/>
|&#160;Left&#160;a&#160;-&gt;&#160;h1&#160;a<br/>
|&#160;Right&#160;b&#160;-&gt;&#160;h2&#160;b&#160;;;<br/>
val&#160;or_elim&#160;:&#160;(’a&#160;-&gt;&#160;’b)&#160;-&gt;&#160;(’c&#160;-&gt;&#160;’b)&#160;-&gt;&#160;(’a,&#160;’c)&#160;ou&#160;-&gt;&#160;’b&#160;=&#160;&lt;fun&gt;<br/>
<b>2.2.4</b><br/>
<b>L’égalité</b><br/>
Prouvons&#160;que&#160;∀<i>n&#160;</i>∈&#160;Nat<i>,&#160;</i>(<i>λn.</i>2&#160;<i>n</i>)&#160;=&#160;2<br/>
let&#160;th&#160;=&#160;Prod(&#34;n&#34;,&#160;Nat,&#160;Eq(Nat,&#160;App(cst2,&#160;V&#160;&#34;n&#34;),&#160;S&#160;(S&#160;O)&#160;))<br/>
in&#160;print&#160;th;;<br/>
&gt;&#160;πn:nat.eq(nat,&#160;(λn:nat.2&#160;n),&#160;2)<br/>
let&#160;proof&#160;=&#160;Lam(&#34;n&#34;,&#160;Nat,&#160;Eq_refl(Nat,&#160;App(cst2,&#160;V&#160;&#34;n&#34;)))&#160;in<br/>
(print&#160;proof&#160;;&#160;print_newline()&#160;;<br/>
print&#160;(check&#160;proof&#160;env0)&#160;;&#160;print_newline()&#160;;<br/>
print&#160;(fullReduc&#160;(check&#160;proof&#160;env0)))<br/>
;;<br/>
&gt;&#160;λn:nat.eq&#160;_refl(nat,&#160;(λn:nat.2&#160;n))<br/>
πn:nat.eq(nat,&#160;(λn:nat.2&#160;n),&#160;(λn:nat.2&#160;n))<br/>
(nat→eq(nat,&#160;2,&#160;2))<br/>
Rappelons&#160;la&#160;règle&#160;de&#160;conversion&#160;ci-dessous&#160;:<br/>
Γ&#160;`&#160;<i>t&#160;</i>:&#160;<i>A</i><br/>
Γ&#160;`&#160;<i>B&#160;</i>:&#160;<i>s</i><br/>
<i>A&#160;</i>=<i>β&#160;B</i><br/>
Γ&#160;`&#160;<i>t&#160;</i>:&#160;<i>B</i><br/>
Ainsi,&#160;un&#160;terme&#160;peut&#160;avoir&#160;plusieurs&#160;types.<br/>
La&#160;preuve&#160;λn:nat.eq&#160;_refl(nat,&#160;(λn:nat.2&#160;n))&#160;est&#160;preuve&#160;de&#160;:<br/>
—&#160;πn:nat.eq(nat,&#160;(λn:nat.2&#160;n),&#160;(λn:nat.2&#160;n))<br/>—&#160;πn:nat.eq(nat,&#160;(λn:nat.2&#160;n),&#160;2)<br/>—&#160;(nat→eq(nat,&#160;2,&#160;2))<br/>
Nous&#160;constatons&#160;que&#160;la&#160;preuve&#160;n’exhibe&#160;pas&#160;le&#160;process&#160;calculatoire&#160;de&#160;la&#160;<i>β</i>-réduction.&#160;Le&#160;théorème<br/>est&#160;ici&#160;prouvé&#160;par&#160;calcul&#160;et&#160;non&#160;par&#160;raisonnement.&#160;Ces&#160;considérations&#160;philosophiques&#160;sont&#160;bien<br/>développées&#160;par&#160;Henri&#160;P<a href="documents.html#127">oincaré[15]</a><br/>
41<br/>
<hr/>
<a name=42></a><b>2.2.5</b><br/>
<b>Le&#160;faux</b><br/>
let&#160;exf&#160;=&#160;Lam&#160;(&#34;x&#34;,&#160;False,&#160;I)&#160;(*&#160;ex&#160;falso&#160;quodlibet&#160;*)<br/>
in&#160;(print&#160;exf&#160;;&#160;print_newline()&#160;;&#160;print&#160;(check&#160;exf&#160;env0))&#160;;;<br/>
&gt;&#160;λx:False.I<br/>
(False→True)<br/>
Voici&#160;un&#160;exemple&#160;simple&#160;manipulant&#160;la&#160;négation&#160;et&#160;la&#160;fonction&#160;d’induction&#160;du&#160;faux.<br/>
Theorem&#160;<i>implication&#160;</i>:&#160;∀&#160;(<i>A&#160;B&#160;</i>:Prop),&#160;¬<i>A</i>∨<i>B&#160;</i>→&#160;(<i>A</i>→<i>B</i>)&#160;.<br/>
Proof.<br/>
intros.<br/>
destruct&#160;<i>H&#160;</i>as&#160;[<i>H1&#160;</i>|<i>H2&#160;</i>].<br/><i>contradiction</i>.<br/>
assumption.<br/>
Qed.<br/>
Print&#160;<i>implication</i>.<br/>
implication&#160;=<br/>
fun&#160;(A&#160;B&#160;:&#160;Prop)&#160;(H&#160;:&#160;~&#160;A&#160;\/&#160;B)&#160;(H0&#160;:&#160;A)&#160;=&gt;<br/>
match&#160;H&#160;with<br/>
|&#160;or_introl&#160;H1&#160;=&gt;&#160;False_ind&#160;B&#160;(H1&#160;H0)<br/>
|&#160;or_intror&#160;H2&#160;=&gt;&#160;H2<br/>
end<br/>
:&#160;forall&#160;A&#160;B&#160;:&#160;Prop,&#160;~&#160;A&#160;\/&#160;B&#160;-&gt;&#160;A&#160;-&gt;&#160;B<br/>
Avec&#160;notre&#160;implémentation&#160;OCAML,&#160;cela&#160;donne&#160;:<br/>
let&#160;preuve_impl&#160;=<br/>
Lam(&#34;A&#34;,&#160;Type,<br/>
Lam(&#34;B&#34;,&#160;Type,<br/>
Lam(&#34;H&#34;,&#160;Or(App(non,&#160;V&#160;&#34;A&#34;),&#160;V&#160;&#34;B&#34;),<br/>
Lam(&#34;H0&#34;,&#160;V&#160;&#34;A&#34;,<br/>
Case&#160;(V&#160;&#34;H&#34;,<br/>
Lam(&#34;x&#34;,&#160;Prod(&#34;w&#34;,&#160;V&#160;&#34;A&#34;,&#160;False),&#160;False_ind(V&#160;&#34;B&#34;,&#160;App(V&#160;&#34;x&#34;,&#160;V&#160;&#34;H0&#34;))),<br/>
Lam&#160;(&#34;y&#34;,&#160;V&#160;&#34;B&#34;,&#160;V&#160;&#34;y&#34;))))))<br/>
in<br/>
(print&#160;preuve_impl&#160;;&#160;print_newline()&#160;;<br/>
print&#160;(fullReduc&#160;(check&#160;preuve_impl&#160;env0)))&#160;;;<br/>
&gt;&#160;λA:Type.λB:Type.λH:(λP:Type.~P&#160;A)\/B.λH0:A.case(H,&#160;λx:~A.false_ind(B,(x&#160;H0)),&#160;λy:B.y)<br/>
πA:Type.πB:Type.(~A\/B→(A→B))<br/>
Dans&#160;un&#160;langage&#160;comme&#160;OCAML,&#160;le&#160;type&#160;faux&#160;est&#160;un&#160;type&#160;sans&#160;constructeur.&#160;Il&#160;est&#160;<i>inhabité</i>.<br/>
La&#160;preuve&#160;de&#160;la&#160;règle&#160;du&#160;modus&#160;tollens&#160;s’écrira&#160;de&#160;la&#160;manière&#160;suivante&#160;:<br/>
type&#160;faux&#160;=&#160;|&#160;;;<br/>
let&#160;modus_tollens&#160;(hfq:’q-&gt;faux)&#160;(hpq:’p-&gt;’q)&#160;(hp:’p)&#160;=<br/>
hfq&#160;(hpq&#160;hp)<br/>
42<br/>
<hr/>
<a name=43></a>Voici&#160;le&#160;même&#160;théorème&#160;en&#160;COQ&#160;:<br/>
Theorem&#160;modus_tollens:&#160;forall&#160;(p&#160;q:Prop),&#160;(q-&gt;False)-&gt;&#160;(p-&gt;q)&#160;-&gt;&#160;(p-&gt;False).<br/>
Proof.<br/>
intros&#160;p&#160;q&#160;Hfq&#160;Hpq&#160;Hp.<br/>
generalize&#160;(Hpq&#160;Hp).<br/>
exact&#160;Hfq.<br/>
Qed.<br/>
Nous&#160;pouvons&#160;décrire&#160;le&#160;<i>ex&#160;falso&#160;quodlibet&#160;</i>en&#160;OCAML&#160;comme&#160;suit&#160;:<br/>
type&#160;faux&#160;=&#160;|&#160;;;<br/>
type&#160;vrai&#160;=&#160;I&#160;;;<br/>
let&#160;exfalsoquodlibet&#160;=&#160;fun&#160;(f:faux)&#160;-&gt;<br/>
I;;<br/>
<b>2.2.6</b><br/>
<b>Le&#160;point&#160;fixe</b><br/>
DNoussurchargeonsnotretermealgébriquedel’opérateurdepointfixeYoftermequiseréduit<br/>
en&#160;Y&#160;t<br/>
t&#160;(Y&#160;t)<br/>
let&#160;multF&#160;=<br/>
Lam&#160;(&#34;f&#34;,&#160;Prod(&#34;w&#34;,Nat,&#160;Nat),<br/>
Lam&#160;(&#34;n&#34;,&#160;Nat,&#160;Lam&#160;(&#34;m&#34;,&#160;Nat,<br/>
IfThenElse(Egal(V&#160;&#34;n&#34;,O),&#160;O,&#160;Add&#160;(V&#160;&#34;m&#34;,&#160;App(App&#160;(V&#160;&#34;f&#34;,&#160;Sub1&#160;(V&#160;&#34;n&#34;)),&#160;V&#160;&#34;m&#34;))))))<br/>
let&#160;mult&#160;=&#160;Y&#160;multF&#160;;;<br/>
let&#160;facF&#160;=&#160;Lam(&#34;f&#34;,&#160;Prod&#160;(&#34;z&#34;,&#160;Nat,&#160;Nat),<br/>
Lam&#160;(&#34;n&#34;,&#160;Nat,<br/>
IfThenElse(Egal(V&#160;&#34;n&#34;,&#160;O),&#160;S&#160;O,&#160;(App(App(mult,&#160;V&#160;&#34;n&#34;),&#160;App(V&#160;&#34;f&#34;,&#160;Sub1&#160;(V&#160;&#34;n&#34;))&#160;)&#160;))))&#160;;;<br/>
let&#160;fac&#160;=&#160;Y&#160;facF<br/>
;;<br/>
print&#160;(fullReduc&#160;(App(fac,&#160;S&#160;(S&#160;(S&#160;(S&#160;(S&#160;O)))))))&#160;;;<br/>
&gt;&#160;120<br/>
<b>2.2.7</b><br/>
<b>La&#160;logique&#160;classique</b><br/>
Sous&#160;l’angle&#160;de&#160;la&#160;correspondance&#160;de&#160;Curry-Howard,&#160;notre&#160;système&#160;se&#160;base&#160;sur&#160;la&#160;logique&#160;in-<br/>
tuitionniste.&#160;C’est-à-dire&#160;que&#160;toute&#160;proposition&#160;a&#160;une&#160;preuve&#160;constructive.&#160;Autrement&#160;dit,&#160;le&#160;type<br/>correspondant&#160;à&#160;la&#160;proposition&#160;est&#160;habité&#160;par&#160;un&#160;terme&#160;de&#160;notre&#160;système&#160;PTS.&#160;Avec&#160;cette&#160;logique<br/>nous&#160;ne&#160;pouvons&#160;prouver&#160;certains&#160;théorèmes&#160;comme&#160;la&#160;loi&#160;de&#160;Peirce&#160;((<i>A&#160;</i>→&#160;<i>B</i>)&#160;→&#160;<i>A</i>)&#160;→&#160;<i>A</i><br/>
Pour&#160;cela&#160;nous&#160;devons&#160;ajouter&#160;l’axiome&#160;du&#160;tiers-exclus&#160;<i>A&#160;</i>∨&#160;¬<i>A</i>.&#160;Voici&#160;comment&#160;la&#160;loi&#160;de&#160;Pierce<br/>
se&#160;déduit&#160;avec&#160;l’axiome&#160;du&#160;tiers-exclus.&#160;En&#160;COQ,&#160;cela&#160;donne&#160;:<br/>
Axiom&#160;<i>classic&#160;</i>:&#160;∀&#160;<i>P&#160;</i>:&#160;Prop,&#160;<i>P</i>\/˜<i>P</i>.<br/>
Theorem&#160;<i>Peirce&#160;</i>:&#160;∀&#160;<i>A&#160;B&#160;</i>:Prop,&#160;((<i>A</i>→<i>B</i>)-&gt;<i>A</i>)-&gt;<i>A</i>.<br/>
Proof.<br/>
43<br/>
<hr/>
<a name=44></a>intros.<br/>
assert&#160;(<i>A</i>\/˜<i>A</i>)&#160;by&#160;(apply&#160;<i>classic&#160;</i>).<br/>
destruct&#160;<i>H0&#160;</i>as&#160;[<i>H1&#160;</i>|&#160;<i>H2&#160;</i>].<br/>
exact&#160;<i>H1</i>.<br/>
apply&#160;<i>H&#160;</i>.<br/>
intros.<br/><i>contradiction</i>.<br/>
Qed.<br/>
Print&#160;<i>Peirce</i>.<br/>
Peirce&#160;=<br/>
fun&#160;(A&#160;B&#160;:&#160;Prop)&#160;(H&#160;:&#160;(A&#160;-&gt;&#160;B)&#160;-&gt;&#160;A)&#160;=&gt;<br/>
let&#160;H0&#160;:&#160;A&#160;\/&#160;~&#160;A&#160;:=&#160;classic&#160;A&#160;in<br/>
match&#160;H0&#160;with<br/>
|&#160;or_introl&#160;H1&#160;=&gt;&#160;H1<br/>
|&#160;or_intror&#160;H2&#160;=&gt;&#160;H&#160;(fun&#160;H1&#160;:&#160;A&#160;=&gt;&#160;False_ind&#160;B&#160;(H2&#160;H1))<br/>
end<br/>
:&#160;forall&#160;A&#160;B&#160;:&#160;Prop,&#160;((A&#160;-&gt;&#160;B)&#160;-&gt;&#160;A)&#160;-&gt;&#160;A<br/>
Voici&#160;notre&#160;implémentation&#160;dans&#160;notre&#160;miniCOQ.&#160;Nous&#160;créons&#160;un&#160;environnement&#160;env_classic<br/>
surchargé&#160;par&#160;le&#160;terme&#160;tiers-exclus&#160;de&#160;type&#160;<i>A&#160;</i>∨&#160;¬<i>A</i>.&#160;Nous&#160;trichons&#160;un&#160;peu&#160;car&#160;le&#160;type&#160;devrait&#160;être<br/>polymorphe&#160;et&#160;donc&#160;de&#160;la&#160;forme&#160;∀<i>P&#160;</i>:&#160;Type<i>,&#160;P&#160;</i>∨&#160;¬<i>P&#160;</i>,&#160;mais&#160;je&#160;ne&#160;vois&#160;pas&#160;comment&#160;ensuite&#160;appliquer<br/>cet&#160;axiome&#160;à&#160;une&#160;variable&#160;A.&#160;Comment&#160;COQ&#160;gère&#160;let&#160;H0&#160;:&#160;A&#160;\/&#160;~&#160;A&#160;:=&#160;classic&#160;A&#160;?<br/>
let&#160;env_classic&#160;=&#160;[(&#34;tiers-exclus&#34;,<br/>
Or(V&#160;&#34;A&#34;,&#160;App(non,&#160;V&#160;&#34;A&#34;)))]&#160;;;<br/>
let&#160;proof_peirce&#160;=<br/>
Lam(&#34;A&#34;,&#160;Type,<br/>
Lam(&#34;B&#34;,&#160;Type,<br/>
Lam&#160;(&#34;H&#34;,&#160;Prod(&#34;x&#34;,&#160;Prod(&#34;y&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;B&#34;),&#160;V&#160;&#34;A&#34;),<br/>
Case(C&#160;&#34;tiers-exclus&#34;,<br/>
Lam(&#34;zz&#34;,&#160;V&#160;&#34;A&#34;,&#160;V&#160;&#34;zz&#34;),<br/>
Lam(&#34;yy&#34;,&#160;V&#160;&#34;A&#34;,&#160;App(V&#160;&#34;H&#34;,&#160;Lam(&#34;H1&#34;,&#160;V&#160;&#34;A&#34;,&#160;False_ind(V&#160;&#34;B&#34;,&#160;App(V&#160;&#34;yy&#34;,&#160;V&#160;&#34;H1&#34;)))))))))<br/>
in&#160;(print&#160;proof_peirce;&#160;print_newline();<br/>
print&#160;(check&#160;proof_peirce&#160;env_classic))&#160;;;<br/>
&gt;&#160;λA:Type.λB:Type.λH:((A→B)→A).case(tiers-exclus,<br/>
λzz:A.zz,<br/>
λyy:A.(H&#160;λH1:A.false_ind(B,(yy&#160;H1))))<br/>
πA:Type.πB:Type.(((A→B)→A)→A)<br/>
Ainsi,&#160;le&#160;tiers-exclus&#160;n’est&#160;pas&#160;démontrable&#160;en&#160;logique&#160;classique.&#160;Cependant,&#160;on&#160;peut&#160;démontrer<br/>
en&#160;logique&#160;intuitionniste&#160;qu’il&#160;n’est&#160;pas&#160;vrai&#160;que&#160;le&#160;tiers-exclus&#160;soit&#160;faux.&#160;C’est-à-dire&#160;que&#160;l’on&#160;ne<br/>peut&#160;démontrer&#160;<i>P&#160;</i>,&#160;mais&#160;¬&#160;¬<i>P</i><br/>
Il&#160;est&#160;surprenant&#160;de&#160;constater&#160;que&#160;&#34;nier&#160;deux&#160;fois&#34;&#160;est&#160;équivalent&#160;à&#160;&#34;affirmer&#34;&#160;en&#160;logique&#160;classique,<br/>
mais&#160;est&#160;plus&#160;faible&#160;en&#160;logique&#160;intuitionniste.<br/>
Voici&#160;la&#160;démonstration&#160;en&#160;COQ.<br/>
44<br/>
<hr/>
<a name=45></a>Section&#160;<i>excluded&#160;middle</i>.<br/>
Variables&#160;<i>A&#160;</i>:&#160;Prop.<br/>
Theorem&#160;<i>il&#160;n&#160;est&#160;pas&#160;vrai&#160;que&#160;le&#160;tiers&#160;exclus&#160;est&#160;faux&#160;</i>:&#160;¬&#160;¬&#160;(˜<i>A&#160;</i>∨&#160;<i>A</i>).<br/>
Proof.<br/>
unfold&#160;<i>not</i>.<br/>
intro&#160;<i>H</i>.<br/>
apply&#160;<i>H</i>.<br/>
left.<br/>
intro&#160;<i>H1</i>.<br/>
apply&#160;<i>H</i>.<br/>
right.<br/>
assumption.<br/>
Qed.<br/>
End&#160;<i>excluded&#160;middle</i>.<br/>
45<br/>
<hr/>
<a name=46></a>46<br/>
<hr/>
<a name=47></a><b>Chapitre&#160;3</b><br/>
<b>L’interprétation</b><br/>
<b>3.1</b><br/>
<b>Introduction</b><br/>
Nous&#160;avons&#160;vu&#160;que&#160;le&#160;<i>λ</i>-calcul&#160;utilise&#160;la&#160;réduction,&#160;basée&#160;sur&#160;un&#160;mécanisme&#160;de&#160;substitution.&#160;Les<br/>
langages&#160;interprétés&#160;que&#160;nous&#160;allons&#160;implémenter&#160;n’utilisent&#160;pas&#160;ce&#160;mécanisme&#160;de&#160;substitution,&#160;mais<br/>font&#160;appel&#160;un&#160;environnement&#160;qui&#160;permet&#160;de&#160;représenter&#160;les&#160;paires&#160;variable/valeur.&#160;A&#160;l’application<br/>d’une&#160;fonction,&#160;cet&#160;environnement&#160;est&#160;<i>étendu&#160;</i>avec&#160;les&#160;nouvelles&#160;paires&#160;variable/valeur&#160;des&#160;arguments<br/>de&#160;la&#160;fonction.<br/>
D<br/>
Nous&#160;perdons&#160;donc&#160;le&#160;côté&#160;pur&#160;du&#160;<i>λ</i>-calcul&#160;qui&#160;se&#160;suffit&#160;à&#160;lui-même&#160;pour&#160;dérouler&#160;ses&#160;calculs.<br/>
L’interprète&#160;ne&#160;pourra&#160;évaluer&#160;son&#160;expression&#160;qu’en&#160;présence&#160;d’un&#160;environnement.&#160;Un&#160;interprète<br/>est&#160;ainsi&#160;une&#160;fonction&#160;eval&#160;telle&#160;que&#160;(eval&#160;<i>π&#160;</i>env)<br/>
valeur<br/>
Nous&#160;reprenons&#160;ici&#160;un&#160;peu&#160;du&#160;code&#160;de&#160;l’excellent&#160;blog&#160;:&#160;<a href="https://bernsteinbear.com/blog/lisp">https://bernsteinbear.com/blog/</a><br/>
<a href="https://bernsteinbear.com/blog/lisp">lisp.</a><br/>
Par&#160;rapport&#160;au&#160;code&#160;du&#160;blog&#160;cité,&#160;nous&#160;faisons&#160;deux&#160;changements&#160;majeurs.&#160;Le&#160;premier&#160;est<br/>
d’utiliser&#160;à&#160;nouveau&#160;les&#160;outils&#160;d’analyseur&#160;lexical&#160;et&#160;syntaxique&#160;<b>ocamllex&#160;</b>et&#160;<b>ocamlyacc</b>.&#160;Le&#160;second<br/>sera&#160;d’utilisé&#160;des&#160;listes&#160;mutables,&#160;afin&#160;de&#160;pleinement&#160;refléter&#160;toutes&#160;les&#160;capacités&#160;de&#160;Scheme&#160;qui&#160;n’est<br/>pas&#160;un&#160;langage&#160;fonctionnel&#160;<i>pur</i>.<br/>
Une&#160;fois&#160;cet&#160;interprète&#160;réalisé,&#160;nous&#160;l’utiliserons&#160;pour&#160;implémenter&#160;un&#160;nouvel&#160;interprète&#160;avec<br/>
quelques&#160;variantes&#160;:&#160;liaison&#160;<i>dynamique&#160;</i>et&#160;<i>statique</i>,&#160;évaluation&#160;<i>stricte&#160;</i>et&#160;<i>paresseuse&#160;</i>et&#160;enfin&#160;un<br/>interprète&#160;par&#160;<i>continuation</i>,&#160;avant&#160;de&#160;conclure&#160;sur&#160;une&#160;tour&#160;de&#160;babel&#160;avec&#160;capacité&#160;de&#160;réification&#160;et<br/>réflection&#160;de&#160;notre&#160;méta-interpète.&#160;C’est&#160;comme&#160;une&#160;quête&#160;philosophique.&#160;.&#160;.<br/>
Pour&#160;ces&#160;diffèrentes&#160;variantes,&#160;nous&#160;nous&#160;inspirons&#160;de&#160;notre&#160;bible&#160;sur&#160;le&#160;langage&#160;LISP&#160;:&#160;<i>LISP&#160;In</i><br/>
<i>Small&#160;Pieces&#160;</i>de&#160;Christian&#160;Queinnec.&#160;<a href="documents.html#127">[16]</a><br/>
<b>3.2</b><br/>
<b>Un&#160;interprète&#160;MiniScheme&#160;avec&#160;OCAML</b><br/>
<b>3.2.1</b><br/>
<b>L’évaluation</b><br/>
Le&#160;<i>λ</i>-calcul&#160;repose&#160;sur&#160;un&#160;mécanisme&#160;de&#160;substitution&#160;permettant&#160;de&#160;réduire&#160;les&#160;termes&#160;et&#160;aboutir<br/>
à&#160;une&#160;forme&#160;normale.&#160;En&#160;programmation&#160;fonctionnelle,&#160;au&#160;lieu&#160;de&#160;réduire&#160;un&#160;terme,&#160;on&#160;l’évaluera.<br/>Un&#160;terme&#160;non&#160;fermé&#160;ne&#160;pourra&#160;être&#160;évalué&#160;que&#160;dans&#160;un&#160;environnement&#160;où&#160;ses&#160;variables&#160;libres&#160;ont<br/>une&#160;liaison.&#160;Nous&#160;avons&#160;les&#160;définitions&#160;suivantes&#160;:<br/>
—&#160;Une&#160;<i>liaison&#160;</i>est&#160;un&#160;couple&#160;(<i>x,&#160;v</i>)&#160;où&#160;<i>x&#160;</i>est&#160;une&#160;variable&#160;et&#160;<i>v&#160;</i>est&#160;une&#160;valeur.<br/>
47<br/>
<hr/>
<a name=48></a>—&#160;Un&#160;<i>environnement&#160;</i>est&#160;une&#160;liste&#160;de&#160;liaison<br/>—&#160;Une&#160;<i>fermeture&#160;</i>est&#160;un&#160;couple&#160;(<i>M,&#160;ρ</i>)&#160;où&#160;<i>M&#160;</i>est&#160;un&#160;terme&#160;et&#160;<i>p&#160;</i>un&#160;environnement&#160;comportant<br/>
une&#160;liaison&#160;pour&#160;chaque&#160;variable&#160;libre&#160;de&#160;<i>M&#160;</i>.<br/>
—&#160;Une&#160;<i>valeur&#160;</i>est&#160;une&#160;fermeture&#160;(<i>M,&#160;p</i>)&#160;avec&#160;<i>M&#160;</i>de&#160;forme&#160;normale.<br/>
On&#160;formalise&#160;l’évaluation&#160;par&#160;la&#160;règle&#160;de&#160;jugement&#160;<i>ρ&#160;</i>`&#160;<i>M&#160;</i>→&#160;<i>v</i>.&#160;Elle&#160;exprime&#160;que&#160;dans&#160;l’environne-<br/>ment&#160;<i>ρ</i>,&#160;le&#160;terme&#160;<i>M&#160;</i>a&#160;pour&#160;valeur&#160;<i>v</i>.<br/>
La&#160;règle&#160;d’évaluation&#160;de&#160;l’appel&#160;par&#160;valeur&#160;se&#160;formalise&#160;ainsi&#160;comme&#160;suit&#160;:<br/>
0<br/>
0<br/>
0<br/>
0<br/>
0<br/>
<i>ρ&#160;</i>`&#160;<i>M&#160;</i>→&#160;(<i>λxM&#160;,&#160;ρ&#160;</i>)<br/>
<i>ρ&#160;</i>`&#160;<i>N&#160;</i>→&#160;<i>v</i><br/>
(<i>x,&#160;v</i>);&#160;<i>ρ&#160;</i>`&#160;<i>M&#160;</i>→&#160;<i>v</i><br/>
(<i>Appv</i>)&#160;:<br/>
<i>ρ&#160;</i>`&#160;<i>M&#160;N&#160;</i>→&#160;<i>v</i>0<br/>
0<br/>
0<br/>
L’évaluation&#160;de&#160;<i>M</i><br/>
le&#160;corps&#160;de&#160;la&#160;lambda&#160;se&#160;fait&#160;dans&#160;l’environnement&#160;<i>ρ&#160;</i>augmenté&#160;d’une<br/>
liaison&#160;due&#160;du&#160;passage&#160;de&#160;paramètre.&#160;C’est&#160;la&#160;caractéristique&#160;de&#160;la&#160;liaison&#160;lexicale.&#160;Pour&#160;une&#160;liaison<br/>dynamique,&#160;l’évaluation&#160;du&#160;corps&#160;de&#160;la&#160;lambda&#160;se&#160;fera&#160;dans&#160;l’environnement&#160;courant&#160;<i>ρ</i><br/>
Dans&#160;le&#160;cadre&#160;d’une&#160;implémentation&#160;en&#160;ML,&#160;l’erreur&#160;à&#160;ne&#160;pas&#160;faire&#160;(et&#160;que&#160;j’ai&#160;malheureusement<br/>
faite&#160;initialement)&#160;et&#160;de&#160;représenter&#160;la&#160;valeur&#160;d’une&#160;évaluation&#160;avec&#160;un&#160;type&#160;différent&#160;de&#160;l’expression<br/>à&#160;évaluer.&#160;La&#160;puissance&#160;de&#160;Lisp&#160;repose&#160;sur&#160;cette&#160;uniformité&#160;entre&#160;programmme&#160;et&#160;valeur.&#160;Nous<br/>utiliserons&#160;cette&#160;caractéristique&#160;pour&#160;implémenter&#160;un&#160;interprète&#160;Lisp&#160;en&#160;Lisp.<br/>
Voici&#160;la&#160;séquence&#160;du&#160;code,&#160;depuis&#160;le&#160;stream&#160;en&#160;entrée&#160;de&#160;l’analyseur&#160;lexical&#160;jusqu’à&#160;la&#160;sortie<br/>
de&#160;l’évaluateur&#160;eval.&#160;J’ai&#160;fait&#160;le&#160;choix&#160;d’avoir&#160;une&#160;représentation&#160;intermédiaire&#160;ast&#160;permettant&#160;de<br/>modéliser&#160;l’arbre&#160;syntaxique,&#160;et&#160;de&#160;faciliter&#160;le&#160;processus&#160;d’évaluation.<br/>
buildast<br/>
(if&#160;a&#160;b&#160;c)<br/>
<i>print</i><br/>
lex<br/>
yacc<br/>
stream<br/>
token<br/>
exp<br/>
ast<br/>
<i>print</i><br/>
If(a,b,c)<br/>
<i>print</i><br/>
Paire(a,&#160;Nil)<br/>
eval<br/>
Voici&#160;le&#160;code&#160;OCAML&#160;des&#160;type&#160;abstrait&#160;exp,&#160;ast&#160;et&#160;env&#160;:<br/>
type&#160;exp&#160;=<br/>
|&#160;Booleen&#160;of&#160;bool<br/>
|&#160;Symbole&#160;of&#160;string<br/>
|&#160;Mot&#160;of&#160;string<br/>
|&#160;Entier&#160;of&#160;int<br/>
|&#160;Nil<br/>
|&#160;Paire&#160;of&#160;exp&#160;ref&#160;*&#160;exp&#160;ref<br/>
|&#160;Closure&#160;of&#160;string&#160;list&#160;*&#160;ast&#160;list&#160;*&#160;(env&#160;ref)<br/>
48<br/>
<hr/>
<a name=49></a>and&#160;ast&#160;=<br/>
|&#160;Atom&#160;of&#160;exp<br/>
|&#160;Var&#160;of&#160;string<br/>
|&#160;If&#160;of&#160;ast&#160;*&#160;ast&#160;*&#160;ast<br/>
|&#160;Cond&#160;of&#160;(ast&#160;*&#160;ast)&#160;list<br/>
|&#160;And&#160;of&#160;ast&#160;list<br/>
|&#160;Or&#160;of&#160;ast&#160;list<br/>
|&#160;Call&#160;of&#160;ast&#160;*&#160;ast&#160;list<br/>
|&#160;Call0&#160;of&#160;ast<br/>
(*&#160;procedure&#160;sans&#160;argument&#160;*)<br/>
|&#160;Lambda&#160;of&#160;string&#160;list&#160;*&#160;ast&#160;list<br/>
|&#160;Let&#160;of&#160;(string&#160;*&#160;ast)&#160;list&#160;*&#160;ast&#160;list<br/>
|&#160;Letrec&#160;of&#160;(string&#160;*&#160;ast)&#160;list&#160;*&#160;ast&#160;list<br/>
|&#160;Define&#160;of&#160;string&#160;*&#160;ast<br/>
|&#160;Begin&#160;of&#160;ast&#160;list<br/>
|&#160;Apply&#160;of&#160;ast&#160;*&#160;ast&#160;list<br/>
|&#160;Quote&#160;of&#160;exp<br/>
and&#160;env&#160;=&#160;(string&#160;*&#160;exp)&#160;list<br/>
<b>3.2.2</b><br/>
<b>Les&#160;étapes&#160;Read,&#160;Eval,&#160;Print</b><br/>
L’interpréte&#160;présente&#160;trois&#160;étapes&#160;que&#160;l’on&#160;décrit&#160;souvent&#160;avec&#160;l’acronyme&#160;<i>REPL&#160;</i>:&#160;Read,&#160;Eval,<br/>
Print,&#160;Loop<br/>
L’étape&#160;<i>READ&#160;</i>sera&#160;effectuée&#160;avec&#160;les&#160;moteurs&#160;ocamllex&#160;et&#160;ocmalyacc.&#160;Cette&#160;étape&#160;va&#160;lire&#160;la<br/>
saisie&#160;clavier&#160;et&#160;construire&#160;l’arbre&#160;syntaxique&#160;des&#160;expressions&#160;SCHEME.<br/>
Voici&#160;quelques&#160;exemples&#160;d’arbres&#160;syntaxiques&#160;générés&#160;avec&#160;Yacc.&#160;Ces&#160;arbres&#160;syntaxiques&#160;sont&#160;à<br/>
nouveau&#160;dessinés&#160;avec&#160;le&#160;package&#160;Tikz&#160;et&#160;nous&#160;avons&#160;développé&#160;une&#160;petite&#160;fonction&#160;qui&#160;parcourt<br/>l’expression&#160;et&#160;génère&#160;le&#160;code&#160;Tikz.<br/>
(moins&#160;4&#160;3)<br/>
call<br/>
var<br/>
exp&#160;list<br/>
moins&#160;4<br/>
3<br/>
(if&#160;#t&#160;(plus&#160;4&#160;5)&#160;(moins&#160;3&#160;2))<br/>
49<br/>
<hr/>
<a name=50></a>if<br/>
true<br/>
call<br/>
call<br/>
var<br/>
exp&#160;list<br/>
var<br/>
exp&#160;list<br/>
plus&#160;4<br/>
5&#160;moins&#160;3<br/>
2<br/>
Et&#160;enfin&#160;une&#160;expression&#160;let&#160;(let&#160;((a&#160;2)&#160;(b&#160;3))&#160;(plus&#160;a&#160;b))<br/>
let<br/>
body&#160;let<br/>
bind<br/>
bind<br/>
call<br/>
a<br/>
2&#160;b<br/>
3<br/>
var<br/>
exp&#160;list<br/>
plus&#160;var<br/>
var<br/>
a<br/>
b<br/>
L’étape&#160;<i>EVAL&#160;</i>va&#160;parcourir&#160;l’arbre&#160;syntaxique&#160;de&#160;l’expression,&#160;traiter&#160;cette&#160;expression&#160;et&#160;en<br/>
exprimer&#160;une&#160;valeur&#160;modélisée&#160;avec&#160;le&#160;type&#160;value<br/>
La&#160;fonction&#160;eval&#160;est&#160;une&#160;fonction&#160;prenant&#160;pour&#160;arguments&#160;une&#160;expression&#160;de&#160;type&#160;ast&#160;et&#160;un<br/>
environnement.&#160;Elle&#160;retourne&#160;une&#160;valeur&#160;de&#160;type&#160;exp.&#160;Voici&#160;sa&#160;signature&#160;:<br/>val&#160;eval&#160;:&#160;ast&#160;-&gt;&#160;env&#160;-&gt;&#160;exp&#160;=&#160;&lt;fun&gt;<br/>
L’étape&#160;<i>PRINT&#160;</i>n’est&#160;autre&#160;que&#160;la&#160;fonction&#160;d’affichage&#160;finale&#160;de&#160;l’interprète.&#160;Une&#160;fois&#160;cette&#160;étape<br/>
finie,&#160;l’interprète&#160;boucle&#160;sur&#160;l’étape&#160;initiale&#160;<i>READ</i><br/>
<b>3.2.3</b><br/>
<b>Liaison&#160;lexicale&#160;vs&#160;liaison&#160;dynamique</b><br/>
Nous&#160;allons&#160;utiliser&#160;ici&#160;la&#160;liaison&#160;lexicale&#160;(statique),&#160;et&#160;non&#160;dynamique.&#160;Cela&#160;nous&#160;impose&#160;de<br/>
capturer&#160;l’environnement&#160;existant&#160;au&#160;moment&#160;de&#160;la&#160;définition&#160;de&#160;la&#160;fonction.&#160;Plus&#160;précisément,<br/>l’environnement&#160;est&#160;capturé&#160;par&#160;l’évaluation&#160;de&#160;la&#160;lambda,&#160;évaluation&#160;dont&#160;la&#160;valeur&#160;est&#160;appelée<br/>une&#160;<i>closure&#160;</i>ou&#160;<i>fermeture</i>.<br/>
Lambda&#160;(parametres,&#160;expression)&#160;-&gt;&#160;Closure&#160;(parametres,&#160;expression,&#160;env)<br/>
50<br/>
<hr/>
<a name=51></a>Dans&#160;le&#160;cas&#160;de&#160;la&#160;liaison&#160;dynamique,&#160;la&#160;fonction&#160;est&#160;appliquée&#160;en&#160;utilisant&#160;l’environnement<br/>
courant,&#160;et&#160;non&#160;pas&#160;son&#160;environnement&#160;de&#160;définition.&#160;Donc&#160;pas&#160;besoin&#160;de&#160;fermeture.<br/>
A&#160;ma&#160;connaissance,&#160;la&#160;liaison&#160;statique&#160;est&#160;maintenant&#160;utilisée&#160;dans&#160;la&#160;plupart&#160;des&#160;langages<br/>
fonctionnels.&#160;En&#160;SCHEME&#160;et&#160;ML,nous&#160;pouvons&#160;voir&#160;dans&#160;l’exemple&#160;ci-dessous&#160;que&#160;l’évaluation&#160;de<br/>la&#160;définition&#160;de&#160;la&#160;lambda&#160;inc_x&#160;capture&#160;la&#160;valeur&#160;de&#160;x&#160;.<br/>
SCHEME<br/>
ML<br/>
&gt;&#160;(define&#160;x&#160;1)<br/>
#&#160;let&#160;x&#160;=&#160;1&#160;;&#160;;<br/>
&gt;&#160;(define&#160;inc_x&#160;(lambda&#160;()&#160;(+&#160;x&#160;1)))<br/>
#&#160;let&#160;inc_x&#160;=&#160;function&#160;()&#160;-&gt;&#160;x+1&#160;;;<br/>
&gt;&#160;(inc_x)<br/>
#&#160;inc_x&#160;()&#160;;&#160;;<br/>
2<br/>
-&#160;:&#160;int&#160;=&#160;2<br/>
&gt;&#160;(let&#160;((x&#160;100))&#160;(inc_x))<br/>
#&#160;let&#160;x&#160;=&#160;100&#160;in&#160;inc_x&#160;()&#160;;;<br/>
2<br/>
-&#160;:&#160;int&#160;=&#160;2<br/>
<b>3.2.4</b><br/>
<b>Gestion&#160;de&#160;l’environnement</b><br/>
Comme&#160;indiqué&#160;en&#160;préambule,&#160;plusieurs&#160;choix&#160;sont&#160;possibles&#160;pour&#160;la&#160;modélisation&#160;de&#160;l’envi-<br/>
ronnement.&#160;Le&#160;choix&#160;le&#160;plus&#160;simple&#160;est&#160;une&#160;représentation&#160;par&#160;une&#160;liste&#160;de&#160;paires&#160;<i>variable&#160;</i>↔<br/><i>value&#160;</i>Ce&#160;choix&#160;peut&#160;être&#160;fait&#160;en&#160;OCAML&#160;par&#160;le&#160;type&#160;natif&#160;list&#160;ou&#160;en&#160;utilisant&#160;le&#160;type&#160;concret<br/>Paire&#160;of&#160;Symbole&#160;*&#160;lobject<br/>
La&#160;principale&#160;difficulté&#160;est&#160;la&#160;représentation&#160;de&#160;fonctions&#160;récursives,&#160;comme&#160;en&#160;exemple&#160;la&#160;fac-<br/>
torielle&#160;ci-dessous&#160;:<br/>
(define&#160;fact<br/>
(lambda&#160;(n)<br/>
(if&#160;(eq?&#160;n&#160;0)<br/>
1<br/>
(*&#160;n&#160;(fact&#160;(-&#160;n&#160;1)))))<br/>
Nous&#160;devons&#160;capturer&#160;l’environnement&#160;existant&#160;au&#160;moment&#160;de&#160;la&#160;définition&#160;de&#160;la&#160;fonction.&#160;Cet<br/>environnement&#160;existant&#160;ne&#160;contient&#160;pas&#160;déjà&#160;la&#160;définition&#160;de&#160;fact.<br/>
Il&#160;y&#160;a&#160;trois&#160;possibilités&#160;pour&#160;traiter&#160;ce&#160;problème&#160;de&#160;représentation&#160;d’un&#160;environnement&#160;<i>récursif</i>.<br/>
1.&#160;Utiliser&#160;une&#160;structure&#160;de&#160;liste&#160;qui&#160;permet&#160;à&#160;l’environnement&#160;capturé&#160;lors&#160;de&#160;la&#160;cloture&#160;de&#160;la<br/>
lambda&#160;de&#160;boucler&#160;sur&#160;lui-même&#160;La&#160;matérialisation&#160;de&#160;cette&#160;boucle&#160;ne&#160;peut&#160;à&#160;ma&#160;connaissance<br/>qu’être&#160;réalisée&#160;par&#160;un&#160;type&#160;liste&#160;<i>mutable</i>.<br/>
Comment&#160;construire&#160;un&#160;environnement&#160;qui&#160;contient&#160;la&#160;fonction&#160;que&#160;l’on&#160;est&#160;en&#160;train&#160;de<br/>définir&#160;?<br/>
envRec&#160;=<br/>
(fac,&#160;&lt;lambda&#160;corps&gt;,&#160;envRec)&#160;::&#160;env<br/>
C’est&#160;une&#160;équation&#160;de&#160;point&#160;fixe.&#160;.&#160;.<br/>
On&#160;remarquera&#160;également&#160;que&#160;le&#160;letrec&#160;de&#160;SCHEME&#160;peut&#160;être&#160;sémantiquement&#160;remplacé<br/>par&#160;un&#160;let&#160;associé&#160;de&#160;set!&#160;Et&#160;de&#160;la&#160;même&#160;manière,&#160;nous&#160;pouvons&#160;faire&#160;cette&#160;opération&#160;en<br/>ML,&#160;avec&#160;l’unique&#160;nuance&#160;est&#160;que&#160;le&#160;let&#160;temporaire&#160;représente&#160;bien&#160;une&#160;fonction&#160;pour&#160;que<br/>la&#160;cohérence&#160;des&#160;types&#160;soit&#160;assurée.<br/>
SCHEME<br/>
(letrec&#160;((f&#160;e))<br/>
corps)<br/>
51<br/>
<hr/>
<a name=52></a>==&gt;<br/>
(let&#160;((f&#160;’any))<br/>
(let&#160;((f-aux&#160;e))<br/>
(set!&#160;f&#160;f-aux)<br/>
corps))<br/>
(let&#160;((fact&#160;’any))<br/>
(let&#160;((f-aux&#160;(lambda&#160;(n)&#160;(if&#160;(eq?&#160;n&#160;0)&#160;1&#160;(*&#160;n&#160;(fact&#160;(-&#160;n&#160;1)))))))<br/>
(set!&#160;fact&#160;f-aux))<br/>
(fact&#160;5))<br/>
OCAML<br/>
let&#160;fact&#160;=&#160;ref&#160;(function&#160;x&#160;-&gt;&#160;x)&#160;in<br/>
let&#160;aux&#160;n&#160;=&#160;if&#160;n=0&#160;then&#160;1&#160;else&#160;n&#160;*&#160;!fact&#160;(n&#160;-&#160;1)&#160;in<br/>
fact:=&#160;aux&#160;;&#160;!fact&#160;5<br/>
2.&#160;Dans&#160;le&#160;cas&#160;de&#160;fonction&#160;récursive,&#160;ne&#160;plus&#160;nous&#160;reposer&#160;sur&#160;l’environnement&#160;mais,&#160;comme&#160;en<br/>
<i>λ</i>-calcul,&#160;utiliser&#160;un&#160;combinateur&#160;de&#160;point&#160;fixe&#160;qui&#160;permet&#160;de&#160;calculer&#160;le&#160;point&#160;fixe&#160;de&#160;notre<br/>fonction,&#160;sans&#160;avoir&#160;à&#160;la&#160;nommer.<br/>
Nous&#160;allons&#160;utiliser&#160;ce&#160;procédé&#160;dans&#160;l’implémentation&#160;ML&#160;de&#160;notre&#160;interprète&#160;Scheme.<br/>
Nous&#160;rappelons&#160;ci-dessous&#160;un&#160;exemple&#160;de&#160;combinateur&#160;implémenté&#160;en&#160;SCHEME,&#160;et&#160;comment<br/>il&#160;peut&#160;être&#160;utilisé.<br/>
(define&#160;Y<br/>
(lambda(f)<br/>
(let&#160;((g&#160;(lambda&#160;(h)&#160;(lambda(x)&#160;((f&#160;(h&#160;h)&#160;x))))))<br/>
(g&#160;g))))<br/>
(define&#160;F*<br/>
(lambda&#160;(f)<br/>
(lambda&#160;(n)<br/>
(if&#160;(eq?&#160;n&#160;0)<br/>
1<br/>
(*&#160;n&#160;(f&#160;(-&#160;n&#160;1)))))))<br/>
(define&#160;fact&#160;(Y&#160;F*))<br/>
3.&#160;La&#160;troisième&#160;approche&#160;est&#160;de&#160;modéliser&#160;l’environnement&#160;par&#160;une&#160;fonction,&#160;et&#160;non&#160;plus&#160;une<br/>
liste&#160;d’association.&#160;La&#160;consultation&#160;de&#160;l’environnement&#160;consiste&#160;à&#160;appliquer&#160;la&#160;fonction&#160;env<br/>qui&#160;le&#160;représente.<br/>
Considérons&#160;l’expression&#160;(letrec&#160;((x1&#160;e1)&#160;...&#160;(xn&#160;en))&#160;corps)&#160;qui,&#160;on&#160;le&#160;rappelle,&#160;est<br/>équivalente&#160;à&#160;((lambda&#160;(x1&#160;...&#160;xn)&#160;corps)&#160;e1&#160;...&#160;en)<br/>
L’environnement&#160;capturé&#160;envRec&#160;au&#160;moment&#160;de&#160;la&#160;définition&#160;de&#160;la&#160;lambda&#160;doit&#160;correspondre<br/>à&#160;l’environnement&#160;étendu&#160;aux&#160;xi&#160;dont&#160;les&#160;valeurs&#160;sont&#160;données&#160;par&#160;l’évaluation&#160;des&#160;ei&#160;de&#160;la<br/>lambda&#160;dans&#160;cet&#160;environnement&#160;envRec&#160;C’est&#160;nécessaire&#160;afin&#160;que&#160;les&#160;ei&#160;puissent&#160;faire&#160;appel<br/>à&#160;des&#160;références&#160;récursives&#160;des&#160;xi.<br/>
52<br/>
<hr/>
<a name=53></a><img src="document-53_1.jpg"/><br/>
Nous&#160;avons&#160;ainsi&#160;(et&#160;à&#160;nouveau)&#160;une&#160;équation&#160;de&#160;point&#160;fixe&#160;:<br/>
<i>envRec</i>(<i>xi</i>)&#160;=&#160;<i>eval</i>(<i>ei,&#160;envRec</i>)<br/><i>envRec</i>(<i>xi</i>)&#160;=&#160;<i>env</i>(<i>xi</i>)&#160;<i>si&#160;xi&#160;/</i><br/>
∈&#160;<i>letrec</i><br/>
<b>3.3</b><br/>
<b>Un&#160;interprète&#160;LISP&#160;avec&#160;le&#160;nouvel&#160;interprète&#160;MiniScheme&#160;.&#160;.&#160;.</b><br/>
<b>La&#160;mise&#160;en&#160;abyme</b><br/>
<i>Pour&#160;obtenir&#160;cet&#160;effet,&#160;suivez-moi,&#160;j’invente&#160;un</i><br/>
<i>personnage&#160;de&#160;romancier,&#160;que&#160;je&#160;pose&#160;en&#160;figure<br/>centrale&#160;;&#160;et&#160;le&#160;sujet&#160;du&#160;livre,&#160;si&#160;vous&#160;voulez,<br/>c’est&#160;précisément&#160;la&#160;lutte&#160;entre&#160;ce&#160;que&#160;lui&#160;offre<br/>la&#160;réalité&#160;et&#160;ce&#160;que,&#160;lui,&#160;prétend&#160;en&#160;faire.&#160;</i><a href="documents.html#127">[7]<br/></a>Les&#160;Faux-monnayeurs.&#160;André&#160;Gide<br/>
Καὶ&#160;εἶπεν&#160;ὁ&#160;θεὸς&#160;πρὸς&#160;Μωυσῆν&#160;᾿Εγώ&#160;εἰμι&#160;ὁ&#160;ὤν.<br/>Exode&#160;3,&#160;14.&#160;La&#160;Septante<br/>
Figure&#160;3.1&#160;–&#160;Gumpp<br/>
<b>LISP&#160;mis&#160;en&#160;abyme</b><br/>
C’est&#160;ici&#160;un&#160;exercice&#160;assez&#160;classique.&#160;Nous&#160;avons&#160;fait&#160;le&#160;choix&#160;d’un&#160;interprète&#160;avec&#160;liaison&#160;dyna-<br/>
mique.&#160;Nous&#160;aurons&#160;ainsi&#160;l’évaluation&#160;suivante&#160;retournant&#160;13&#160;et&#160;non&#160;10.<br/>
((evaluate<br/>
’(let&#160;((a&#160;1))<br/>
(let&#160;((f&#160;(lambda&#160;(b)&#160;(+&#160;b&#160;a))))<br/>
(let&#160;((a&#160;3))&#160;(f&#160;10)))<br/>
))&#160;env)<br/>
En&#160;outre,&#160;il&#160;n’est&#160;pas&#160;nécessaire&#160;d’avoir&#160;un&#160;mécanisme&#160;de&#160;point&#160;fixe&#160;ou&#160;d’environnement&#160;récursif<br/>pour&#160;l’appel&#160;d’une&#160;fonction&#160;récusrsive.&#160;C’est&#160;l’un&#160;des&#160;avantages&#160;de&#160;la&#160;liaison&#160;dynamique.<br/>
((evaluate<br/>
’(let&#160;((fact&#160;(lambda&#160;(n)&#160;(if&#160;(=&#160;n&#160;0)&#160;1&#160;(*&#160;n&#160;(fact&#160;(-&#160;n&#160;1)))))))<br/>
(fact&#160;6)))<br/>
env)<br/>
53<br/>
<hr/>
<a name=54></a><b>3.4</b><br/>
<b>L’auto-interprétation&#160;de&#160;l’interprète</b><br/>
En&#160;rendant&#160;explicite&#160;la&#160;procédure&#160;eval&#160;et&#160;ses&#160;acolytes&#160;evlis,&#160;invoke,&#160;...&#160;dans&#160;l’environ-<br/>
nement&#160;env&#160;,&#160;la&#160;procédure&#160;evaluate&#160;pourra&#160;être&#160;évaluée&#160;par&#160;elle-même.&#160;Le&#160;premier&#160;argument<br/>évalué&#160;de&#160;la&#160;fonction&#160;est&#160;le&#160;symbole&#160;env.&#160;Ce&#160;symbole&#160;devra&#160;être&#160;contenu&#160;dans&#160;l’environnement&#160;env,<br/>c’est-à-dire&#160;dans&#160;lui-même.&#160;.&#160;.<br/>
Nous&#160;avons&#160;(eval&#160;’(eval&#160;’<i>π&#160;</i>env)&#160;env)&#160;≡&#160;(evaluate&#160;’<i>π&#160;</i>env)<br/>
<b>3.4.1</b><br/>
<b>La&#160;tour&#160;de&#160;Babel</b><br/>
I∞<br/>
...<br/>
.&#160;.&#160;.<br/>
env.&#160;#env<br/>
I4<br/>
(eval&#160;’(eval&#160;’(eval&#160;’(eval&#160;0<i>π&#160;</i>env)&#160;env)&#160;env)&#160;env)<br/>
I3<br/>
(eval&#160;’(eval&#160;’(eval&#160;0<i>π&#160;</i>env)&#160;env)&#160;env)<br/>
I2<br/>
evlis.&lt;proc&gt;<br/>
(eval&#160;’(eval&#160;0<i>π&#160;</i>env)&#160;env)<br/>
I1<br/>
(eval&#160;0<i>π&#160;</i>env)<br/>
eval.&lt;proc&gt;<br/>
I0<br/>
SCHEME<br/>
((evaluate&#160;(quote&#160;((evaluate&#160;(quote&#160;((evaluate&#160;(quote&#160;((evaluate&#160;(quote&#160;(<br/>
(lambda&#160;(x&#160;y)&#160;(+&#160;x&#160;y))&#160;(fact&#160;5)&#160;(fact&#160;6)&#160;)))<br/>
env)))&#160;env)))&#160;env)))&#160;env)<br/>
<b>L’environnement</b><br/>
L’environnement&#160;doit&#160;contenir&#160;la&#160;valeur&#160;du&#160;symbole&#160;env.&#160;Il&#160;doit&#160;faire&#160;référence&#160;à&#160;lui-même.&#160;Seule<br/>
une&#160;liste&#160;mutable&#160;peut&#160;modéliser&#160;cette&#160;boucle&#160;infinie.<br/>
&gt;&#160;env&#160;;&#160;affichage&#160;de&#160;l’environnement&#160;récursif&#160;avec&#160;DrRacket<br/>
#0=((env&#160;.&#160;#0#)<br/>
(not&#160;.&#160;#&lt;procedure:...interpreter2.scm:15:17&gt;)<br/>
(=&#160;.&#160;#&lt;procedure:...interpreter2.scm:16:15&gt;)<br/>
(*&#160;.&#160;#&lt;procedure:...interpreter2.scm:17:17&gt;)<br/>
(-&#160;.&#160;#&lt;procedure:...interpreter2.scm:18:17&gt;)<br/>
(+&#160;.&#160;#&lt;procedure:...interpreter2.scm:19:17&gt;)<br/>
(atom?&#160;.&#160;#&lt;procedure:...interpreter2.scm:20:19&gt;)<br/>
(boolean?&#160;.&#160;#&lt;procedure:...interpreter2.scm:21:22&gt;)<br/>
(number?&#160;.&#160;#&lt;procedure:...interpreter2.scm:22:21&gt;)<br/>
(cons&#160;.&#160;#&lt;procedure:...interpreter2.scm:23:18&gt;)<br/>
(car&#160;.&#160;#&lt;procedure:...interpreter2.scm:24:17&gt;)<br/>
54<br/>
<hr/>
<a name=55></a>(cdr&#160;.&#160;#&lt;procedure:...interpreter2.scm:25:17&gt;)<br/>
(pair?&#160;.&#160;#&lt;procedure:...interpreter2.scm:34:19&gt;)<br/>
(apply&#160;.&#160;#&lt;procedure:...interpreter2.scm:36:22&gt;)<br/>
(fact&#160;.&#160;#&lt;procedure:...interpreter2.scm:46:20&gt;)<br/>
(lookup&#160;.&#160;#&lt;procedure:...interpreter2.scm:53:21&gt;)<br/>
(eprogn&#160;.&#160;#&lt;procedure:...interpreter2.scm:63:21&gt;)<br/>
(evlis&#160;.&#160;#&lt;procedure:...interpreter2.scm:74:20&gt;)<br/>
(invoke&#160;.&#160;#&lt;procedure:...interpreter2.scm:85:14&gt;)<br/>
(extend&#160;.&#160;#&lt;procedure:...interpreter2.scm:94:18&gt;)<br/>
(mapcar&#160;.&#160;#&lt;procedure:...interpreter2.scm:105:18&gt;)<br/>
(mapcadr&#160;.&#160;#&lt;procedure:...interpreter2.scm:113:19&gt;)<br/>
(evallet&#160;.&#160;#&lt;procedure:...interpreter2.scm:121:6&gt;)<br/>
(evaluate&#160;.&#160;#&lt;procedure:...interpreter2.scm:128:16&gt;))<br/>
<b>3.4.2</b><br/>
<b>Réification&#160;et&#160;réflexion</b><br/>
La&#160;<i>réification&#160;</i>est&#160;le&#160;fait&#160;de&#160;rendre&#160;concrète&#160;une&#160;chose&#160;abstraite.&#160;Dans&#160;le&#160;cas&#160;de&#160;notre&#160;tour&#160;de<br/>
Babel,&#160;réifier&#160;un&#160;objet&#160;du&#160;langage&#160;d’implémentation&#160;le&#160;rendra&#160;accessible&#160;au&#160;langage&#160;implémenté.<br/>On&#160;peut&#160;citer&#160;l’exemple&#160;de&#160;la&#160;fonction&#160;eval&#160;rendant&#160;accessible&#160;dans&#160;Scheme&#160;le&#160;process&#160;d’évaluation.<br/>(eval&#160;’<i>π&#160;</i>)&#160;=<br/>
<i>π</i><br/>
L’autre&#160;exemple&#160;que&#160;nous&#160;implémenterons&#160;est&#160;la&#160;réification&#160;de&#160;la&#160;continuation&#160;courante,&#160;mis&#160;à<br/>
disposition&#160;par&#160;la&#160;fonction&#160;call/cc.&#160;Cette&#160;fonction&#160;prend&#160;en&#160;argument&#160;une&#160;lambda&#160;avec&#160;un&#160;seul<br/>paramètre&#160;qui&#160;récupère&#160;la&#160;continuation&#160;courante&#160;de&#160;l’expression&#160;en&#160;cours&#160;d’évaluation.<br/>
E&#160;=&#160;(e1&#160;e2&#160;...&#160;(call/cc&#160;(lambda&#160;(k)&#160;ei))&#160;...&#160;en)<br/>
Si&#160;ei&#160;ne&#160;fait&#160;pas&#160;appel&#160;à&#160;k,&#160;alors&#160;ei&#160;est&#160;évaluée&#160;normalement,&#160;ainsi&#160;que&#160;E.&#160;Dans&#160;le&#160;cas&#160;contraire,&#160;k<br/>est&#160;appelée,&#160;liée&#160;à&#160;la&#160;continuation&#160;courante.&#160;Le&#160;résultat&#160;de&#160;ei&#160;est&#160;ainsi&#160;rendue&#160;à&#160;cette&#160;continuation<br/>capturée&#160;(e1&#160;...&#160;[]&#160;...&#160;en).&#160;Autrement&#160;écrit&#160;k&#160;=&#160;(lambda(v)&#160;(e1&#160;...&#160;v&#160;...&#160;en))<br/>
(+&#160;5&#160;(call/cc&#160;(lambda&#160;(k)&#160;(*&#160;2&#160;(k&#160;8)))))<br/>
=&#160;12<br/>
L’environnement&#160;global-env&#160;partagé&#160;avec&#160;les&#160;différents&#160;interprètes&#160;I<i>i&#160;</i>de&#160;notre&#160;tour&#160;de&#160;babel<br/>
est&#160;aussi&#160;considéré&#160;comme&#160;un&#160;environnement&#160;réifié.&#160;L’environnement&#160;du&#160;langage&#160;d’implémentation<br/>est&#160;ici&#160;mis&#160;à&#160;disposition&#160;aux&#160;langages&#160;implémentés.<br/>
La&#160;<i>réflection&#160;</i>peut&#160;être&#160;vue&#160;comme&#160;l’opération&#160;inverse&#160;de&#160;la&#160;réification.&#160;Elle&#160;permet&#160;la&#160;mise&#160;à<br/>
disposition&#160;dans&#160;le&#160;langage&#160;d’implémentation&#160;un&#160;objet&#160;du&#160;langage&#160;implémenté.&#160;Comme&#160;exemple,<br/>citons&#160;la&#160;fonction&#160;quote&#160;qui&#160;n’évalue&#160;pas&#160;son&#160;argument&#160;et&#160;le&#160;rend&#160;tel&#160;quel.&#160;quote&#160;est&#160;une&#160;primitive&#160;du<br/>langage&#160;Scheme&#160;dans&#160;le&#160;sens&#160;où&#160;il&#160;n’est&#160;pas&#160;possible&#160;de&#160;redéfinir&#160;cette&#160;fonction&#160;avec&#160;les&#160;autre&#160;éléments<br/>du&#160;langage.&#160;Avec&#160;l’implémentation&#160;de&#160;l’interprète&#160;I<i>R&#160;</i>permettant&#160;les&#160;opérations&#160;de&#160;réflection&#160;et<br/>réification,&#160;cela&#160;deviendra&#160;possible.<br/>
Pour&#160;faire&#160;court,&#160;la&#160;réflection&#160;est&#160;une&#160;opération&#160;d’abstraction&#160;;&#160;la&#160;réification&#160;est&#160;l’application<br/>
d’une&#160;abstraction.&#160;Ce&#160;sont&#160;ainsi&#160;deux&#160;opérations&#160;réciproques.&#160;Voici&#160;ce&#160;que&#160;nous&#160;donne&#160;pour&#160;infor-<br/>mation&#160;la&#160;définition&#160;du&#160;terme&#160;<i>abstraction&#160;</i>recherché&#160;dans&#160;notre&#160;dictionnaire.<br/>
<b>Définition&#160;6.&#160;</b><i>L’abstraction&#160;désigne&#160;le&#160;produit&#160;de&#160;l’opération&#160;qui&#160;consiste&#160;à&#160;isoler&#160;par&#160;la&#160;pensée&#160;une<br/>ou&#160;plusieurs&#160;qualités&#160;d’un&#160;objet&#160;concret&#160;pour&#160;en&#160;former&#160;une&#160;représentation&#160;intellectuelle</i><br/>
55<br/>
<hr/>
<a name=56></a>réification<br/>
program&#160;vers&#160;data<br/>
((reifier-to-cloture&#160;proc)&#160;(cdr&#160;e)&#160;r&#160;k)<br/>
réflection<br/>
data&#160;vers&#160;program<br/>
(cloture-to-reifier&#160;(lambda&#160;(e&#160;r&#160;k)&#160;exp))<br/>
<b>L’interprète&#160;par&#160;continuation</b><br/>
La&#160;fonction&#160;d’évaluation&#160;sera&#160;enrichie&#160;pour&#160;prendre&#160;trois&#160;arguments,&#160;le&#160;programme&#160;<i>π&#160;</i>à&#160;évaluer,<br/>
D<br/>
l’environnement&#160;<i>ρ&#160;</i>et&#160;la&#160;continuation&#160;<i>κ</i><br/>
(eval&#160;<i>π&#160;ρ&#160;κ&#160;</i>)<br/>
valeur<br/>
Nous&#160;reprenons&#160;ici&#160;le&#160;code&#160;de&#160;l’excellent&#160;article&#160;<i>a&#160;Simple&#160;Reflective&#160;Interpreter&#160;</i><a href="documents.html#127">[19]&#160;</a>La&#160;fonction<br/>
evaluate&#160;implémente&#160;un&#160;interprète&#160;Lisp&#160;en&#160;mode&#160;CPS&#160;de&#160;manière&#160;très&#160;naturelle.&#160;La&#160;valeur&#160;ajoutée<br/>de&#160;l’article&#160;est&#160;la&#160;modélisation&#160;des&#160;fonctions.&#160;Trois&#160;types&#160;sont&#160;disponibles&#160;et&#160;distinguées&#160;par&#160;un&#160;tag<br/>dans&#160;l’environnement.<br/>
1.&#160;Les&#160;fonctions&#160;utilisateurs&#160;(cloture&#160;(parl)&#160;exp&#160;env)<br/>
2.&#160;Les&#160;fonctions&#160;réifiées&#160;(reifier&#160;(e&#160;r&#160;k&#160;)&#160;exp&#160;)<br/>
3.&#160;Les&#160;fonctions&#160;primitives&#160;(primitive&#160;nom&#160;)<br/>
L’application&#160;d’une&#160;fonction&#160;utilisateur&#160;se&#160;fait&#160;de&#160;manière&#160;classique&#160;par&#160;une&#160;évaluation&#160;du&#160;corps<br/>de&#160;la&#160;lambda&#160;sur&#160;un&#160;environnement&#160;étendu&#160;aux&#160;nouvelles&#160;liaisons&#160;entre&#160;paramètres&#160;et&#160;arguments<br/>préalablement&#160;évalués.<br/>
Une&#160;fonction&#160;réifiée&#160;prend&#160;trois&#160;paramètres&#160;e,&#160;r&#160;et&#160;k.<br/>—&#160;e&#160;est&#160;lié&#160;à&#160;la&#160;liste&#160;des&#160;arguments&#160;non&#160;évalués&#160;de&#160;l’application.<br/>—&#160;r&#160;est&#160;lié&#160;à&#160;l’environnement&#160;de&#160;l’interprète&#160;évaluant&#160;l’application.<br/>—&#160;k&#160;est&#160;lié&#160;à&#160;la&#160;continuation&#160;de&#160;l’interprète&#160;évaluant&#160;l’application.<br/>
Ainsi,&#160;nous&#160;avons&#160;un&#160;contrôle&#160;<i>complet&#160;</i>de&#160;la&#160;fonction&#160;réifiée&#160;:&#160;contrôle&#160;du&#160;corps&#160;de&#160;la&#160;fonction&#160;et<br/>des&#160;arguments&#160;non&#160;encore&#160;évalués&#160;par&#160;l’interprète&#160;sous-jacent,&#160;mais&#160;aussi&#160;la&#160;possibilité&#160;d’accéder&#160;à<br/>l’environnement&#160;et&#160;à&#160;la&#160;continuation&#160;courante.&#160;En&#160;bref,&#160;no&#160;limit,&#160;on&#160;peut&#160;tout&#160;définir.&#160;.&#160;.<br/>
Les&#160;fonctions&#160;callcc&#160;et&#160;quote&#160;seront&#160;très&#160;simplement&#160;codées&#160;de&#160;la&#160;manière&#160;suivante&#160;:<br/>
(define&#160;callcc&#160;(cloture-to-reifier&#160;(lambda&#160;(e&#160;r&#160;k)&#160;((evaluate&#160;(car&#160;e)&#160;r&#160;id)&#160;k))))<br/>
(define&#160;quote&#160;(cloture-to-reifier&#160;(lambda&#160;(e&#160;r&#160;k)&#160;(k&#160;(car&#160;e)&#160;))))<br/>
Dès&#160;le&#160;niveau&#160;1&#160;de&#160;notre&#160;tour,&#160;c’est-à-dire&#160;lorsque&#160;la&#160;fonction&#160;evaluate&#160;n’est&#160;plus&#160;évaluée&#160;par<br/>
Scheme&#160;mais&#160;par&#160;elle-même,&#160;les&#160;formes&#160;spéciales&#160;if,&#160;quote,&#160;begin,&#160;define&#160;sont&#160;représentées&#160;par<br/>des&#160;fonctions&#160;réifiées.&#160;La&#160;fonction&#160;d’évaluation&#160;peut&#160;ainsi&#160;être&#160;réduite&#160;à&#160;son&#160;strict&#160;minimum&#160;:<br/>
(define&#160;evaluate<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
((if&#160;(pair?&#160;e)<br/>
(if&#160;(equal?&#160;(car&#160;e)&#160;’lambda)<br/>
eval-abstraction<br/>
eval-application)<br/>
(if&#160;(or&#160;(or&#160;(number?&#160;e)&#160;(string?&#160;e))&#160;(boolean?&#160;e))<br/>
eval-constante<br/>
eval-variable))<br/>
e&#160;r&#160;k&#160;)))<br/>
56<br/>
<hr/>
<a name=57></a><img src="document-57_1.jpg"/><br/>
La&#160;fonction&#160;openloop&#160;peut&#160;être&#160;lancée&#160;à&#160;volonté&#160;et&#160;peut&#160;créer<br/>une&#160;succession&#160;de&#160;nouveaux&#160;étages&#160;dans&#160;notre&#160;tour&#160;de&#160;babel.<br/>Comme&#160;dans&#160;l’épisode&#160;biblique&#160;du&#160;livre&#160;de&#160;la&#160;<a href="documents.html#127">Genèse[1],&#160;</a>la&#160;fa-<br/>culté&#160;d’avoir&#160;un&#160;langage&#160;commun&#160;permet&#160;la&#160;construction&#160;d’une<br/>tour&#160;de&#160;hauteur&#160;potentiellement&#160;infinie.&#160;Nous&#160;nous&#160;retrouvons<br/>nous-même&#160;grisés&#160;par&#160;cette&#160;tour&#160;<i>dont&#160;la&#160;tête&#160;touche&#160;les&#160;cieux<br/></i>(ἡ&#160;κεφαλὴ&#160;ἔσται&#160;ἕως&#160;τοῦ&#160;οὐρανοῦ).&#160;Nous&#160;citons&#160;ici&#160;la&#160;Septante<br/>(LXX).<br/>L’enthousiasme&#160;de&#160;pouvoir&#160;monter&#160;dans&#160;les&#160;étages&#160;doit&#160;cepen-<br/>dant&#160;être&#160;tempéré.&#160;Le&#160;fait&#160;d’être&#160;à&#160;l’étage&#160;<i>n&#160;</i>+&#160;1&#160;n’apporte&#160;rien<br/>par&#160;rapport&#160;à&#160;l’étage&#160;<i>n</i>.&#160;L’application&#160;eval&#160;est&#160;idempotente&#160;car<br/>∀<i>π&#160;</i>(eval&#160;’<i>π</i>)&#160;=&#160;(eval&#160;(eval&#160;’&#160;<i>π</i>)).&#160;Autrement&#160;dit,&#160;la&#160;valeur<br/>
Figure&#160;3.2&#160;–&#160;Bruegel<br/>
(eval’<i>π</i>)&#160;est&#160;un&#160;point&#160;fixe&#160;de&#160;eval.<br/>
ΓΕΝΕΣΙΣ&#160;11<br/>
1.&#160;Καὶ&#160;ἦν&#160;πᾶσα&#160;ἡ&#160;γῆ&#160;χεῖλος&#160;ἕν,&#160;καὶ&#160;φωνὴ&#160;μία&#160;πᾶσιν.<br/>
(...)<br/>
9.&#160;διὰ&#160;τοῦτο&#160;ἐκλήθη&#160;τὸ&#160;ὄνομα&#160;αὐτῆς&#160;Σύγχυσις,&#160;ὅτι&#160;ἐκεῖ&#160;συνέχεεν&#160;κύριος&#160;τὰ&#160;χείλη&#160;πάσης&#160;τῆς&#160;γῆς.<br/><i>Toute&#160;la&#160;terre&#160;avait&#160;alors&#160;une&#160;même&#160;parole&#160;;&#160;il&#160;y&#160;avait&#160;une&#160;seule&#160;langue&#160;pour&#160;tous.<br/>À&#160;cause&#160;de&#160;cela,&#160;ce&#160;lieu&#160;fut&#160;appelé&#160;Babel&#160;(confusion),&#160;parce&#160;que&#160;là&#160;le&#160;Seigneur&#160;confondit&#160;les&#160;langues<br/>de&#160;toute&#160;la&#160;terre.</i><br/>
En&#160;pratique,&#160;malheureusement&#160;dès&#160;le&#160;niveau&#160;3&#160;de&#160;notre&#160;tour,&#160;les&#160;temps&#160;d’évaluation&#160;deviennent<br/>
abominablement&#160;longs&#160;sur&#160;notre&#160;interprète&#160;maison&#160;implémenté&#160;en&#160;OCAML.&#160;Plusieurs&#160;minutes&#160;sont<br/>requises&#160;pour&#160;le&#160;calcul&#160;de&#160;la&#160;factorielle&#160;de&#160;cinq&#160;au&#160;niveau&#160;3&#160;de&#160;la&#160;tour.&#160;C’est&#160;un&#160;peux&#160;plus&#160;rapide<br/>avec&#160;DrRacket,&#160;mais&#160;pas&#160;tellement.&#160;Le&#160;poids&#160;des&#160;sous-couches&#160;d’interprétation&#160;est&#160;lourd.&#160;Dieu&#160;ne<br/>nous&#160;disperse&#160;pas&#160;ici&#160;par&#160;la&#160;confusion&#160;des&#160;langages,&#160;mais&#160;par&#160;la&#160;limitation&#160;de&#160;notre&#160;puissance&#160;de<br/>calcul<br/>
.<br/>
Voici&#160;le&#160;code&#160;complet&#160;de&#160;l’interprète&#160;au&#160;niveau&#160;1.&#160;La&#160;fonction&#160;d’évaluation&#160;n’utilise&#160;pas&#160;ici&#160;les<br/>
réifications&#160;des&#160;fonctions&#160;if,&#160;quote,&#160;begin.<br/>
(define&#160;evaluate<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
((if&#160;(not&#160;(pair?&#160;e))<br/>
(if&#160;(or&#160;(or&#160;(number?&#160;e)&#160;(string?&#160;e))&#160;(boolean?&#160;e))<br/>
eval-constante<br/>eval-variable)<br/>
(if&#160;(equal?&#160;(car&#160;e)&#160;’quote)<br/>
eval-quote<br/>(if&#160;(equal?&#160;(car&#160;e)&#160;’if)<br/>
eval-if<br/>
(if&#160;(equal?&#160;(car&#160;e)&#160;’begin)<br/>
eval-begin<br/>(if&#160;(equal?&#160;(car&#160;e)&#160;’define)<br/>
eval-assign<br/>(if&#160;(equal?&#160;(car&#160;e)&#160;’lambda)<br/>
eval-abstraction<br/>eval-application))))))<br/>
e&#160;r&#160;k&#160;)))<br/>
(define&#160;eval-constante<br/>
57<br/>
<hr/>
<a name=58></a>(lambda&#160;(e&#160;r&#160;k)<br/>
(k&#160;e)))<br/>
(define&#160;eval-quote<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(k&#160;(cadr&#160;e))))<br/>
(define&#160;eval-variable<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(get-pair&#160;e&#160;r<br/>(lambda&#160;(success-pair)<br/>
(k&#160;(cdr&#160;success-pair)))<br/>(lambda&#160;()<br/>(wrong&#160;&#34;symbol&#160;not&#160;bound&#160;&#34;&#160;e)))))<br/>
(define&#160;eval-if<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(evaluate&#160;(cadr&#160;e)&#160;r<br/>
(lambda&#160;(v)<br/>
(if&#160;v<br/>
(evaluate&#160;(caddr&#160;e)&#160;r&#160;k)<br/>(evaluate&#160;(cadddr&#160;e)&#160;r&#160;k))))))<br/>
(define&#160;eval-assign<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(evaluate&#160;(caddr&#160;e)&#160;r<br/>
(lambda&#160;(v)<br/>
(get-pair&#160;(cadr&#160;e)&#160;r<br/>
(lambda&#160;(success-pair)<br/>
(begin<br/>(set-cdr!&#160;success-pair&#160;v)<br/>(k&#160;(void))&#160;))<br/>
(lambda&#160;()<br/>
(begin<br/>
(set-cdr!&#160;global-env&#160;(cons&#160;(car&#160;global-env)(cdr&#160;global-env)))<br/>(set-car!&#160;global-env&#160;(cons&#160;(cadr&#160;e)&#160;v))<br/>(k&#160;(void)))))))))<br/>
(define&#160;eval-define<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(evaluate&#160;(caddr&#160;e)&#160;r<br/>(lambda&#160;(v)<br/>(update!&#160;(cadr&#160;e)&#160;r&#160;v)))))<br/>
(define&#160;eval-abstraction<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>(k&#160;(make-function&#160;(cadr&#160;e)&#160;(caddr&#160;e)&#160;r))))<br/>
(define&#160;get-pair<br/>
(lambda&#160;(id&#160;r&#160;success&#160;failure)<br/>
(find-pair&#160;id&#160;r<br/>
success<br/>(lambda&#160;()<br/>
(find-pair<br/>
id&#160;global-env&#160;success&#160;failure)&#160;))&#160;))<br/>
58<br/>
<hr/>
<a name=59></a>(define&#160;find-pair<br/>
(lambda&#160;(elt&#160;alist&#160;success&#160;failure)<br/>
(&#160;(lambda&#160;(assq-result)<br/>
(if&#160;assq-result<br/>
(success&#160;assq-result)<br/>(failure))&#160;)<br/>
(assq&#160;elt&#160;alist)&#160;)&#160;)&#160;)<br/>
(define&#160;make-function<br/>
(lambda&#160;(varl&#160;corps&#160;r)<br/>
(list&#160;’cloture&#160;varl&#160;corps&#160;r)))<br/>
(define&#160;eval-application<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(evaluate&#160;(car&#160;e)&#160;r<br/>
(lambda&#160;(proc)<br/>
(if&#160;(equal?&#160;(car&#160;proc)&#160;’reifier)<br/>
((reifier-to-cloture&#160;proc)&#160;(cdr&#160;e)&#160;r&#160;k)<br/>(evlis&#160;(cdr&#160;e)&#160;r<br/>
(lambda&#160;(args)<br/>
(apply-procedure&#160;proc&#160;args&#160;k))))))))<br/>
(define&#160;evlis<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(if&#160;(null?&#160;e)<br/>
(k&#160;’())<br/>(evaluate&#160;(car&#160;e)&#160;r<br/>
(lambda&#160;(v)<br/>
(evlis&#160;(cdr&#160;e)&#160;r<br/>
(lambda&#160;(w)<br/>
(k&#160;(cons&#160;v&#160;w)))))))))<br/>
(define&#160;eval-begin<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(eprogn&#160;(cdr&#160;e)&#160;r&#160;k)))<br/>
(define&#160;eprogn<br/>
(lambda&#160;(e&#160;r&#160;k)<br/>
(if&#160;(null?&#160;(cdr&#160;e))<br/>
(evaluate&#160;(car&#160;e)&#160;r&#160;k)<br/>(evaluate&#160;(car&#160;e)&#160;r&#160;(lambda&#160;(v)<br/>
(eprogn&#160;(cdr&#160;e)&#160;r&#160;k))))))<br/>
(define&#160;extend<br/>
(lambda&#160;(env&#160;variables&#160;values)<br/>
(if&#160;(or&#160;(null?&#160;variables)&#160;(null?&#160;values))<br/>
env<br/>(cons&#160;(cons&#160;(car&#160;variables)&#160;(car&#160;values))<br/>
(extend&#160;env&#160;(cdr&#160;variables)&#160;(cdr&#160;values))))))<br/>
(define&#160;apply-procedure<br/>
(lambda&#160;(proc&#160;args&#160;k)<br/>
(if&#160;(equal?&#160;(car&#160;proc)&#160;’cloture)<br/>
(eprogn&#160;(list&#160;(caddr&#160;proc))<br/>
(extend&#160;(cadddr&#160;proc)&#160;(cadr&#160;proc)&#160;args)<br/>k)<br/>
59<br/>
<hr/>
<a name=60></a>(k&#160;(apply-primitive&#160;(cadr&#160;proc)&#160;args)))))<br/>
(define&#160;apply-primitive<br/>
(lambda&#160;(name&#160;args)<br/>
(if&#160;(equal?&#160;name&#160;’car)<br/>
(car&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’or)<br/>
(or&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’cdr)<br/>
(cdr&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’cons)<br/>
(cons&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’set-car!)<br/>
(set-car!&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’set-cdr!)<br/>
(set-cdr!&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’memq)<br/>
(memq&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’assq)<br/>
(assq&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’=)<br/>
(=&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’+)<br/>
(+&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’-)<br/>
(-&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’*)<br/>
(*&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’null?)<br/>
(null?&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’not)<br/>
(not&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’symbol?)<br/>
(symbol?&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’list)<br/>
args<br/>
(if&#160;(equal?&#160;name&#160;’pair?)<br/>
(pair?&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’read)<br/>
(if&#160;(null?&#160;args)&#160;(read)&#160;(read&#160;(car&#160;args)))<br/>
(if&#160;(equal?&#160;name&#160;’eof-object?)<br/>
(eof-object?&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’close-input-port)<br/>
(close-input-port&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’newline)<br/>
(newline)<br/>
(if&#160;(equal?&#160;name&#160;’equal?)<br/>
(equal?&#160;(car&#160;args)&#160;(cadr&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’write)<br/>
(write&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’display)<br/>
(display&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’load)<br/>
(load&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’number?)<br/>
(number?&#160;(car&#160;args))<br/>
60<br/>
<hr/>
<a name=61></a>(if&#160;(equal?&#160;name&#160;’string?)<br/>
(string?&#160;(car&#160;args))<br/>
(if&#160;(equal?&#160;name&#160;’boolean?)<br/>
(boolean?&#160;(car&#160;args))<br/>
&#34;erreur&#160;apply&#160;primitive&#34;))))))))))))))))))))))))))))))<br/>
(define&#160;mapper<br/>
(lambda&#160;(f&#160;l)<br/>
(if&#160;(null?&#160;l)<br/>
’()<br/>(cons&#160;(f&#160;(car&#160;l))&#160;(mapper&#160;f&#160;(cdr&#160;l))))))<br/>
(define&#160;primitive-identifiers<br/>
(lambda&#160;()<br/>
’(placeholder&#160;car&#160;cdr&#160;cons&#160;+&#160;-&#160;*&#160;=&#160;set-car!&#160;set-cdr!&#160;memq&#160;assq&#160;null?&#160;equal?&#160;newline<br/>
display&#160;read&#160;symbol?&#160;list&#160;pair?&#160;not&#160;load&#160;or&#160;number?&#160;string?&#160;boolean?)))<br/>
(define&#160;make-primitive<br/>
(lambda&#160;(op)<br/>
(list&#160;’primitive&#160;op)))<br/>
(define&#160;reifier-to-cloture<br/>
(lambda&#160;(reifier)<br/>
(cons&#160;’cloture&#160;(cdr&#160;reifier))))<br/>
(define&#160;cloture-to-reifier<br/>
(lambda&#160;(cloture)<br/>
(cons&#160;’reifier&#160;(cdr&#160;cloture))))<br/>
(define&#160;make-reifier<br/>
(lambda&#160;(formals&#160;body&#160;r)<br/>
(list&#160;’reifier&#160;formals&#160;body&#160;r)))<br/>
(define&#160;global-env&#160;’())<br/>
(define&#160;initialize-global-env<br/>
(lambda&#160;()<br/>
(define&#160;global-env<br/>
(extend&#160;global-env<br/>
(primitive-identifiers)<br/>(mapper&#160;make-primitive<br/>
(primitive-identifiers))))))<br/>
(define&#160;openloop<br/>
(lambda&#160;(read-prompt&#160;write-prompt)<br/>
(begin<br/>(display&#160;read-prompt)<br/>(evaluate&#160;(read)&#160;’()<br/>
(lambda&#160;(v)<br/>
(begin<br/>(display&#160;write-prompt)<br/>(if&#160;(equal?&#160;v&#160;(void))<br/>
&#34;rien&#160;a&#160;afficher&#34;<br/>(display&#160;v))<br/>
(newline)<br/>(openloop&#160;read-prompt&#160;write-prompt)))))))<br/>
61<br/>
<hr/>
<a name=62></a>(define&#160;babel<br/>
(lambda&#160;()<br/>
(begin<br/>(set-car!&#160;global-env&#160;(cons&#160;’global-env&#160;global-env&#160;))<br/>(openloop&#160;&#34;i0&#160;&#34;&#160;&#34;i0&#160;&#34;))))<br/>
62<br/>
<hr/>
<a name=63></a><b>Chapitre&#160;4</b><br/>
<b>La&#160;compilation</b><br/>
<b>4.1</b><br/>
<b>Compilation&#160;des&#160;</b><i>λ</i><b>-termes&#160;en&#160;termes&#160;applicatifs</b><br/>
Il&#160;existe&#160;un&#160;formalisme&#160;appelé&#160;<i>Logique&#160;Combinatoire&#160;</i>qui&#160;permet&#160;de&#160;construire&#160;un&#160;calcul&#160;sans<br/>
variables&#160;liées.&#160;C’est&#160;surprenant,&#160;mais&#160;ces&#160;variables&#160;liées&#160;qui&#160;sont&#160;introduites&#160;par&#160;abstraction&#160;puis<br/>éliminées&#160;par&#160;application&#160;ne&#160;sont&#160;finalement&#160;pas&#160;essentielles&#160;pour&#160;le&#160;calcul.<br/>
Comment&#160;traduire&#160;une&#160;abstraction&#160;en&#160;termes&#160;applicatifs&#160;?&#160;Nous&#160;allons&#160;définir&#160;une&#160;traduction<br/>
<i>M&#160;</i>7→&#160;<i>M</i>@&#160;,&#160;ainsi&#160;qu’une&#160;traduction&#160;en&#160;sens&#160;inverse&#160;<i>A&#160;</i>7→&#160;<i>Aλ</i>.<br/>
L’idée&#160;est&#160;de&#160;partir&#160;sur&#160;les&#160;règles&#160;de&#160;traduction&#160;suivantes&#160;:<br/>
d<i>λx.x</i>e<br/>
=<br/>
<i>I</i><br/>
d<i>λx.M&#160;</i>e<br/>
=<br/>
<i>KM</i><br/>
(<i>x&#160;/</i><br/>
∈&#160;<i>M&#160;</i>)<br/>
d<i>λx.M&#160;N&#160;</i>e&#160;=&#160;<i>S</i>d<i>λx.M&#160;</i>ed<i>λx.N&#160;</i>e<br/>
(<i>x&#160;</i>∈&#160;<i>M,&#160;N&#160;</i>)<br/>
où&#160;d<i>T&#160;</i>e&#160;représente&#160;le&#160;<i>λ</i>-terme&#160;<i>T&#160;</i>sans&#160;lambda&#160;abstraction.<br/>
Nous&#160;serions&#160;tentés&#160;de&#160;vouloir&#160;faire&#160;directement&#160;la&#160;traduction&#160;en&#160;utilisant&#160;ces&#160;règles.&#160;Il&#160;nous&#160;faut<br/>
cependant&#160;passer&#160;par&#160;un&#160;opérateur&#160;d’abstraction&#160;<i>A&#160;</i>7→&#160;[<i>x</i>]<i>.A&#160;</i>qui&#160;permettra&#160;de&#160;&#34;supprimer&#34;&#160;toutes<br/>les&#160;lambdas&#160;en&#160;profondeur&#160;dans&#160;le&#160;<i>λ</i>-terme,&#160;puis&#160;seulement&#160;ensuite,&#160;nous&#160;pourrons&#160;utiliser&#160;les&#160;trois<br/>règles&#160;ci-dessous&#160;:<br/>
[<i>x</i>]<i>.x</i><br/>
≡&#160;<i>I</i><br/>
[<i>x</i>]<i>.A</i><br/>
≡&#160;<i>KA</i><br/>
(<i>x&#160;/</i><br/>
∈&#160;<i>A</i>)<br/>
[<i>x</i>]<i>.AB</i><br/>
≡&#160;<i>S</i>([<i>x</i>]<i>.A</i>)([<i>x</i>]<i>.B</i>)<br/>
(<i>x&#160;</i>∈&#160;<i>A,&#160;B</i>)<br/>
Les&#160;combinateurs&#160;<i>I,&#160;K&#160;</i>et&#160;<i>S&#160;</i>sont&#160;définis&#160;comme&#160;ceci&#160;:<br/>
<i>I</i><br/>
=<br/>
<i>λx.x</i><br/>
<i>K</i><br/>
=<br/>
<i>λxy.x</i><br/>
<i>S</i><br/>
=<br/>
<i>λxyz.xz</i>(<i>yz</i>)<br/>
Et&#160;voici&#160;la&#160;définition&#160;de&#160;la&#160;traduction&#160;des&#160;<i>λ</i>-termes&#160;en&#160;termes&#160;applicatifs.<br/>
(<i>x</i>)@<br/>
≡&#160;<i>x</i><br/>
(<i>P&#160;Q</i>)@<br/>
≡&#160;(<i>P&#160;</i>)@(<i>Q</i>)@<br/>
(<i>λx.M&#160;</i>)@&#160;≡&#160;[<i>x</i>]<i>.</i>(<i>M&#160;</i>)@<br/>
Dans&#160;la&#160;définition&#160;de&#160;notre&#160;type&#160;applicatif&#160;ski,&#160;nous&#160;incluons&#160;aussi&#160;notre&#160;opérateur&#160;[<i>x</i>]<i>.A&#160;</i>avec<br/>
le&#160;constructeur&#160;Op.<br/>
63<br/>
<hr/>
<a name=64></a>type&#160;ski&#160;=<br/>
|&#160;Varia&#160;of&#160;string<br/>
|&#160;I<br/>
|&#160;K<br/>
|&#160;S<br/>
|&#160;Appl&#160;of&#160;ski*ski<br/>
|&#160;Op&#160;of&#160;string&#160;*&#160;ski&#160;;;<br/>
exception&#160;SkiExec<br/>
let&#160;rec&#160;lambda_ski&#160;=&#160;function<br/>
|&#160;Lam(x,&#160;t)&#160;-&gt;&#160;lambda_ski_op&#160;(Op(x,&#160;lambda_ski&#160;t))<br/>
|&#160;Var(x)&#160;-&gt;&#160;Varia(x)<br/>
|&#160;App(m,n)&#160;-&gt;&#160;Appl(lambda_ski&#160;m,&#160;lambda_ski&#160;n)<br/>
and&#160;lambda_ski_op&#160;=&#160;function<br/>
|&#160;Op(x,Varia&#160;y)&#160;when&#160;x=y&#160;-&gt;&#160;I<br/>
|&#160;Op(x,&#160;t)&#160;when&#160;not&#160;(mem&#160;x&#160;(var&#160;t))&#160;-&gt;&#160;Appl(K,&#160;t)<br/>
|&#160;Op(x,&#160;Appl(m,&#160;n))<br/>
when&#160;(mem&#160;x&#160;(var&#160;m))&#160;||&#160;(mem&#160;x&#160;(var&#160;n))<br/>
-&gt;&#160;Appl(Appl(S,&#160;(lambda_ski_op&#160;(Op(x,m)))),&#160;(lambda_ski_op&#160;(Op(x,n))))<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;SkiErreur<br/>
A&#160;titre&#160;d’exemple,&#160;traduisons&#160;notre&#160;combinateur&#160;<i>y&#160;</i>en&#160;termes&#160;applicatifs&#160;:<br/>
utop&#160;#&#160;print_ski&#160;(lambda_ski&#160;y)&#160;;;<br/>
((S((S((S(KS))((S(KK))I)))(K((SI)I))))((S((S(KS))((S(KK))I)))(K((SI)I))))<br/>
Une&#160;fois&#160;le&#160;code&#160;compilé,&#160;son&#160;exécution&#160;sera&#160;réalisée&#160;avec&#160;les&#160;règles&#160;de&#160;réécriture&#160;:<br/>
<i>Ix</i><br/>
−→<br/>
<i>x</i><br/>
<i>Kxy</i><br/>
−→<br/>
<i>x</i><br/>
<i>Sxyz</i><br/>
−→&#160;<i>xz</i>(<i>yz</i>)<br/>
Voici&#160;une&#160;première&#160;version&#160;de&#160;l’exécution&#160;de&#160;ces&#160;règles&#160;de&#160;réécriture.&#160;Ce&#160;code&#160;un&#160;est&#160;peu&#160;bourrin<br/>car&#160;on&#160;appelle&#160;la&#160;fonction&#160;tant&#160;que&#160;le&#160;terme&#160;n’est&#160;pas&#160;réduit.<br/>
let&#160;rec&#160;exec_aux&#160;=&#160;function<br/>
|&#160;Appl(I,&#160;x)&#160;-&gt;&#160;exec_aux&#160;x<br/>
|&#160;Appl(Appl(K,&#160;x),&#160;y)&#160;-&gt;&#160;exec_aux&#160;x<br/>
|&#160;Appl(Appl(Appl(S,x),y),z)&#160;-&gt;&#160;Appl(Appl(exec_aux&#160;x,&#160;exec_aux&#160;z),&#160;Appl(exec_aux&#160;y,exec_aux&#160;z))<br/>
|&#160;Appl(x,y)&#160;-&gt;&#160;Appl(exec_aux&#160;x,&#160;exec_aux&#160;y)<br/>
|&#160;Varia&#160;x&#160;-&gt;&#160;Varia&#160;x<br/>
|&#160;I&#160;-&gt;&#160;I<br/>
|&#160;K&#160;-&gt;&#160;K<br/>
|&#160;S&#160;-&gt;&#160;S<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;SkiErreur<br/>
and<br/>
exec&#160;t&#160;=<br/>
let&#160;r&#160;=&#160;exec_aux&#160;t&#160;in<br/>
if&#160;r=t&#160;then&#160;r&#160;else&#160;exec_aux&#160;r<br/>
64<br/>
<hr/>
<a name=65></a>Voici&#160;une&#160;version&#160;plus&#160;élégante&#160;qui&#160;retourne&#160;la&#160;forme&#160;réduite.<br/>
let&#160;rec&#160;ski_norm&#160;m&#160;=<br/>
match&#160;m&#160;with<br/>
|&#160;S&#160;|&#160;K&#160;|&#160;I&#160;-&gt;&#160;m<br/>
|&#160;Varia&#160;x&#160;-&gt;&#160;m<br/>
|&#160;Appl&#160;(m0,&#160;m1)&#160;-&gt;<br/>
match&#160;ski_norm&#160;m0&#160;with<br/>
|&#160;I&#160;-&gt;&#160;ski_norm&#160;m1<br/>
|&#160;Appl&#160;(K,&#160;m’)&#160;-&gt;&#160;m’<br/>
|&#160;Appl&#160;(Appl&#160;(S,&#160;m3),&#160;m2)&#160;-&gt;&#160;ski_norm&#160;(Appl&#160;(Appl&#160;(m3,&#160;m1),&#160;Appl&#160;(m2,&#160;m1)))<br/>
|&#160;autre&#160;-&gt;&#160;Appl&#160;(autre,&#160;ski_norm&#160;m1);;<br/>
La&#160;traduction&#160;en&#160;sens&#160;inverse&#160;<i>A&#160;</i>7→&#160;<i>Aλ&#160;</i>se&#160;fait&#160;naturellement&#160;par&#160;la&#160;fonction&#160;ML&#160;ci-dessous&#160;:<br/>
let&#160;rec&#160;ski_lambda&#160;=&#160;function<br/>
|&#160;I&#160;-&gt;&#160;Lam(&#34;x&#34;,&#160;Var&#160;&#34;x&#34;)<br/>
|&#160;K&#160;-&gt;&#160;Lam(&#34;x&#34;,&#160;Lam(&#34;y&#34;,&#160;Var&#160;&#34;x&#34;))<br/>
|&#160;S&#160;-&gt;&#160;Lam(&#34;x&#34;,&#160;Lam(&#34;y&#34;,&#160;Lam(&#34;z&#34;,&#160;App(App(Var&#160;&#34;x&#34;,&#160;Var&#160;&#34;z&#34;),&#160;App(Var&#160;&#34;y&#34;,&#160;Var&#160;&#34;z&#34;)))))<br/>
|&#160;Varia(x)&#160;-&gt;&#160;Var(x)<br/>
|&#160;Appl(m,n)&#160;-&gt;&#160;App(ski_lambda&#160;m,ski_lambda&#160;n)<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;SkiErreur<br/>
Utilisons&#160;l’exemple&#160;de&#160;la&#160;factorielle,&#160;exemple&#160;complexe&#160;car&#160;il&#160;comporte&#160;les&#160;représentations&#160;en<br/>
<i>λ</i>-termes&#160;du&#160;combinateur&#160;<i>Y&#160;</i>,&#160;de&#160;la&#160;condition&#160;<i>if-then-else</i>,&#160;des&#160;entiers&#160;<i>Church&#160;</i>ainsi&#160;que&#160;les&#160;opérations<br/><i>plus,&#160;moins,&#160;mult</i>.&#160;<a href="documents.html#65">1</a><br/>
print_terme&#160;(betaNormal&#160;(ski_lambda&#160;(exec&#160;(lambda_ski&#160;(App(fact,&#160;trois))))))&#160;;;<br/>
λz.λz0.z&#160;(z&#160;(z&#160;(z&#160;(z&#160;(z&#160;z0)&#160;)&#160;)&#160;)&#160;)&#160;-&#160;:&#160;unit&#160;=&#160;()<br/>
Nous&#160;avons&#160;les&#160;deux&#160;propriétés&#160;suivantes&#160;que&#160;nous&#160;ne&#160;démontrerons&#160;pas.<br/>
∗<br/>
∗<br/>
1.&#160;Si&#160;<i>A&#160;</i>−→<i>β&#160;B</i>,&#160;alors&#160;<i>Aλ&#160;</i>−→<i>β&#160;Bλ</i><br/>
∗<br/>
2.&#160;(<i>M</i>@)<i>λ&#160;</i>−→<i>β&#160;M</i><br/>
Cependant,&#160;nous&#160;aurons&#160;parfois&#160;<i>M&#160;</i>−→<i>β&#160;N&#160;</i>sans&#160;que&#160;<i>M</i>@&#160;−→@&#160;<i>N</i>@<br/>
∗<br/>
Par&#160;exemple&#160;<i>SK&#160;</i>−→<i>β&#160;</i>0&#160;mais&#160;<i>SK&#160;</i>est&#160;irréductible&#160;pour&#160;−→@<br/>
utop&#160;#&#160;betaNormalPrint&#160;sk&#160;;;<br/>
[1]&#160;-&gt;&#160;λx.λy.λz.x&#160;z&#160;(y&#160;z)<br/>
λx.λy.x<br/>
[2]&#160;-&gt;&#160;λy.λz.λx.λy.x&#160;z&#160;(y&#160;z)<br/>
[3]&#160;-&gt;&#160;λy.λz.λy.z&#160;(y&#160;z)<br/>
[4]&#160;-&gt;&#160;λy.λz.z<br/>
-&#160;:&#160;unit&#160;-&gt;&#160;unit&#160;=&#160;&lt;fun&gt;<br/>
utop&#160;#&#160;exec&#160;(Appl(S,K))&#160;;;<br/>
-&#160;:&#160;ski&#160;=&#160;Appl&#160;(S,&#160;K)<br/>
1.&#160;Ce&#160;résultat&#160;est&#160;obtenu&#160;après&#160;quelques&#160;minutes...<br/>
65<br/>
<hr/>
<a name=66></a>D’autre&#160;part,&#160;on&#160;n’a&#160;pas&#160;nécessairement&#160;(<i>Aλ</i>)@&#160;=@&#160;<i>A</i>.<br/>Par&#160;exemple&#160;(<i>Kλ</i>)@&#160;≡&#160;<i>S</i>(<i>KK</i>)<i>I&#160;</i>ne&#160;se&#160;réduit&#160;pas&#160;en&#160;<i>K</i>.<br/>
utop&#160;#&#160;exec&#160;(lambda_ski&#160;k)&#160;;;<br/>
-&#160;:&#160;ski&#160;=&#160;Appl&#160;(Appl&#160;(S,&#160;Appl&#160;(K,&#160;K)),&#160;I)<br/>
betaNormalPrint&#160;(App(App(s,&#160;App&#160;(k,&#160;k)),&#160;i))&#160;;;<br/>
[1]&#160;-&gt;&#160;λx.λy.λz.x&#160;z&#160;(y&#160;z)<br/>
(λx.λy.x&#160;λx.λy.x)<br/>
λx.x<br/>
[2]&#160;-&gt;&#160;λy.λz.λx.λy.x&#160;λx.λy.x&#160;z&#160;(y&#160;z)<br/>
λx.x<br/>
[3]&#160;-&gt;&#160;λz.λx.λy.x&#160;λx.λy.x&#160;z&#160;(λx.x&#160;z)<br/>
[4]&#160;-&gt;&#160;λz.λy.λx.λy.x&#160;z&#160;(λx.x&#160;z)<br/>
[5]&#160;-&gt;&#160;λz.λx.λy.x&#160;(λx.x&#160;z)<br/>
[6]&#160;-&gt;&#160;λz.λy.λx.x&#160;z<br/>
[7]&#160;-&gt;&#160;λz.λy.z<br/>
-&#160;:&#160;unit&#160;-&gt;&#160;unit&#160;=&#160;&lt;fun&gt;<br/>
∗<br/>
On&#160;peut&#160;constater&#160;que&#160;(<i>SKK</i>)<i>x&#160;</i>−→<i>β&#160;x</i>,&#160;donc&#160;le&#160;terme&#160;<i>SKK&#160;</i>joue&#160;le&#160;même&#160;rôle&#160;que&#160;la&#160;constante&#160;<i>I</i>.<br/>
let&#160;skk&#160;=&#160;Appl(Appl(S,K),K)&#160;;;<br/>
exec&#160;(Appl(skk,&#160;Varia&#160;&#34;x&#34;))&#160;;;<br/>
-&#160;:&#160;ski&#160;=&#160;Varia&#160;&#34;x&#34;<br/>
ou&#160;plus&#160;directement&#160;en&#160;CAML&#160;:<br/>
utop&#160;#<br/>
let&#160;k&#160;x&#160;y&#160;=&#160;x<br/>
and&#160;s&#160;x&#160;y&#160;z&#160;=&#160;(x&#160;z&#160;(y&#160;z))<br/>
in&#160;(s&#160;k&#160;k)&#160;&#34;toto&#160;&#34;;;<br/>
-&#160;:&#160;string&#160;=&#160;&#34;toto&#160;&#34;<br/>
La&#160;base&#160;combinatoire&#160;{<i>S,&#160;K</i>}&#160;suffit&#160;donc&#160;au&#160;<i>λ</i>-calcul.&#160;Une&#160;base&#160;à&#160;un&#160;seul&#160;élément&#160;existerait&#160;même.&#160;.&#160;.<br/>
<b>La&#160;correspondance&#160;de&#160;Curry-Howard</b><br/>
Dans&#160;un&#160;<i>λ</i>-calcul&#160;typé,&#160;les&#160;types&#160;des&#160;combinateurs&#160;<i>K&#160;</i>et&#160;<i>S&#160;</i>correspondent&#160;aux&#160;deux&#160;axiomes&#160;des<br/>
systèmes&#160;hilbertiens&#160;:<br/>
<i>S&#160;</i>:&#160;(<i>φ&#160;</i>⇒&#160;(<i>χ&#160;</i>⇒&#160;<i>ψ</i>))&#160;⇒&#160;((<i>φ&#160;</i>⇒&#160;<i>χ</i>)&#160;⇒&#160;(<i>φ&#160;</i>⇒&#160;<i>ψ</i>))<br/>
<i>K&#160;</i>:&#160;<i>φ&#160;</i>⇒&#160;(<i>ψ&#160;</i>⇒&#160;<i>φ</i>)<br/>
L’inférence&#160;de&#160;type&#160;OCAML&#160;nous&#160;donne&#160;en&#160;effet&#160;k&#160;:&#160;’a&#160;-&gt;&#160;’b&#160;-&gt;&#160;’a&#160;et<br/>
s&#160;:&#160;(’a&#160;-&gt;&#160;’b&#160;-&gt;&#160;’c)&#160;-&gt;&#160;(’a&#160;-&gt;&#160;’b)&#160;-&gt;&#160;’a&#160;-&gt;&#160;’c<br/>
<i>logique&#160;combinatoire</i><br/>
<i>système&#160;hilbertien</i><br/>
type<br/>
formule<br/>
application&#160;(<b>App</b>)<br/>
modus&#160;ponens<br/>
combinateurs&#160;<i>S&#160;</i>et&#160;<i>K</i><br/>
noms&#160;des&#160;axiomes&#160;<i>S&#160;</i>et&#160;<i>K</i><br/>
type&#160;des&#160;combinateurs&#160;<i>S&#160;</i>et&#160;<i>K</i><br/>
axiomes&#160;<i>S&#160;</i>et&#160;<i>K</i><br/>
variable<br/>
nom&#160;d’une&#160;hypothèse<br/>
type&#160;d’une&#160;variable<br/>
hypothèse<br/>
66<br/>
<hr/>
<a name=67></a>L’unique&#160;règle&#160;d’inférence,&#160;la&#160;règle&#160;du&#160;modus&#160;ponens,&#160;est&#160;ainsi&#160;modélisée&#160;par&#160;l’application<br/>
<i>φ&#160;</i>⇒&#160;<i>ψ&#160;φ</i><br/>
(<i>App</i>)&#160;:<br/>
<i>ψ</i><br/>
Dans&#160;le&#160;système&#160;hilbertien,&#160;il&#160;n’y&#160;a&#160;pas&#160;de&#160;règle&#160;d’introduction&#160;(<i>I</i>⇒)&#160;:&#160;[<i>φ</i>]&#160;<i>χ&#160;</i>qui&#160;équivalait&#160;à&#160;une<br/>
<i>φ</i>⇒<i>χ</i><br/>
abstraction&#160;<i>λxφ.yψ</i><br/>
Le&#160;modus&#160;ponens&#160;et&#160;les&#160;axiomes&#160;permettent&#160;de&#160;simuler&#160;(<i>I</i>⇒)&#160;de&#160;la&#160;même&#160;façon&#160;que&#160;l’abstraction<br/>
du&#160;<i>λ</i>-calcul&#160;est&#160;simulée&#160;à&#160;l’aide&#160;des&#160;constantes&#160;<i>S&#160;</i>et&#160;<i>K&#160;</i>en&#160;logique&#160;combinatoire.<br/>
<b>4.2</b><br/>
<b>Compilation&#160;basique&#160;vers&#160;une&#160;machine&#160;à&#160;pile</b><br/>
Nous&#160;utilisons&#160;l’implémentation&#160;ci-dessous&#160;pour&#160;la&#160;représentation&#160;des&#160;piles&#160;sous&#160;formes&#160;de&#160;listes<br/>
mutables.<br/>
type&#160;’a&#160;pile&#160;=&#160;’a&#160;list&#160;ref&#160;;;<br/>
let&#160;empiler&#160;x&#160;p&#160;=&#160;p&#160;:=&#160;x&#160;::&#160;!p&#160;;;<br/>
exception&#160;Vide&#160;;;<br/>
let&#160;depiler&#160;p&#160;=<br/>
match&#160;!p&#160;with<br/>
|&#160;[]&#160;-&gt;&#160;raise&#160;Vide<br/>
|x::t&#160;-&gt;&#160;p:=t&#160;;&#160;x&#160;;;<br/>
let&#160;sommet&#160;p&#160;=<br/>
match&#160;!p&#160;with<br/>
|&#160;[]&#160;-&gt;&#160;raise&#160;Vide<br/>
|&#160;x::t&#160;-&gt;&#160;x<br/>
;;<br/>
La&#160;machine&#160;à&#160;pile&#160;exécutera&#160;les&#160;instructions&#160;suivantes&#160;:<br/>
[&#34;EMPILER&#34;;&#160;&#34;nombre&#34;],[&#34;ADD&#34;],&#160;[&#34;SUB&#34;],&#160;[&#34;MUL&#34;],&#160;[&#34;STOP&#34;]<br/>
La&#160;lecture&#160;d’une&#160;instruction&#160;est&#160;réalisée&#160;par&#160;la&#160;fonction&#160;fetch.&#160;Cette&#160;fonction&#160;parcourt&#160;de<br/>
manière&#160;linéaire&#160;le&#160;code&#160;représenté&#160;par&#160;un&#160;<i>array</i>.&#160;Chaque&#160;fetch&#160;incrémente&#160;la&#160;variable&#160;pc&#160;qui<br/>représente&#160;le&#160;<i>program&#160;counter</i>.<br/>
exception&#160;Erreur&#160;;;<br/>
let&#160;executer&#160;code&#160;=<br/>
let&#160;pc&#160;=&#160;ref&#160;0&#160;in<br/>
let&#160;pile&#160;=&#160;ref&#160;[]&#160;in<br/>
let&#160;fetch&#160;code<br/>
=<br/>
begin<br/>
pc&#160;:=&#160;!pc&#160;+&#160;1&#160;;<br/>
Array.get&#160;code&#160;(!pc&#160;-&#160;1)<br/>
67<br/>
<hr/>
<a name=68></a>end<br/>
in<br/>
let&#160;rec&#160;exec&#160;()&#160;=<br/>
let&#160;instr&#160;=&#160;fetch&#160;code&#160;in<br/>
match&#160;instr&#160;with<br/>
|&#160;[&#34;EMPILER&#34;;&#160;n]&#160;-&gt;&#160;(&#160;empiler&#160;(int_of_string&#160;n)&#160;pile&#160;;&#160;exec&#160;()&#160;)<br/>
|&#160;[&#34;ADD&#34;]&#160;-&gt;&#160;let&#160;v2&#160;=&#160;depiler&#160;pile&#160;in&#160;let&#160;v1&#160;=&#160;depiler&#160;pile&#160;in<br/>
(&#160;empiler&#160;(v1&#160;+&#160;v2)&#160;pile&#160;;&#160;exec&#160;()&#160;)<br/>
|&#160;[&#34;SUB&#34;]&#160;-&gt;&#160;let&#160;v2&#160;=&#160;depiler&#160;pile&#160;in&#160;let&#160;v1&#160;=&#160;depiler&#160;pile&#160;in<br/>
(&#160;empiler&#160;(v1&#160;-&#160;v2)&#160;pile&#160;;&#160;exec&#160;()&#160;)<br/>
|&#160;[&#34;MUL&#34;]&#160;-&gt;&#160;let&#160;v2&#160;=&#160;depiler&#160;pile&#160;in&#160;let&#160;v1&#160;=&#160;depiler&#160;pile&#160;in<br/>
(&#160;empiler&#160;(v1&#160;*&#160;v2)&#160;pile&#160;;&#160;exec&#160;()&#160;)<br/>
|&#160;[&#34;STOP&#34;]&#160;-&gt;&#160;print_int&#160;(sommet&#160;pile)<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;Erreur<br/>
in&#160;exec&#160;()<br/>
Voici&#160;l’exécution&#160;de&#160;la&#160;machine&#160;à&#160;pile&#160;:<br/>
let&#160;code&#160;=&#160;[|&#160;[&#34;EMPILER&#34;;&#160;&#34;10&#34;]&#160;;[&#34;EMPILER&#34;;&#160;&#34;15&#34;]&#160;;&#160;[&#34;ADD&#34;]&#160;;<br/>
[&#34;EMPILER&#34;;&#160;&#34;4&#34;]&#160;;&#160;[&#34;MUL&#34;]&#160;;&#160;[&#34;STOP&#34;]&#160;|]&#160;;;<br/>
#&#160;executer&#160;code&#160;;;<br/>
#&#160;100-&#160;:&#160;unit&#160;=&#160;()<br/>
<b>4.2.1</b><br/>
<b>Certification&#160;de&#160;la&#160;compilation&#160;avec&#160;le&#160;langage&#160;COQ</b><br/>
<i>Quod&#160;erat&#160;demonstrandum.</i><br/>
<i>e</i><br/>
<i>c</i><br/>
sémantique&#160;du&#160;compilateur<br/>
séman<br/>
séman<br/>
tique<br/>
tique<br/>
de<br/>
du<br/>
la<br/>
langage<br/>
mac<br/>
hine<br/>
∀<i>e,&#160;eval</i>(<i>e</i>)&#160;=&#160;<i>exe</i>(<i>compile&#160;e</i>)<br/>
<i>v</i>1<br/>
<i>v</i>2<br/>
<i>v</i>1&#160;=&#160;<i>v</i>2<br/>
Require&#160;Import&#160;<i>Arith</i>.<br/>
Require&#160;Import&#160;<i>ZArith</i>.<br/>
Require&#160;Import&#160;<i>Bool</i>.<br/>
68<br/>
<hr/>
<a name=69></a>Require&#160;Import&#160;<i>List</i>.<br/>
Inductive&#160;<i>exp&#160;</i>:&#160;Set&#160;:=<br/>
|&#160;<i>Const&#160;</i>:&#160;<i>nat&#160;</i>→&#160;<i>exp<br/></i>|&#160;<i>Fois&#160;</i>:&#160;<i>exp&#160;</i>→&#160;<i>exp&#160;</i>→&#160;<i>exp<br/></i>|&#160;<i>Plus&#160;</i>:&#160;<i>exp&#160;</i>→&#160;<i>exp&#160;</i>→&#160;<i>exp</i>.<br/>
Fixpoint&#160;<i>expEval&#160;</i>(<i>e&#160;</i>:<i>exp</i>)&#160;:&#160;<i>nat&#160;</i>:=<br/>
match&#160;<i>e&#160;</i>with<br/>|&#160;<i>Const&#160;n&#160;</i>⇒&#160;<i>n<br/></i>|&#160;<i>Fois&#160;e1&#160;e2&#160;</i>⇒&#160;<i>mult&#160;</i>(<i>expEval&#160;e1&#160;</i>)&#160;(<i>expEval&#160;e2&#160;</i>)<br/>|&#160;<i>Plus&#160;e1&#160;e2&#160;</i>⇒&#160;<i>plus&#160;</i>(<i>expEval&#160;e1&#160;</i>)&#160;(<i>expEval&#160;e2&#160;</i>)<br/>end.<br/>
Inductive&#160;<i>instr&#160;</i>:&#160;Set&#160;:=<br/>
|&#160;<i>EMPILER&#160;</i>:&#160;<i>nat&#160;</i>→&#160;<i>instr<br/></i>|&#160;<i>ADD&#160;</i>:&#160;<i>instr<br/></i>|&#160;<i>MUL&#160;</i>:&#160;<i>instr</i><br/>
.<br/>
Definition&#160;<i>programme&#160;</i>:=&#160;<i>list&#160;instr</i>.<br/>
Definition&#160;<i>pile&#160;</i>:=&#160;<i>list&#160;nat</i>.<br/>
Definition&#160;<i>instrExec&#160;</i>(<i>i&#160;</i>:<i>instr&#160;</i>)&#160;(<i>s&#160;</i>:&#160;<i>pile</i>)&#160;:&#160;<i>option&#160;pile&#160;</i>:=<br/>
match&#160;<i>i&#160;</i>with<br/>|&#160;<i>EMPILER&#160;n&#160;</i>⇒&#160;<i>Some&#160;</i>(<i>n&#160;</i>:&#160;:&#160;<i>s</i>)<br/>|&#160;<i>ADD&#160;</i>⇒<br/>
match&#160;<i>s&#160;</i>with<br/>|&#160;<i>arg1&#160;</i>:&#160;:&#160;<i>arg2&#160;</i>:&#160;:&#160;<i>s’&#160;</i>⇒&#160;<i>Some&#160;</i>(<i>expEval&#160;</i>(<i>Plus&#160;</i>(<i>Const</i>(<i>arg1&#160;</i>))&#160;(<i>Const</i>(<i>arg2&#160;</i>)))&#160;:&#160;:&#160;<i>s’</i>)<br/>|<br/>
⇒&#160;<i>None</i><br/>
end<br/>
|&#160;<i>MUL&#160;</i>⇒<br/>
match&#160;<i>s&#160;</i>with<br/>|&#160;<i>arg1&#160;</i>:&#160;:&#160;<i>arg2&#160;</i>:&#160;:&#160;<i>s’&#160;</i>⇒&#160;<i>Some&#160;</i>(<i>expEval&#160;</i>(<i>Fois&#160;</i>(<i>Const</i>(<i>arg1&#160;</i>))&#160;(<i>Const</i>(<i>arg2&#160;</i>)))&#160;:&#160;:<i>s’</i>)<br/>|<br/>
⇒&#160;<i>None</i><br/>
end<br/>
end.<br/>
Fixpoint&#160;<i>progExec&#160;</i>(<i>p&#160;</i>:<i>programme</i>)&#160;(<i>s&#160;</i>:<i>pile</i>)&#160;:&#160;<i>option&#160;pile&#160;</i>:=<br/>
match&#160;<i>p&#160;</i>with<br/>|&#160;<i>nil&#160;</i>⇒&#160;<i>Some&#160;s<br/></i>|&#160;<i>i&#160;</i>:&#160;:&#160;<i>p’&#160;</i>⇒<br/>
match&#160;<i>instrExec&#160;i&#160;s&#160;</i>with<br/>|&#160;<i>None&#160;</i>⇒&#160;<i>None<br/></i>|&#160;<i>Some&#160;s’&#160;</i>⇒&#160;<i>progExec&#160;p’&#160;s’<br/></i>end<br/>
end.<br/>
Fixpoint&#160;<i>compile&#160;</i>(<i>e&#160;</i>:<i>exp</i>)&#160;:&#160;<i>programme&#160;</i>:=<br/>
match&#160;<i>e&#160;</i>with<br/>|&#160;<i>Const&#160;n&#160;</i>⇒&#160;<i>EMPILER&#160;n&#160;</i>:&#160;:&#160;<i>nil</i><br/>
69<br/>
<hr/>
<a name=70></a>|&#160;<i>Plus&#160;e1&#160;e2&#160;</i>⇒&#160;<i>compile&#160;e2&#160;</i>++&#160;<i>compile&#160;e1&#160;</i>++&#160;<i>ADD&#160;</i>:&#160;:&#160;<i>nil<br/></i>|&#160;<i>Fois&#160;e1&#160;e2&#160;</i>⇒&#160;<i>compile&#160;e2&#160;</i>++&#160;<i>compile&#160;e1&#160;</i>++&#160;<i>MUL&#160;</i>:&#160;:&#160;<i>nil<br/></i>end&#160;.<br/>
Eval&#160;compute&#160;in&#160;(<i>compile&#160;</i>(<i>Const&#160;</i>1999))&#160;.<br/>
Eval&#160;compute&#160;in&#160;(<i>compile&#160;</i>(<i>Fois&#160;</i>(<i>Plus&#160;</i>(<i>Const&#160;</i>1999)&#160;(<i>Const&#160;</i>1))&#160;(<i>Const&#160;</i>5)))&#160;.<br/>
Eval&#160;compute&#160;in&#160;(&#160;<i>progExec&#160;</i>(<i>compile&#160;</i>(<i>Fois&#160;</i>(<i>Plus&#160;</i>(<i>Const&#160;</i>1999)&#160;(<i>Const&#160;</i>1))&#160;(<i>Const&#160;</i>5)))&#160;<i>nil</i>)&#160;.<br/>
Lemma&#160;<i>compile&#160;correct&#160;lemme&#160;</i>:&#160;∀&#160;(<i>e&#160;</i>:<i>exp</i>)&#160;(<i>p&#160;</i>:&#160;<i>programme</i>)&#160;(<i>s&#160;</i>:&#160;<i>pile</i>),<br/>
<i>progExec&#160;</i>(<i>compile&#160;e</i>++<i>p</i>)&#160;<i>s&#160;</i>=&#160;<i>progExec&#160;p&#160;</i>(<i>expEval&#160;e&#160;</i>:&#160;:<i>s</i>)<br/>
.<br/>
induction&#160;<i>e</i>.<br/>
intros.<br/>
unfold&#160;<i>compile</i>.<br/>
unfold&#160;<i>expEval</i>.<br/>
unfold&#160;<i>progExec&#160;</i>at&#160;1.<br/>
simpl.<br/>
fold&#160;<i>progExec</i>.<br/>
reflexivity.<br/>
intros.<br/>
unfold&#160;<i>compile</i>.&#160;fold&#160;<i>compile</i>.<br/>
unfold&#160;<i>expEval</i>.&#160;fold&#160;<i>expEval</i>.<br/>
rewrite&#160;<i>app&#160;assoc&#160;reverse</i>.<br/>
rewrite&#160;<i>IHe2</i>.&#160;rewrite&#160;<i>app&#160;assoc&#160;reverse</i>.<br/>
rewrite&#160;<i>IHe1</i>.<br/>
unfold&#160;<i>progExec&#160;</i>at&#160;1.&#160;simpl.&#160;fold&#160;<i>progExec</i>.&#160;reflexivity.<br/>
intros.<br/>
unfold&#160;<i>compile</i>.&#160;fold&#160;<i>compile</i>.<br/>
rewrite&#160;<i>app&#160;assoc&#160;reverse</i>.&#160;rewrite&#160;<i>IHe2</i>.<br/>
rewrite&#160;<i>app&#160;assoc&#160;reverse</i>.<br/>
unfold&#160;<i>progExec&#160;</i>at&#160;1.&#160;simpl.&#160;fold&#160;<i>progExec</i>.<br/>
rewrite&#160;<i>IHe1</i>.<br/>
unfold&#160;<i>progExec&#160;</i>at&#160;1.&#160;simpl.&#160;fold&#160;<i>progExec</i>.&#160;reflexivity.<br/>
Qed.<br/>
Theorem&#160;<i>compile&#160;correct&#160;</i>:&#160;∀&#160;<i>e&#160;</i>:&#160;<i>exp</i>,&#160;<i>Some&#160;</i>((<i>expEval&#160;e</i>)&#160;:&#160;:&#160;<i>nil</i>)&#160;=&#160;(<i>progExec&#160;</i>(<i>compile&#160;e</i>)&#160;<i>nil</i>).<br/>
intros.<br/>
rewrite&#160;(<i>app&#160;nil&#160;end&#160;</i>(<i>compile&#160;e</i>)).<br/>
rewrite&#160;<i>compile&#160;correct&#160;lemme</i>.<br/>
reflexivity.<br/>
Qed.<br/>
Print&#160;<i>compile&#160;correct</i>.<br/>
70<br/>
<hr/>
<a name=71></a><b>4.3</b><br/>
<b>Compilation&#160;du&#160;LISP&#160;vers&#160;une&#160;machine&#160;abstraite</b><br/>
<b>La&#160;machine&#160;SECD</b><br/>
La&#160;machine&#160;SECD&#160;inventée&#160;par&#160;Landin&#160;est&#160;une&#160;machine&#160;abstraite&#160;utilisant&#160;quatre&#160;composants&#160;:<br/>
—&#160;S,&#160;la&#160;pile&#160;ou&#160;<i>stack&#160;</i>permettant&#160;de&#160;stocker&#160;les&#160;résultats&#160;intermédiaires&#160;puis&#160;le&#160;résultat&#160;final<br/>—&#160;E,&#160;l’environnement&#160;d’éxecution<br/>—&#160;C,&#160;le&#160;code<br/>—&#160;D,&#160;le&#160;dump&#160;permettant&#160;de&#160;stocker&#160;les&#160;valeurs&#160;courantes&#160;S,E,C&#160;le&#160;temps&#160;d’un&#160;calcul&#160;local<br/>
d’une&#160;fonction<br/>
Nous&#160;devons&#160;implémenter&#160;deux&#160;fonctions.<br/>
La&#160;fonction&#160;de&#160;compilation&#160;compile&#160;qui&#160;prend&#160;en&#160;argument&#160;une&#160;expression&#160;LISP,&#160;un&#160;environne-<br/>
ment&#160;de&#160;compilation&#160;et&#160;l’accumulateur&#160;du&#160;code&#160;compilé.&#160;Nous&#160;ferons&#160;travailler&#160;la&#160;fonction&#160;compile<br/>sur&#160;la&#160;syntaxe&#160;abstraite&#160;pour&#160;plus&#160;de&#160;facilité.<br/>
La&#160;fonction&#160;d’éxecution&#160;exe&#160;s&#160;e&#160;c&#160;d&#160;prend&#160;en&#160;arguments&#160;les&#160;quatre&#160;composantes&#160;de&#160;la&#160;machine<br/>
abstraite.<br/>
D&#160;DCONST(<i>c</i>)nACCESS(<i>n</i>)&#160;D<br/>
<b>La&#160;compilation&#160;</b><i>C&#160;</i>:&#160;<i>exp</i><br/>
<b>code</b><br/>
c<br/>
(+&#160;a1&#160;a2)<br/>
<i>C</i>(<i>a</i>1);&#160;<i>C</i>(<i>a</i>2);&#160;ADD<br/>
D<br/>
(-&#160;a1&#160;a2)<br/>
<i>C</i>(<i>a</i>1);&#160;<i>C</i>(<i>a</i>2);&#160;SUB<br/>
(=&#160;a1&#160;a2)<br/>
<i>C</i>(<i>a</i>1);&#160;<i>C</i>(<i>a</i>2);&#160;CMP<br/>
((lambda&#160;(v1...vn)&#160;body)&#160;e1...en)<br/>
NIL;&#160;<i>C</i>(<i>v</i>1);ARG;<i>.&#160;.&#160;.&#160;C</i>(<i>vn</i>);ARG;CLOSURE(<i>C</i>(<i>body</i>);RTS);JSR<br/>
<b>La&#160;table&#160;de&#160;transition&#160;de&#160;la&#160;machine&#160;SECD</b><br/>
<b>état&#160;avant</b><br/>
<b>état&#160;après</b><br/>
<i>S</i><br/>
<i>E</i><br/>
<i>C</i><br/>
<i>D</i><br/>
<i>S</i><br/>
<i>E</i><br/>
<i>C</i><br/>
<i>D</i><br/>
<i>s</i><br/>
<i>e</i><br/>
CONST(<i>cst</i>);&#160;<i>c</i><br/>
<i>d</i><br/>
<i>cst.s</i><br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
<i>n</i>2<i>.n</i>1<i>.s</i><br/>
<i>e</i><br/>
ADD;&#160;<i>c</i><br/>
<i>d</i><br/>
(<i>n</i>1&#160;+&#160;<i>n</i>2)<i>.s</i><br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
<i>n</i>2<i>.n</i>1<i>.s</i><br/>
<i>e</i><br/>
SUB;&#160;<i>c</i><br/>
<i>d</i><br/>
(<i>n</i>1&#160;−&#160;<i>n</i>2)<i>.s</i><br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
<i>n</i>2<i>.n</i>1<i>.s</i><br/>
<i>e</i><br/>
CMP;&#160;<i>c</i><br/>
<i>d</i><br/>
(<i>n</i>1&#160;=&#160;<i>n</i>2)<i>.s</i><br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
<i>s</i><br/>
<i>e</i><br/>
ACCESS(<i>n</i>);&#160;<i>c</i><br/>
<i>d</i><br/>
<i>e</i>(<i>n</i>)<i>.s</i><br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
construction&#160;d’une&#160;liste&#160;d’arguments<br/>
<i>s</i><br/>
<i>e</i><br/>
NIL;&#160;<i>c</i><br/>
<i>d</i><br/>
[&#160;]<br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
<i>v</i>1<i>.v</i>2<i>.s</i><br/>
<i>e</i><br/>
ARG;&#160;<i>c</i><br/>
<i>d</i><br/>
<i>v</i>1@<i>v</i>2<i>.s</i><br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
la&#160;conditionnelle<br/>
<i>v.s</i><br/>
<i>e</i><br/>
BRANCH(<i>c</i>1<i>,&#160;c</i>2);&#160;<i>c</i><br/>
<i>d</i><br/>
<i>s</i><br/>
<i>e</i><br/>
<i>c</i>1;&#160;<i>c</i><br/>
<i>d</i><br/>
<i>v.s</i><br/>
<i>e</i><br/>
BRANCH(<i>c</i>1<i>,&#160;c</i>2);&#160;<i>c</i><br/>
<i>d</i><br/>
<i>s</i><br/>
<i>e</i><br/>
<i>c</i>2;&#160;<i>c</i><br/>
<i>d</i><br/>
le&#160;traitement&#160;d’une&#160;clôture<br/>
<i>s</i><br/>
<i>e</i><br/>
CLOSURE(<i>f&#160;</i>);&#160;<i>c</i><br/>
<i>d</i><br/>
CLOS(<i>f,&#160;e</i>)<br/>
<i>e</i><br/>
<i>c</i><br/>
<i>d</i><br/>
application&#160;d’une&#160;lambda&#160;avec&#160;les&#160;instructions&#160;JSR,RTS<br/>
CLOS(<i>f,&#160;e</i>0)<i>.largs.s</i><br/>
<i>e</i><br/>
JSR;&#160;<i>c</i><br/>
<i>d</i><br/>
[&#160;]<br/>
<i>largs&#160;</i>::&#160;<i>e</i>0<br/>
<i>f</i><br/>
ENVEXE(<i>s,&#160;e,&#160;c</i>)<i>.d</i><br/>
<i>v.s</i><br/>
<i>e</i><br/>
RTS;&#160;<i>c</i><br/>
ENVEXE(<i>s</i>1<i>,&#160;e</i>1<i>,&#160;c</i>1)<i>.d</i><br/>
<i>v.s</i>1<br/>
<i>e</i>1<br/>
<i>c</i>1<br/>
<i>d</i><br/>
71<br/>
<hr/>
<a name=72></a><b>L’implémentation&#160;en&#160;OCAML</b><br/>
let&#160;rec&#160;compile&#160;envc&#160;exp&#160;codesuivant<br/>
=<br/>
match&#160;exp&#160;with<br/>|&#160;Atom&#160;(Entier&#160;n)&#160;-&gt;&#160;CONST&#160;n&#160;::&#160;codesuivant<br/>|&#160;Var&#160;s&#160;-&gt;&#160;ACCESS&#160;(adresse&#160;s&#160;envc)&#160;::&#160;codesuivant<br/>|&#160;Call&#160;(f,&#160;args)&#160;-&gt;&#160;compile_call&#160;envc&#160;f&#160;args&#160;codesuivant<br/>|&#160;Let&#160;(decl,expl)&#160;-&gt;&#160;compile_let&#160;envc&#160;decl&#160;expl&#160;codesuivant<br/>|&#160;If&#160;(cond,&#160;exp1,&#160;exp2)&#160;-&gt;&#160;compile_if&#160;envc&#160;cond&#160;exp1&#160;exp2&#160;codesuivant<br/>|&#160;Lambda&#160;(parl,&#160;bodyl)&#160;-&gt;&#160;compile_lambda&#160;envc&#160;parl&#160;bodyl&#160;codesuivant<br/>|&#160;_&#160;-&gt;&#160;raise&#160;(Erreur&#160;&#34;compile&#34;)<br/>
and&#160;compile_lambda&#160;envc&#160;parl&#160;bodyl&#160;codesuivant&#160;=<br/>
(CLOSURE&#160;((compile&#160;(parl::envc)&#160;(hd&#160;bodyl)<br/>
[RTS]))&#160;)&#160;::&#160;codesuivant<br/>
and&#160;compile_if&#160;envc&#160;cond&#160;exp1&#160;exp2&#160;codesuivant&#160;=<br/>
let&#160;code_si&#160;=&#160;compile&#160;envc&#160;exp1&#160;codesuivant<br/>and&#160;code_sinon&#160;=&#160;compile&#160;envc&#160;exp2&#160;codesuivant<br/>
in&#160;compile&#160;envc&#160;cond&#160;(&#160;BRANCH(code_si,<br/>
code_sinon)&#160;::&#160;codesuivant&#160;)<br/>
and&#160;compile_call&#160;envc&#160;f&#160;args&#160;codesuivant<br/>
=<br/>
match&#160;f&#160;with<br/>
|&#160;Var&#160;&#34;+&#34;&#160;-&gt;&#160;compile_app<br/>
envc&#160;args<br/>
(ADD&#160;::&#160;codesuivant)<br/>
|&#160;Var<br/>
&#34;-&#34;<br/>
-&gt;&#160;compile_app<br/>
envc&#160;args<br/>
(SUB&#160;::&#160;codesuivant)<br/>
|&#160;Var<br/>
&#34;=&#34;<br/>
-&gt;&#160;compile_app<br/>
envc&#160;args<br/>
(CMP&#160;::&#160;codesuivant)<br/>
|&#160;_&#160;-&gt;&#160;compile_larg&#160;envc&#160;args&#160;(compile&#160;envc&#160;f&#160;(JSR&#160;::&#160;codesuivant))<br/>
and<br/>compile_app&#160;envc&#160;args&#160;codesuivant&#160;=<br/>
if&#160;args&#160;=&#160;[]&#160;then&#160;codesuivant<br/>else<br/>
compile&#160;envc&#160;(hd&#160;args)&#160;(compile_app&#160;envc&#160;(tl&#160;args)&#160;codesuivant)<br/>
and&#160;compile_let&#160;envc&#160;decl&#160;expl&#160;codesuivant&#160;=<br/>
let&#160;lvar&#160;=&#160;map&#160;fst&#160;decl<br/>in&#160;let&#160;lexp&#160;=&#160;map&#160;snd&#160;decl<br/>in&#160;compile&#160;envc&#160;(Call(Lambda(lvar,&#160;expl),lexp))&#160;codesuivant<br/>
and&#160;compile_larg&#160;envc&#160;lexp&#160;codesuivant&#160;=<br/>
let&#160;rec&#160;aux&#160;lexp&#160;codesuivant&#160;=<br/>
match&#160;lexp&#160;with<br/>|&#160;[]&#160;-&gt;&#160;codesuivant<br/>|&#160;a::b&#160;-&gt;&#160;aux&#160;b&#160;(compile&#160;envc&#160;a&#160;(ARG::codesuivant))<br/>
in&#160;NIL::(aux&#160;lexp&#160;codesuivant)<br/>
let&#160;rec&#160;exe&#160;s&#160;e&#160;c&#160;d&#160;=<br/>
if&#160;(List.length&#160;c)&#160;=&#160;0&#160;then&#160;hd&#160;s<br/>else<br/>
match&#160;(hd&#160;c)&#160;with<br/>
|&#160;ADD&#160;-&gt;<br/>
let&#160;Entier(n2)&#160;=&#160;hd&#160;(hd&#160;s)&#160;and&#160;Entier(n1)&#160;=&#160;hd&#160;(hd&#160;(tl&#160;s))&#160;in<br/>
exe&#160;([Entier(n1+n2)]::&#160;(tl&#160;(tl&#160;s)))&#160;e&#160;(tl&#160;c)&#160;d<br/>
|&#160;SUB&#160;-&gt;<br/>
let&#160;Entier(n2)&#160;=&#160;hd&#160;(hd&#160;s)&#160;and&#160;Entier(n1)&#160;=&#160;hd&#160;(hd&#160;(tl&#160;s))&#160;in<br/>
exe&#160;([Entier(n1-n2)]::&#160;(tl&#160;(tl&#160;s)))&#160;e&#160;(tl&#160;c)&#160;d<br/>
|&#160;CMP&#160;-&gt;<br/>
let&#160;Entier(n2)&#160;=&#160;hd&#160;(hd&#160;s)&#160;and&#160;Entier(n1)&#160;=&#160;hd&#160;(hd&#160;(tl&#160;s))&#160;in<br/>
exe&#160;([Booleen(n1=n2)]::&#160;(tl&#160;(tl&#160;s)))&#160;e&#160;(tl&#160;c)&#160;d<br/>
|&#160;CONST&#160;n&#160;-&gt;<br/>
exe&#160;([Entier&#160;n]::s)<br/>
e&#160;(tl&#160;c)&#160;d<br/>
|&#160;NIL&#160;-&gt;<br/>
exe&#160;([]::s)&#160;e&#160;(tl&#160;c)&#160;d<br/>
|&#160;ARG&#160;-&gt;<br/>
let&#160;v1&#160;=&#160;hd&#160;s<br/>in&#160;let&#160;v2&#160;=&#160;hd&#160;(tl&#160;s)<br/>
72<br/>
<hr/>
<a name=73></a>in<br/>
exe&#160;((v1&#160;@&#160;v2)::(tl&#160;(tl&#160;s)))&#160;e&#160;(tl&#160;c)&#160;d<br/>
|&#160;ACCESS&#160;sy&#160;-&gt;<br/>
exe&#160;([lire_env&#160;sy&#160;e]::s)&#160;e&#160;(List.tl&#160;c)&#160;d<br/>
|&#160;BRANCH(code_si,&#160;code_sinon)&#160;-&gt;<br/>
let&#160;v&#160;=&#160;hd&#160;(hd&#160;s)&#160;in<br/>
if&#160;(v&#160;=&#160;Booleen(true))&#160;then&#160;exe&#160;(tl&#160;s)&#160;e&#160;(code_si&#160;@&#160;(tl&#160;c))&#160;d<br/>else&#160;exe&#160;(tl&#160;s)&#160;e&#160;(&#160;code_sinon&#160;@&#160;(tl&#160;c))&#160;d<br/>
|&#160;CLOSURE(fonc)&#160;-&gt;<br/>
exe&#160;([CLOS(fonc,e)]::s)&#160;e&#160;(tl&#160;c)&#160;d<br/>
|&#160;JSR&#160;-&gt;&#160;let&#160;CLOS(corps,&#160;e0)&#160;=&#160;hd&#160;(hd&#160;s)&#160;in<br/>
let&#160;larg&#160;=&#160;hd&#160;(tl&#160;s)&#160;in<br/>
exe&#160;[]&#160;(larg::e)&#160;corps&#160;((ENVEXE(tl&#160;(tl&#160;s),&#160;e,&#160;(tl&#160;c)))::d)<br/>
|&#160;RTS&#160;-&gt;&#160;let&#160;ENVEXE(s1,&#160;e1,&#160;c1)&#160;=&#160;hd&#160;d<br/>
and&#160;v&#160;=&#160;hd&#160;s&#160;in<br/>exe&#160;(v::s1)&#160;e1&#160;c1&#160;(tl&#160;d)<br/>
73<br/>
<hr/>
<a name=74></a>74<br/>
<hr/>
<a name=75></a><b>Chapitre&#160;5</b><br/>
<b>La&#160;résolution</b><br/>
<b>5.1</b><br/>
<b>Représentation&#160;des&#160;termes&#160;finis</b><br/>
Nous&#160;reprenons&#160;ici&#160;le&#160;très&#160;bon&#160;formalisme&#160;du&#160;livre&#160;de&#160;<i>Lalement&#160;</i><a href="documents.html#127">[12].<br/></a>Les&#160;symboles&#160;de&#160;constante&#160;true,&#160;158,&#160;les&#160;symboles&#160;de&#160;fonctions&#160;unaires&#160;not,&#160;+,&#160;les&#160;symboles&#160;de<br/>
fonctions&#160;binaires&#160;or,&#160;etc.&#160;constituent&#160;la&#160;signature&#160;Σ&#160;du&#160;langage.&#160;Si&#160;<i>f&#160;</i>est&#160;d’arité&#160;<i>n&#160;</i>≥&#160;1,&#160;alors&#160;<i>f&#160;</i>est<br/>un&#160;symbole&#160;fonctionnel,&#160;et&#160;si&#160;<i>f&#160;</i>est&#160;d’arité&#160;0,&#160;<i>f&#160;</i>est&#160;un&#160;symbole&#160;de&#160;constante.&#160;Nous&#160;ajoutons&#160;à&#160;Σ&#160;un<br/>ensemble&#160;<i>X&#160;</i>de&#160;symboles&#160;de&#160;variables.<br/>
L’ensemble&#160;des&#160;termes&#160;<i>T</i>Σ∪<i>X&#160;</i>est&#160;défini&#160;de&#160;la&#160;manière&#160;suivante&#160;:<br/>—&#160;si&#160;<i>c&#160;</i>∈&#160;Σ&#160;et&#160;<i>c&#160;</i>d’arité&#160;0,&#160;alors&#160;<i>c&#160;</i>∈&#160;<i>T</i>Σ∪<i>X<br/></i>—&#160;si&#160;<i>f&#160;</i>∈&#160;Σ&#160;et&#160;<i>f&#160;</i>d’arité&#160;<i>n&#160;</i>≥&#160;1&#160;avec&#160;<i>M</i>1<i>,&#160;.&#160;.&#160;.&#160;,&#160;Mn&#160;</i>∈&#160;<i>T</i>Σ∪<i>X&#160;</i>,&#160;alors&#160;<i>f&#160;M</i>1<i>...Mn&#160;</i>∈&#160;<i>T</i>Σ∪<i>X<br/></i>—&#160;si&#160;<i>x&#160;</i>∈&#160;<i>X</i>,&#160;alors&#160;<i>x&#160;</i>∈&#160;<i>T</i>Σ∪<i>X<br/></i>Nous&#160;pouvons&#160;représenter&#160;les&#160;termes&#160;en&#160;OCAML&#160;avec&#160;le&#160;type&#160;abstrait&#160;suivant&#160;:<br/>
type&#160;terme&#160;=<br/>
|&#160;Var&#160;of&#160;string<br/>
|&#160;Func&#160;of&#160;string&#160;*&#160;terme&#160;list<br/>
En&#160;fait,&#160;quasiment&#160;tous&#160;les&#160;objets&#160;que&#160;nous&#160;manipulerons&#160;pourront&#160;être&#160;modélisés&#160;par&#160;des&#160;termes.<br/>
Prenons&#160;l’exemple&#160;suivant&#160;pour&#160;définir&#160;le&#160;<i>type&#160;</i>des&#160;entiers&#160;naturels&#160;à&#160;partir&#160;de&#160;la&#160;signature&#160;Σ&#160;=&#160;{0<i>,&#160;S</i>}<br/>Les&#160;symboles&#160;<i>O&#160;</i>et&#160;<i>S&#160;</i>sont&#160;respectivement&#160;d’arité&#160;0&#160;et&#160;1.&#160;Nous&#160;avons&#160;ainsi&#160;:<br/>
<i>T</i>Σ&#160;=&#160;{0<i>,&#160;S</i>0<i>,&#160;SS</i>0<i>,&#160;SSS</i>0<i>,&#160;...</i>}<br/>
En&#160;OCAML,&#160;nous&#160;pourrons&#160;écrire&#160;:<br/>
type&#160;entiers&#160;=&#160;Zero&#160;|&#160;S&#160;of&#160;entiers<br/>
En&#160;Prolog&#160;:<br/>
entiers(zero).<br/>
entiers(s(X))&#160;:-&#160;entiers(X)<br/>
En&#160;Coq&#160;:<br/>
Inductive&#160;<i>entiers&#160;</i>:&#160;Set&#160;:=&#160;<i>Zero&#160;</i>:&#160;<i>entiers&#160;</i>|&#160;<i>S&#160;</i>:&#160;<i>entiers&#160;</i>→&#160;<i>entiers&#160;</i>.<br/>
Les&#160;termes&#160;se&#160;représentent&#160;naturellement&#160;sous&#160;forme&#160;d’arbres.<br/>
Prenons&#160;par&#160;exemple&#160;le&#160;terme&#160;Func(&#34;f&#34;,&#160;[Func(&#34;g&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Var&#160;&#34;y&#34;]);&#160;Var&#160;&#34;z&#34;])&#160;Il<br/>
sera&#160;représenté&#160;par&#160;l’arbre&#160;ci-dessous&#160;annoté&#160;de&#160;ses&#160;occurences&#160;<i>u&#160;</i>∈&#160;O(<i>M&#160;</i>)&#160;:<br/>
75<br/>
<hr/>
<a name=76></a>f&#160;(<i>u&#160;</i>=&#160;<i></i>)<br/>
g&#160;(<i>u&#160;</i>=&#160;1)<br/>
z&#160;(<i>u&#160;</i>=&#160;2)<br/>
x&#160;(<i>u&#160;</i>=&#160;11)&#160;y&#160;(<i>u&#160;</i>=&#160;12)<br/>
Pour&#160;tout&#160;terme&#160;<i>M&#160;</i>,&#160;on&#160;définit&#160;:<br/>
—&#160;L’ensemble&#160;O(<i>M&#160;</i>)&#160;des&#160;occurences&#160;de&#160;M<br/>—&#160;Le&#160;symbole&#160;<i>M&#160;</i>(<i>u</i>)&#160;en&#160;<i>u&#160;</i>pour&#160;<i>u&#160;</i>∈&#160;O(<i>M&#160;</i>)<br/>—&#160;Le&#160;sous-terme&#160;<i>M&#160;</i>|<i>u&#160;</i>de&#160;<i>M&#160;</i>en&#160;<i>u</i>,&#160;pour&#160;<i>u&#160;</i>∈&#160;O(<i>M&#160;</i>)<br/>
Dans&#160;le&#160;cas&#160;où&#160;<i>M&#160;</i>=&#160;<i>c&#160;</i>∈&#160;Σ,&#160;alors&#160;O(<i>M&#160;</i>)&#160;=&#160;{<i></i>},&#160;<i>M&#160;</i>(<i></i>)&#160;=&#160;<i>c</i>,&#160;<i>M&#160;</i>|<i>&#160;</i>=&#160;<i>c</i><br/>
Dans&#160;le&#160;cas&#160;où&#160;<i>M&#160;</i>=&#160;<i>f&#160;M</i>1&#160;<i>.&#160;.&#160;.&#160;Mn</i>,&#160;alors&#160;:<br/>
<i>n</i><br/>
O<br/>
[<br/>
(<i>M&#160;</i>)&#160;=&#160;{<i></i>}&#160;∪<br/>
<i>i.</i>O(<i>Mi</i>)<br/>
<i>i</i>=1<br/>
Avec&#160;les&#160;égalités&#160;suivantes&#160;pour&#160;les&#160;sous-termes&#160;<i>M&#160;</i>|<i>&#160;</i>=&#160;<i>f&#160;</i>et&#160;<i>M&#160;</i>|<i>i.u&#160;</i>=&#160;<i>Mi</i>|<i>u<br/></i>et&#160;de&#160;manière&#160;équivalente&#160;pour&#160;les&#160;symboles&#160;<i>M&#160;</i>(<i></i>)&#160;=&#160;<i>f&#160;</i>et&#160;<i>M&#160;</i>(<i>i.u</i>)&#160;=&#160;<i>Mi</i>(<i>u</i>)<br/>
Nous&#160;implémentons&#160;cela&#160;avec&#160;un&#160;peu&#160;de&#160;difficulté&#160;pour&#160;les&#160;conversions&#160;string&#160;vers&#160;int&#160;nécessaire<br/>
à&#160;la&#160;manipulation&#160;des&#160;occurences&#160;<i>u</i>.&#160;On&#160;considère&#160;ici&#160;qu’un&#160;arbre&#160;ne&#160;peut&#160;avoir&#160;plus&#160;de&#160;9&#160;fils,&#160;donc<br/>un&#160;seul&#160;digit&#160;permet&#160;de&#160;définir&#160;le&#160;numéro&#160;du&#160;noeud&#160;associé.<br/>
open&#160;String<br/>
let&#160;rec&#160;occurences&#160;i&#160;terme<br/>
=<br/>
match&#160;terme&#160;with<br/>
|Var&#160;_&#160;|&#160;Func(_,&#160;[])&#160;-&gt;<br/>
[i]<br/>
|Func&#160;(_,&#160;m)&#160;-&gt;<br/>
[i]&#160;@&#160;occur_liste&#160;1&#160;i<br/>
m<br/>
and&#160;occur_liste<br/>
c<br/>
i&#160;lterme&#160;=<br/>
match&#160;lterme&#160;with<br/>
|&#160;[]&#160;-&gt;&#160;[]<br/>
|&#160;a::b&#160;-&gt;&#160;(occurences&#160;(int_of_string((string_of_int(i)^(string_of_int&#160;c))))&#160;a)<br/>
@&#160;occur_liste&#160;(c+1)&#160;i&#160;b<br/>
let&#160;reste&#160;s&#160;=<br/>
if&#160;(length&#160;s)&#160;&lt;=&#160;1&#160;then&#160;&#34;0&#34;<br/>
else&#160;sub&#160;s&#160;1&#160;((length&#160;s)&#160;-1)<br/>
let&#160;string_of_char&#160;=&#160;String.make&#160;1&#160;;;<br/>
let&#160;rec&#160;cut&#160;i&#160;terme&#160;=<br/>
match&#160;terme&#160;with<br/>
|&#160;Var&#160;_&#160;|&#160;Func(_,&#160;[])&#160;when&#160;i=0&#160;-&gt;&#160;terme<br/>
76<br/>
<hr/>
<a name=77></a>|&#160;Func(f,&#160;lt)&#160;-&gt;&#160;if&#160;i=0&#160;then&#160;terme<br/>
else&#160;subterme&#160;(int_of_string(string_of_char((string_of_int&#160;i).[0])))<br/>
(int_of_string(reste&#160;(string_of_int&#160;i)))<br/>
lt<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;Impossible<br/>
and&#160;subterme&#160;i&#160;u&#160;ltermes&#160;=<br/>
match&#160;ltermes&#160;with<br/>
|&#160;hd::tl&#160;-&gt;&#160;if&#160;(i=1)&#160;then<br/>
cut&#160;u&#160;hd&#160;else<br/>
subterme&#160;(i-1)&#160;u&#160;tl<br/>
|&#160;[]&#160;-&gt;&#160;raise&#160;Impossible<br/>
Nous&#160;pouvons&#160;aussi&#160;définir&#160;l’opération&#160;de&#160;<i>greffe&#160;</i>à&#160;une&#160;occurence&#160;<i>u&#160;</i>donnée.&#160;Nous&#160;utiliserons&#160;l’écriture<br/><i>M&#160;</i>[<i>N&#160;</i>]<i>u&#160;</i>pour&#160;signifier&#160;que&#160;le&#160;terme&#160;<i>M&#160;</i>reçoit&#160;à&#160;l’occurence&#160;<i>u&#160;</i>son&#160;greffon&#160;<i>N&#160;</i>.<br/>
let&#160;rec&#160;greffe&#160;i&#160;terme&#160;greffon&#160;=<br/>
match&#160;terme&#160;with<br/>
|&#160;Var&#160;_&#160;|&#160;Func(_,&#160;[])&#160;when&#160;i=0&#160;-&gt;&#160;greffon<br/>
|&#160;Func(f,&#160;lt)&#160;-&gt;&#160;if&#160;i=0&#160;then&#160;greffon<br/>
else&#160;Func(f,&#160;greffeltermes&#160;(int_of_string(string_of_char((string_of_int&#160;i).[0])))<br/>
(int_of_string(reste&#160;(string_of_int&#160;i)))<br/>
lt<br/>
greffon)<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;Impossible<br/>
and&#160;greffeltermes&#160;i&#160;u&#160;ltermes&#160;greffon&#160;=<br/>
match&#160;ltermes&#160;with<br/>
|&#160;hd::tl&#160;-&gt;&#160;if&#160;(i=1)&#160;then<br/>
(greffe&#160;u&#160;hd&#160;greffon)::tl<br/>
else&#160;hd::(greffeltermes&#160;(i-1)&#160;u&#160;tl&#160;greffon)<br/>
|&#160;[]&#160;-&gt;&#160;raise&#160;Impossible<br/>
<b>5.2</b><br/>
<b>La&#160;substitution</b><br/>
Une&#160;substitution&#160;est&#160;une&#160;application&#160;<i>θ&#160;</i>:&#160;<i>X&#160;</i>→&#160;<i>TX</i>∪Σ<br/>
Le&#160;domaine&#160;de&#160;substitution&#160;est&#160;l’ensemble&#160;des&#160;variables&#160;de&#160;<i>X&#160;</i>telles&#160;que&#160;<i>θ</i>(<i>x</i>)&#160;6=&#160;<i>x&#160;</i>On&#160;dit&#160;aussi<br/>
que&#160;l’application&#160;<i>θ&#160;</i>est&#160;l’identité&#160;<i>presque&#160;</i>partout,&#160;i.e&#160;sauf&#160;sur&#160;une&#160;partie&#160;finie&#160;de&#160;<i>X</i>.&#160;Considérons<br/>le&#160;domaine&#160;de&#160;<i>θ&#160;</i>=&#160;{<i>x</i>1<i>,&#160;...,&#160;xn</i>},&#160;alors&#160;<i>θ&#160;</i>est&#160;représenté&#160;par&#160;l’ensemble&#160;des&#160;couples&#160;(variable,&#160;terme)<br/>{(<i>x</i>1<i>,&#160;θ</i>(<i>x</i>1))<i>,&#160;...,&#160;</i>(<i>xn,&#160;θ</i>(<i>xn</i>)}<br/>
Nous&#160;avons&#160;par&#160;induction&#160;:<br/>
—&#160;ˆ<br/>
<i>θc&#160;</i>=&#160;<i>c</i>,&#160;si&#160;<i>c&#160;</i>∈&#160;Σ&#160;d’arité&#160;1<br/>
—&#160;ˆ<br/>
<i>θ</i>(<i>f&#160;M</i>1&#160;<i>.&#160;.&#160;.&#160;Mn</i>)&#160;=&#160;<i>f&#160;</i>(ˆ<br/>
<i>θM</i>1&#160;<i>.&#160;.&#160;.&#160;</i>ˆ<br/>
<i>θMn</i>),&#160;si&#160;<i>f&#160;</i>∈&#160;Σ&#160;d’arité&#160;<i>n</i><br/>
—&#160;ˆ<br/>
<i>θx&#160;</i>=&#160;<i>θ</i>(<i>x</i>)&#160;si&#160;<i>x&#160;</i>∈&#160;<i>X</i><br/>
La&#160;fonction&#160;<i>θ&#160;</i>s’étend&#160;ainsi&#160;en&#160;une&#160;fonction&#160;ˆ<br/>
<i>θ&#160;</i>(mais&#160;que&#160;nous&#160;appelerons&#160;aussi&#160;<i>θ</i>)&#160;de&#160;<i>TX</i>∪Σ&#160;→&#160;<i>TX</i>∪Σ.<br/>
ˆ<br/>
<i>θ&#160;</i>est&#160;l’unique&#160;fonction&#160;telle&#160;que&#160;∀<i>x&#160;</i>∈&#160;<i>X,&#160;</i>ˆ<br/>
<i>θx&#160;</i>=&#160;<i>θ</i>(<i>x</i>)<br/>
77<br/>
<hr/>
<a name=78></a><i>X</i><br/>
<i>θ</i><br/>
<i>TX</i>∪Σ<br/>
∈<br/>
ˆ<br/>
<i>θ</i><br/>
<i>TX</i>∪Σ<br/>
Voici&#160;un&#160;exemple&#160;d’implémentation&#160;de&#160;la&#160;substitution&#160;en&#160;OCAML&#160;:<br/>
let&#160;valeur_subst&#160;sigma&#160;var&#160;=<br/>
try&#160;assoc&#160;var&#160;sigma<br/>
with&#160;Not_found&#160;-&gt;&#160;var<br/>
let&#160;rec&#160;substituer&#160;terme&#160;sigma<br/>
=<br/>
match&#160;terme&#160;with<br/>
|&#160;Var(x)&#160;-&gt;&#160;(valeur_subst&#160;sigma&#160;terme)<br/>
|&#160;Func(f,&#160;[])&#160;-&gt;&#160;Func(f,&#160;[])<br/>
|&#160;Func(f,&#160;args)&#160;-&gt;&#160;Func(f,&#160;(map&#160;(function&#160;t&#160;-&gt;&#160;(substituer&#160;t&#160;sigma))&#160;args))<br/>
<b>5.3</b><br/>
<b>Filtrage&#160;et&#160;réécriture</b><br/>
<b>5.3.1</b><br/>
<b>Le&#160;filtrage</b><br/>
Soient&#160;deux&#160;termes&#160;<i>M&#160;</i>et&#160;<i>M&#160;</i>0&#160;appartenant&#160;à&#160;<i>TX&#160;</i>,&#160;le&#160;filtrage&#160;consiste&#160;à&#160;trouver&#160;une&#160;substitution<br/>
<i>σ&#160;</i>telle&#160;que&#160;<i>σM&#160;</i>=&#160;<i>M&#160;</i>0.&#160;Autrement&#160;dit,&#160;il&#160;faut&#160;trouver&#160;les&#160;valeurs&#160;à&#160;donner&#160;aux&#160;variables&#160;de&#160;<i>M&#160;</i>pour<br/>que&#160;celui-ci&#160;soit&#160;égal&#160;<i>M&#160;</i>0.<br/>
On&#160;appelle&#160;<i>M&#160;</i>le&#160;<i>pattern&#160;</i>et&#160;<i>M&#160;</i>0&#160;l’<i>instance</i>.&#160;Nous&#160;implémentons&#160;cela&#160;comme&#160;ci-dessous&#160;:<br/>
type&#160;terme&#160;=<br/>
|&#160;Var&#160;of&#160;string<br/>
|&#160;Func&#160;of&#160;string&#160;*&#160;terme&#160;list<br/>
exception&#160;Impossible<br/>
let&#160;rec&#160;filtre_termes&#160;lt1&#160;lt2&#160;sigma&#160;=<br/>
match&#160;(lt1,lt2)&#160;with<br/>
|&#160;([],&#160;_)<br/>
-&gt;&#160;sigma<br/>
|&#160;(_,&#160;[])&#160;-&gt;<br/>
sigma<br/>
|&#160;_&#160;-&gt;<br/>
begin<br/>
let&#160;sigma1&#160;=&#160;filtre&#160;(hd(lt1))&#160;(hd(lt2))&#160;sigma&#160;in<br/>
filtre_termes&#160;(tl(lt1))&#160;(tl(lt2))&#160;sigma1<br/>
end<br/>
and&#160;filtre&#160;m&#160;n&#160;sigma&#160;=<br/>
match&#160;(m,n)&#160;with<br/>
|&#160;(Func(f,_),&#160;Func(g,&#160;_))&#160;when&#160;f&#160;&lt;&gt;&#160;g&#160;-&gt;&#160;raise&#160;Impossible<br/>
|&#160;(Var(x),&#160;n)&#160;-&gt;<br/>
78<br/>
<hr/>
<a name=79></a>begin<br/>
try&#160;let&#160;var_val&#160;=&#160;assoc&#160;(Var(x))&#160;sigma&#160;in<br/>
if&#160;var_val&#160;=&#160;n&#160;then&#160;sigma&#160;else&#160;raise&#160;Impossible<br/>
with&#160;Not_found&#160;-&gt;&#160;(Var(x),&#160;n)::sigma<br/>
end<br/>
|&#160;(Func(f,f1),&#160;Func(g,g1))&#160;-&gt;&#160;filtre_termes&#160;f1&#160;g1&#160;sigma<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;Impossible<br/>
let&#160;f1&#160;=&#160;Func(&#34;f&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Func(&#34;g&#34;,&#160;[Var&#160;&#34;y&#34;;&#160;Var&#160;&#34;z&#34;]);&#160;Func(&#34;h&#34;,&#160;[Var&#160;&#34;x&#34;])])&#160;;;<br/>
let&#160;f2&#160;=&#160;Func(&#34;f&#34;,&#160;[Func(&#34;a&#34;,[]);&#160;Func(&#34;g&#34;,&#160;[Func(&#34;h&#34;,&#160;[Var&#160;&#34;x&#34;]);&#160;Func(&#34;b&#34;,&#160;[])]);&#160;Func(&#34;h&#34;,&#160;[Func&#160;(&#34;a&#34;,&#160;[])])])&#160;;;<br/>
imprime_sigma&#160;(filtre&#160;f1&#160;f2&#160;[])&#160;;;<br/>
=&gt;&gt;&gt;<br/>
z&#160;&lt;-&gt;<br/>
b<br/>
y&#160;&lt;-&gt;&#160;(h&#160;x&#160;)<br/>
x&#160;&lt;-&gt;<br/>
a<br/>
-&#160;:&#160;unit&#160;=&#160;()<br/>
<b>5.3.2</b><br/>
<b>La&#160;réécriture&#160;et&#160;l’arithmétique&#160;de&#160;Peano</b><br/>
Le&#160;mécanisme&#160;de&#160;réécriture,&#160;très&#160;simple&#160;à&#160;comprendre&#160;conceptuellement,&#160;est&#160;un&#160;peu&#160;plus&#160;difficile<br/>
à&#160;formaliser&#160;proprement.<br/>
Un&#160;système&#160;de&#160;<i>réécriture&#160;</i>est&#160;composé&#160;d’une&#160;signature&#160;Σ&#160;et&#160;d’un&#160;ensemble&#160;de&#160;règles&#160;R&#160;représenté<br/>
par&#160;des&#160;couples&#160;(<i>P,&#160;Q</i>)&#160;∈&#160;<i>T</i>Σ[<i>X</i>]&#160;×&#160;<i>T</i>Σ[<i>X</i>].<br/>
Les&#160;couples&#160;(<i>P,&#160;Q</i>)&#160;sont&#160;notés&#160;<i>P&#160;</i>−→&#160;<i>Q<br/></i>Si&#160;nous&#160;avons&#160;un&#160;filtre&#160;<i>σ&#160;</i>tel&#160;que&#160;<i>σP&#160;</i>=&#160;<i>M&#160;</i>|<i>u</i>,&#160;alors&#160;le&#160;terme&#160;<i>M&#160;</i>se&#160;réécrit&#160;en&#160;un&#160;terme&#160;<i>M&#160;</i>[<i>σQ</i>]<i>u</i><br/>
par&#160;l’application&#160;de&#160;la&#160;règle&#160;<i>P&#160;</i>−→&#160;<i>Q&#160;</i>à&#160;l’occurence&#160;<i>u&#160;</i>∈&#160;O(<i>M&#160;</i>)<br/>
<i>M</i><br/>
<i>M&#160;</i>[<i>σQ</i>]<i>u</i><br/>
<i>σP</i><br/>
<i>σQ</i><br/>
<i>u</i><br/>
CAML&#160;est&#160;«déjà»&#160;une&#160;machine&#160;à&#160;faire&#160;du&#160;filtrage&#160;et&#160;de&#160;la&#160;réécriture.&#160;L’application&#160;d’une&#160;fonction<br/>
<i>P&#160;</i>à&#160;son&#160;argument&#160;<i>Q&#160;</i>est&#160;modélisé&#160;par&#160;le&#160;redex&#160;(<i>λmP&#160;</i>)<i>Q&#160;</i>−→&#160;<i>θP&#160;</i>où&#160;<i>m&#160;</i>est&#160;le&#160;pattern&#160;et&#160;<i>θ&#160;</i>le&#160;filtre&#160;de<br/><i>m&#160;</i>vers&#160;<i>Q</i>,&#160;c’est-à-dire&#160;<i>θm&#160;</i>=&#160;<i>Q</i>.<br/>
Il&#160;est&#160;ainsi&#160;simple&#160;de&#160;programmer&#160;en&#160;OCAML&#160;une&#160;fonction&#160;de&#160;réécriture.&#160;Appliquons&#160;cela&#160;sur<br/>
l’arithmétique&#160;de&#160;Peano.<br/>
Peano&#160;a&#160;reconstruit&#160;la&#160;théorie&#160;des&#160;entiers&#160;à&#160;partir&#160;de&#160;la&#160;fonction&#160;successeur.&#160;On&#160;se&#160;donne&#160;uni-<br/>
quement&#160;le&#160;symbole&#160;<i>S&#160;</i>d’arité&#160;1&#160;et&#160;le&#160;symbole&#160;de&#160;constante&#160;0.&#160;Les&#160;entiers&#160;sont&#160;les&#160;termes&#160;de&#160;la&#160;forme<br/>0<i>,&#160;S</i>0<i>,&#160;SS</i>0<i>,&#160;SSS</i>0&#160;<i>.&#160;.&#160;.&#160;</i>Nous&#160;pouvons&#160;implémenter&#160;cela&#160;en&#160;OCAM&#160;avec&#160;le&#160;type&#160;abstrait&#160;peano<br/>
type&#160;peano&#160;=<br/>
|&#160;Zero<br/>
|&#160;Succ&#160;of&#160;peano<br/>
|&#160;Plus&#160;of&#160;peano&#160;*&#160;peano<br/>
79<br/>
<hr/>
<a name=80></a>|&#160;Mult&#160;of&#160;peano&#160;*&#160;peano<br/>
let&#160;un&#160;=&#160;Succ&#160;Zero&#160;;;<br/>
let&#160;deux&#160;=&#160;Succ&#160;(Succ&#160;Zero)&#160;;;<br/>
let&#160;trois&#160;=&#160;Succ&#160;(Succ&#160;(Succ&#160;Zero))&#160;;;<br/>
Puis&#160;nous&#160;avons&#160;les&#160;quatre&#160;règles&#160;de&#160;réécriture&#160;suivante&#160;:<br/>
(<i>r</i>1)&#160;(+&#160;<i>x&#160;</i>0)&#160;→&#160;<i>x<br/></i>(<i>r</i>2)&#160;(+&#160;<i>x&#160;</i>(<i>S&#160;y</i>))&#160;→&#160;(<i>S&#160;</i>(+<i>x&#160;y</i>))<br/>(<i>r</i>3)&#160;(∗&#160;<i>x&#160;</i>0)&#160;→&#160;0<br/>(<i>r</i>4)&#160;(∗&#160;<i>x&#160;</i>(<i>S&#160;y</i>))&#160;→&#160;(+&#160;<i>y&#160;</i>(∗<i>x&#160;y</i>))<br/>
Ces&#160;quatre&#160;règles&#160;sont&#160;implémentées&#160;par&#160;la&#160;fonction&#160;réduire&#160;ci-dessous&#160;:<br/>
let&#160;rec&#160;reduire&#160;=&#160;function<br/>
|&#160;Plus&#160;(p,&#160;Zero)&#160;-&gt;&#160;reduire&#160;p<br/>
|&#160;Plus&#160;(p1&#160;,&#160;(Succ&#160;p2))&#160;-&gt;&#160;Succ&#160;(&#160;reduire&#160;((Plus&#160;(reduire&#160;p1,&#160;reduire&#160;p2)))&#160;)<br/>
|&#160;Mult&#160;(p,&#160;Zero)&#160;-&gt;&#160;Zero<br/>
|&#160;Mult&#160;(p1,&#160;(Succ&#160;p2))<br/>
-&gt;&#160;reduire&#160;(Plus&#160;(reduire&#160;p1,&#160;reduire&#160;((Mult&#160;(reduire&#160;p1,&#160;reduire&#160;p2)))&#160;))<br/>
|&#160;_&#160;as&#160;p&#160;-&gt;&#160;p<br/>
let&#160;rec&#160;peano_entier&#160;=&#160;function<br/>
|&#160;Zero&#160;-&gt;&#160;0<br/>
|&#160;Succ&#160;p&#160;-&gt;&#160;1&#160;+&#160;(peano_entier&#160;p)<br/>
|&#160;any&#160;-&gt;&#160;peano_entier&#160;(reduire&#160;any)<br/>
peano_entier&#160;(Plus&#160;(&#160;Mult(deux,&#160;trois),&#160;trois));;<br/>
Essayons&#160;maintenant&#160;d’implémenter&#160;le&#160;mécanisme&#160;de&#160;réécriture&#160;en&#160;utilisation&#160;le&#160;type&#160;<i>terme</i><br/>
que&#160;nous&#160;avons&#160;précedemment&#160;présenté,&#160;ainsi&#160;que&#160;la&#160;fonction&#160;de&#160;filtrage&#160;filtre&#160;et&#160;la&#160;fonction&#160;du<br/>substitution&#160;substituer.<br/>
Nous&#160;avons&#160;fait&#160;simple&#160;avec&#160;cette&#160;méthode&#160;naïve&#160;qui&#160;utilise&#160;les&#160;trois&#160;fonctions&#160;ci-dessous&#160;:<br/>—&#160;La&#160;première&#160;rewrite&#160;utilise&#160;la&#160;fonction&#160;filtre&#160;pour&#160;chercher&#160;une&#160;substitution&#160;égalisant<br/>
notre&#160;terme&#160;avec&#160;la&#160;partie&#160;gauche&#160;de&#160;la&#160;règle&#160;de&#160;substitution.&#160;Si&#160;cette&#160;substitution&#160;est&#160;trou-<br/>veée,&#160;la&#160;fonction&#160;retourne&#160;la&#160;partie&#160;droite&#160;de&#160;la&#160;règle&#160;appliquée&#160;à&#160;la&#160;substitution.&#160;Dans&#160;le&#160;cas<br/>contraire,&#160;la&#160;fonction&#160;est&#160;appelée&#160;récursivement&#160;sur&#160;l’ensemble&#160;des&#160;arguments&#160;du&#160;terme.<br/>
—&#160;La&#160;seconde&#160;rewriteall&#160;déroule&#160;l’ensemble&#160;des&#160;règles&#160;représentées&#160;par&#160;une&#160;liste&#160;de&#160;paires<br/>
(<i>l,&#160;r</i>)&#160;tant&#160;que&#160;la&#160;réécriture&#160;ne&#160;modifie&#160;par&#160;le&#160;terme.<br/>
—&#160;La&#160;troisième&#160;rewrite_bourrin&#160;itère&#160;la&#160;fonction&#160;précédente&#160;tant&#160;que&#160;l’on&#160;peut&#160;réduire&#160;le<br/>
terme.&#160;Désolé&#160;pour&#160;cette&#160;méthode&#160;bourrin,&#160;mais&#160;ça&#160;fonctionne.&#160;.&#160;.<br/>
let&#160;rec&#160;rewrite&#160;t&#160;l&#160;r&#160;=<br/>
match&#160;t&#160;with<br/>
|&#160;Var(_)&#160;|&#160;Func(_,[])&#160;-&gt;&#160;t<br/>
|&#160;Func(f,&#160;listet)<br/>
-&gt;<br/>
try&#160;let&#160;subst&#160;=&#160;filtre&#160;l&#160;t&#160;[]&#160;in<br/>
80<br/>
<hr/>
<a name=81></a>substituer&#160;r&#160;subst<br/>
with&#160;Impossible&#160;-&gt;&#160;Func(f,&#160;map&#160;(function&#160;t&#160;-&gt;&#160;(rewrite&#160;t&#160;l&#160;r))&#160;listet)<br/>
and&#160;rewriteall&#160;lregles&#160;t&#160;=<br/>
match&#160;lregles&#160;with<br/>
|&#160;[]&#160;-&gt;&#160;t<br/>
|&#160;(l,r)&#160;::reste&#160;-&gt;<br/>
let&#160;t1&#160;=&#160;(rewrite&#160;t&#160;l&#160;r)&#160;in<br/>
if&#160;t1=t&#160;then&#160;rewriteall&#160;reste&#160;t<br/>
else&#160;t1<br/>
and&#160;rewrite_bourrin&#160;t&#160;lregles&#160;=<br/>
let&#160;t1&#160;=&#160;rewriteall&#160;lregles&#160;t&#160;in<br/>
if&#160;t1=t&#160;then&#160;t<br/>
else&#160;rewrite_bourrin&#160;t1&#160;lregles<br/>
Les&#160;quatre&#160;règles&#160;de&#160;Peano&#160;sont&#160;modélisées&#160;de&#160;la&#160;façon&#160;suivante&#160;:<br/>
let&#160;peano&#160;=&#160;[<br/>
(Func(&#34;+&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Func(&#34;0&#34;,&#160;[])]),&#160;Var&#160;&#34;x&#34;)&#160;;<br/>
(Func(&#34;+&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Func(&#34;S&#34;,&#160;[Var&#160;&#34;y&#34;])])),&#160;Func(&#34;S&#34;,&#160;[Func(&#34;+&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Var&#160;&#34;y&#34;])])&#160;;<br/>
(Func(&#34;*&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Func(&#34;0&#34;,&#160;[])]),&#160;Func(&#34;0&#34;,&#160;[]))&#160;;<br/>
(Func(&#34;*&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Func(&#34;S&#34;,&#160;[Var&#160;&#34;y&#34;])])),&#160;Func(&#34;+&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Func(&#34;*&#34;,&#160;[Var&#160;&#34;x&#34;;&#160;Var&#160;&#34;y&#34;])])&#160;;<br/>
]<br/>
Nous&#160;pouvons&#160;ainsi&#160;calculer&#160;la&#160;valeur&#160;16&#160;:<br/>
let&#160;un&#160;=&#160;Func(&#34;S&#34;,&#160;[Func(&#34;0&#34;,&#160;[])])&#160;;;<br/>
let&#160;deux&#160;=&#160;Func(&#34;+&#34;,&#160;[un;&#160;un])&#160;;;<br/>
let&#160;quatre&#160;=&#160;Func(&#34;*&#34;,&#160;[deux;deux])&#160;;;<br/>
let&#160;seize&#160;=&#160;Func(&#34;*&#34;,&#160;[quatre;quatre])&#160;;;<br/>
rewrite_bourrin&#160;seize&#160;peano&#160;;;<br/>
<b>5.4</b><br/>
<b>L’unification&#160;des&#160;termes</b><br/>
Un&#160;interprète&#160;PROLOG&#160;peut&#160;être&#160;considéré&#160;comme&#160;une&#160;machine&#160;à&#160;unifier.<br/>
Définissons&#160;d’abord&#160;l’opération&#160;d’unification&#160;de&#160;deux&#160;termes.&#160;Un&#160;unificateur&#160;de&#160;deux&#160;termes&#160;<i>t</i>1<br/>
et&#160;<i>t</i>2&#160;est&#160;une&#160;substitution&#160;<i>σ&#160;</i>telle&#160;que&#160;<i>σt</i>1&#160;=&#160;<i>σt</i>2<br/>
Soit&#160;<i>E</i>,&#160;un&#160;système&#160;d’équations,&#160;on&#160;peut&#160;définir&#160;des&#160;transformations&#160;<i>E</i>1&#160;→<i>t&#160;E</i>2&#160;entre&#160;systèmes<br/>
d’équations.&#160;On&#160;note&#160;le&#160;symbole&#160;⊥&#160;qui&#160;représente&#160;un&#160;système&#160;sans&#160;solution.&#160;Résoudre&#160;<i>E</i>0&#160;consiste<br/>à&#160;appliquer&#160;une&#160;suite&#160;de&#160;transformations&#160;<i>E</i>0&#160;→∗&#160;<i>En&#160;</i>de&#160;sorte&#160;que&#160;<i>En&#160;</i>soit&#160;en&#160;forme&#160;résolue,&#160;ou&#160;bien<br/><i>En&#160;</i>=&#160;⊥<br/>
Nous&#160;avons&#160;six&#160;types&#160;de&#160;transformations&#160;possibles&#160;:<br/>
81<br/>
<hr/>
<a name=82></a>décomposition<br/>
<i>E&#160;</i>∪&#160;{<i>f&#160;M</i>1&#160;<i>.&#160;.&#160;.&#160;Mr&#160;</i>=&#160;<i>f&#160;N</i>1&#160;<i>.&#160;.&#160;.&#160;Nr</i>}&#160;→&#160;<i>E&#160;</i>∪&#160;{<i>M</i>1&#160;=&#160;<i>N</i>1<i>,&#160;.&#160;.&#160;.&#160;,&#160;Mr&#160;</i>=&#160;<i>Nr</i>}<br/>
effacement<br/>
<i>E&#160;</i>∪&#160;{<i>M&#160;</i>=&#160;<i>M&#160;</i>}&#160;→&#160;<i>E</i><br/>
élimination<br/>
<i>E&#160;</i>∪&#160;{<i>x&#160;</i>=&#160;<i>M&#160;</i>}&#160;→&#160;<i>E</i>[<i>x&#160;</i>:=&#160;<i>M&#160;</i>]&#160;∪&#160;{<i>x&#160;</i>=&#160;<i>M&#160;</i>}&#160;si&#160;<i>M&#160;/</i><br/>
∈&#160;<i>X,&#160;x&#160;/</i><br/>
∈&#160;<i>var</i>(<i>M&#160;</i>)<br/>
inversion<br/>
<i>E&#160;</i>∪&#160;{<i>M&#160;</i>=&#160;<i>x</i>}&#160;→&#160;<i>E&#160;</i>∪&#160;{<i>x&#160;</i>=&#160;<i>M&#160;</i>}&#160;si&#160;<i>M&#160;/</i><br/>
∈&#160;<i>X</i><br/>
conflit<br/>
<i>E&#160;</i>∪&#160;{<i>f&#160;M&#160;</i>=&#160;<i>gM&#160;</i>}&#160;→&#160;⊥&#160;si&#160;<i>f&#160;</i>6=&#160;<i>g</i><br/>
cycle<br/>
<i>E&#160;</i>∪&#160;{<i>x&#160;</i>=&#160;<i>M&#160;</i>}&#160;→&#160;⊥&#160;si&#160;<i>x&#160;</i>∈&#160;<i>var</i>(<i>M&#160;</i>)<br/>
La&#160;difficulté&#160;de&#160;cet&#160;algorithme&#160;est&#160;sa&#160;condition&#160;d’arrêt.&#160;Si&#160;aucune&#160;règle&#160;ne&#160;peut&#160;plus&#160;s’appli-<br/>
quer&#160;sur&#160;les&#160;éléments&#160;du&#160;système&#160;d’équations,&#160;alors&#160;l’algorithme&#160;doit&#160;s’arrêter&#160;et&#160;son&#160;résultat&#160;est<br/>la&#160;substitution&#160;unifiant&#160;les&#160;deux&#160;termes&#160;initiaux.&#160;Avec&#160;une&#160;seule&#160;fonction&#160;parcourant&#160;le&#160;système<br/>d’équations,&#160;représentés&#160;en&#160;OCAML&#160;par&#160;le&#160;type&#160;(term&#160;*&#160;term)&#160;list,&#160;je&#160;pense&#160;que&#160;ce&#160;n’est&#160;pas<br/>possible.&#160;Je&#160;me&#160;suis&#160;là&#160;aussi&#160;un&#160;peu&#160;cassé&#160;les&#160;cheveux.&#160;Voici&#160;mon&#160;code&#160;avec&#160;deux&#160;fonctions&#160;:<br/>
let&#160;rec<br/>
unifier&#160;equation&#160;=<br/>
match&#160;equation&#160;with<br/>
|&#160;(Var(x),Var(y))&#160;-&gt;&#160;if&#160;x=y&#160;then&#160;[]&#160;else&#160;[(Var(x),&#160;Var(y))]<br/>
|&#160;(Func(f1,l1),Func(f2,&#160;l2))&#160;-&gt;&#160;if&#160;f1&#160;=&#160;f2&#160;&amp;&amp;&#160;List.length&#160;l1&#160;=&#160;List.length&#160;l2<br/>
then&#160;unifierliste&#160;(List.combine&#160;l1&#160;l2)<br/>
else&#160;raise&#160;Impossible<br/>
|&#160;(Func(m,n),Var(x))&#160;-&gt;&#160;unifier&#160;(Var(x),&#160;Func(m,n))<br/>
|&#160;(Var(x),&#160;Func(m,n))&#160;-&gt;&#160;if&#160;(mem&#160;(Var(x))&#160;(listevar&#160;(Func(m,n))))<br/>
then&#160;raise&#160;Impossible<br/>
else&#160;[(Var(x),&#160;Func(m,n))&#160;]<br/>
and&#160;unifierliste&#160;=&#160;function<br/>
|&#160;[]&#160;-&gt;&#160;[]<br/>
|&#160;(x,y)::t&#160;-&gt;<br/>
let&#160;t2&#160;=&#160;unifierliste&#160;t&#160;in<br/>
let&#160;t1&#160;=&#160;unifier&#160;((substituer&#160;x&#160;t2&#160;),(substituer&#160;y&#160;t2))&#160;in<br/>
t1&#160;@&#160;t2<br/>
On&#160;retrouve&#160;dans&#160;la&#160;fonction&#160;unifier,&#160;qui&#160;travaille&#160;uniquement&#160;sur&#160;une&#160;paire&#160;de&#160;terme,&#160;les<br/>
différentes&#160;règles&#160;de&#160;l’algorithme.&#160;La&#160;fonction&#160;unifierliste&#160;va&#160;unifier&#160;sa&#160;première&#160;paire&#160;en&#160;utilisant<br/>la&#160;substitution&#160;trouvée&#160;dans&#160;le&#160;reste&#160;de&#160;l’équation.&#160;C’est&#160;un&#160;bel&#160;exemple&#160;de&#160;récursivité&#160;qui&#160;nous<br/>dépasse&#160;très&#160;souvent...&#160;Ce&#160;bout&#160;de&#160;code&#160;vient&#160;du&#160;site&#160;de&#160;l’université&#160;de&#160;Cornell.<br/>
Voici&#160;un&#160;autre&#160;exemple&#160;moins&#160;proche&#160;de&#160;l’algorithme&#160;présenté.<br/>
let&#160;unifier&#160;t1&#160;t2&#160;=<br/>
let&#160;rec&#160;unificateur&#160;t1&#160;t2&#160;=<br/>
match&#160;(t1,t2)&#160;with<br/>
|&#160;(Var(x),&#160;_)<br/>
-&gt;<br/>
begin<br/>
if&#160;t1&#160;=&#160;t2&#160;then&#160;[]<br/>
else&#160;if&#160;(mem&#160;t1&#160;(listevar&#160;t2))&#160;then&#160;raise&#160;Impossible<br/>
else&#160;[(t1,&#160;t2)]<br/>
end<br/>
|&#160;(_,&#160;Var(x))&#160;-&gt;&#160;unificateur&#160;t2&#160;t1<br/>
|&#160;(Func(x,&#160;l1),&#160;Func(y,&#160;l2))&#160;-&gt;&#160;if&#160;x&lt;&gt;y&#160;then&#160;raise&#160;Impossible<br/>
82<br/>
<hr/>
<a name=83></a>else&#160;(unifliste&#160;l1&#160;l2&#160;[])<br/>
and&#160;unifliste&#160;l1&#160;l2&#160;sigma&#160;=<br/>
match&#160;(l1,&#160;l2)&#160;with<br/>
|&#160;([],&#160;_)&#160;-&gt;&#160;sigma<br/>
|&#160;(h1::t1,&#160;h2::t2)&#160;-&gt;<br/>
begin<br/>
let&#160;sigma1&#160;=&#160;(unificateur&#160;h1&#160;h2)&#160;in<br/>
unifliste&#160;(map&#160;(function&#160;terme&#160;-&gt;&#160;(substituer&#160;terme&#160;sigma1))&#160;t1)<br/>
(map&#160;(function&#160;terme&#160;-&gt;&#160;(substituer&#160;terme&#160;sigma1))&#160;t2)<br/>
(compose_subst&#160;sigma&#160;sigma1)<br/>
end<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;Impossible<br/>
in&#160;unificateur&#160;t1&#160;t2<br/>
<b>5.5</b><br/>
<b>Un&#160;mini&#160;PROLOG</b><br/>
let&#160;question()&#160;=<br/>
begin<br/>
print_string&#160;&#34;\n&#160;autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:&#34;&#160;;<br/>
if&#160;read_int()=&#160;1<br/>
then&#160;false&#160;else&#160;true<br/>
end<br/>
let&#160;autre_solution&#160;lvar&#160;lvaleur<br/>
=<br/>
if&#160;lvaleur&#160;&lt;&gt;&#160;[]&#160;then&#160;(affiche_solution&#160;lvar&#160;lvaleur&#160;;&#160;question())<br/>
else&#160;false<br/>
let&#160;prolog&#160;but&#160;lregles&#160;=<br/>
let&#160;lvar_but&#160;=&#160;listevar&#160;but&#160;in<br/>
let&#160;rec&#160;prouveli&#160;lbuts&#160;lvaleur&#160;=<br/>
match&#160;lbuts&#160;with<br/>
|&#160;[]&#160;-&gt;&#160;autre_solution&#160;lvar_but&#160;lvaleur<br/>
|&#160;h::t&#160;-&gt;<br/>
some&#160;(fun&#160;regle&#160;-&gt;<br/>
try<br/>
let&#160;regle_bis&#160;=&#160;(renomme&#160;regle)&#160;in<br/>
let&#160;sigma1&#160;=&#160;unifier&#160;h&#160;(hd&#160;regle_bis)&#160;in<br/>
prouveli<br/>
(sublis&#160;sigma1&#160;((lhypotheses&#160;regle_bis)&#160;@&#160;t))<br/>
(sublis&#160;sigma1&#160;lvaleur)<br/>
with&#160;Impossible&#160;-&gt;&#160;false)<br/>
lregles<br/>
in<br/>
prouveli&#160;[but]&#160;lvar_but<br/>
83<br/>
<hr/>
<a name=84></a><b>5.6</b><br/>
<b>Quelques&#160;exemples&#160;de&#160;programmation&#160;en&#160;PROLOG</b><br/>
<b>5.6.1</b><br/>
<b>Les&#160;entiers&#160;naturels</b><br/>
Définissons&#160;en&#160;PROLOG&#160;le&#160;type&#160;des&#160;entiers&#160;naturels&#160;avec&#160;la&#160;fonction&#160;nat&#160;d’arité&#160;1,&#160;la&#160;fonction<br/>
s&#160;d’arité&#160;1&#160;et&#160;la&#160;constante&#160;0.&#160;Nous&#160;avons&#160;ainsi&#160;les&#160;2&#160;règles&#160;:<br/>
<i>nat</i>(0)&#160;⇐<br/><i>nat</i>(<i>s</i>(<i>x</i>))&#160;⇐&#160;<i>nat</i>(<i>x</i>)<br/>
---------------------------------------------------<br/>
let&#160;nat&#160;=&#160;[&#160;[Func(&#34;nat&#34;,&#160;[Func(&#34;0&#34;,&#160;[])])]&#160;;<br/>
[Func(&#34;nat&#34;,&#160;[Func(&#34;s&#34;,[Var(&#34;X&#34;)])])&#160;;&#160;Func(&#34;nat&#34;,&#160;[Var(&#34;X&#34;)])]&#160;]&#160;;;<br/>
let&#160;but&#160;=&#160;Func(&#34;nat&#34;,&#160;[Var(&#34;X&#34;)])&#160;;;<br/>
prolog&#160;but&#160;nat&#160;;;<br/>
----------------------------------------------------<br/>
vincent@HP-Notebook:~/workspace&#160;vscodium$&#160;./prolog.byte<br/>
X<br/>
&lt;-&gt;<br/>
0<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
X<br/>
&lt;-&gt;&#160;(s&#160;0&#160;)<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
X<br/>
&lt;-&gt;&#160;(s(s&#160;0&#160;))<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
X<br/>
&lt;-&gt;&#160;(s(s(s&#160;0&#160;)))<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:2<br/>
vincent@HP-Notebook:~/workspace&#160;vscodium$<br/>
<b>5.6.2</b><br/>
<b>Les&#160;additions&#160;de&#160;Peano</b><br/>
Nous&#160;pouvons&#160;modéliser&#160;les&#160;additions&#160;avec&#160;l’arithmétique&#160;de&#160;Peano&#160;en&#160;utilisant&#160;les&#160;deux&#160;propo-<br/>
sitions&#160;suivantes&#160;:<br/>
<i>add</i>(<i>x,&#160;</i>0<i>,&#160;x</i>)&#160;⇐<br/><i>add</i>(<i>x,&#160;s</i>(<i>y</i>)<i>,&#160;s</i>(<i>z</i>))&#160;⇐&#160;<i>add</i>(<i>x,&#160;y,&#160;z</i>)<br/>
Puis&#160;demandons&#160;à&#160;notre&#160;mini&#160;Prolog&#160;de&#160;résoudre&#160;l’équation&#160;<i>add</i>(<i>x,&#160;y,&#160;s</i>(<i>s</i>(<i>s</i>(0))))<br/>
(*&#160;les&#160;entiers&#160;de&#160;peano&#160;*)<br/>
let&#160;peano&#160;=&#160;[&#160;[Func(&#34;add&#34;,&#160;[Var(&#34;x&#34;);&#160;Func(&#34;0&#34;,&#160;[]);&#160;Var(&#34;x&#34;)])&#160;]&#160;;<br/>
[Func(&#34;add&#34;,&#160;[Var(&#34;x&#34;);<br/>
Func(&#34;S&#34;,&#160;[Var(&#34;y&#34;)])&#160;;&#160;Func(&#34;S&#34;,&#160;[Var(&#34;z&#34;)])])&#160;;<br/>
Func(&#34;add&#34;,&#160;[Var(&#34;x&#34;);&#160;Var(&#34;y&#34;);&#160;Var(&#34;z&#34;)])]<br/>
]&#160;;;<br/>
let&#160;but1&#160;=&#160;Func(&#34;add&#34;,&#160;[Var(&#34;x&#34;)&#160;;&#160;Var(&#34;y&#34;)&#160;;&#160;Func(&#34;S&#34;,&#160;[Func(&#34;S&#34;,&#160;[Func(&#34;S&#34;,&#160;[Func(&#34;0&#34;,&#160;[])])])])])&#160;;;<br/>
vincent@HP-Notebook:~/vsc$&#160;./prolog.byte<br/>
x<br/>
&lt;-&gt;&#160;(S(S(S&#160;0&#160;)))&#160;y<br/>
&lt;-&gt;<br/>
0<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
x<br/>
&lt;-&gt;&#160;(S(S&#160;0&#160;))&#160;y<br/>
&lt;-&gt;&#160;(S&#160;0&#160;)<br/>
84<br/>
<hr/>
<a name=85></a>autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
x<br/>
&lt;-&gt;&#160;(S&#160;0&#160;)&#160;y<br/>
&lt;-&gt;&#160;(S(S&#160;0&#160;))<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
x<br/>
&lt;-&gt;<br/>
0<br/>
y<br/>
&lt;-&gt;&#160;(S(S(S&#160;0&#160;)))<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
vincent@HP-Notebook:~/vsc$<br/>
<b>5.6.3</b><br/>
<b>Programmation&#160;&#34;logique&#34;&#160;en&#160;COQ</b><br/>
L’utilisation&#160;des&#160;types&#160;dépendants&#160;en&#160;COQ&#160;nous&#160;permet&#160;également&#160;de&#160;définir&#160;les&#160;relations&#160;PRO-<br/>
LOG.<br/>
Inductive&#160;<i>entier&#160;</i>:=<br/>|&#160;<i>O&#160;</i>:&#160;<i>entier<br/></i>|&#160;<i>S&#160;</i>:&#160;<i>entier&#160;</i>→&#160;<i>entier</i>.<br/>
Fixpoint&#160;<i>somme&#160;</i>(<i>e1&#160;e2&#160;</i>:<i>entier&#160;</i>)&#160;:<i>entier&#160;</i>:=<br/>
match&#160;<i>e1&#160;</i>with<br/>|&#160;<i>O&#160;</i>⇒&#160;<i>e2<br/></i>|&#160;<i>S&#160;e1&#160;</i>⇒&#160;<i>S&#160;</i>(<i>somme&#160;e1&#160;e2&#160;</i>)<br/>end.<br/>
Lemma&#160;<i>somme&#160;O&#160;</i>:&#160;∀&#160;<i>e&#160;</i>:<i>entier</i>,&#160;<i>somme&#160;e&#160;O&#160;</i>=&#160;<i>e</i>.<br/>
Proof.<br/>
intro&#160;<i>e</i>.<br/>
induction&#160;<i>e</i>.<br/>
simpl.&#160;reflexivity.<br/>
simpl.&#160;rewrite&#160;<i>IHe</i>.&#160;reflexivity.<br/>
Qed.<br/>
Lemma&#160;<i>somme&#160;S&#160;</i>:&#160;∀&#160;(<i>e1&#160;e2&#160;</i>:<i>entier&#160;</i>),&#160;<i>somme&#160;e1&#160;</i>(<i>S&#160;e2&#160;</i>)=&#160;<i>S&#160;</i>(<i>somme&#160;e1&#160;e2&#160;</i>).<br/>
Proof.<br/>
intros.<br/>
induction&#160;<i>e1</i>.&#160;simpl.&#160;reflexivity.<br/>
simpl.<br/>
rewrite&#160;<i>IHe1</i>.&#160;reflexivity.<br/>
Qed.<br/>
Compute&#160;<i>somme&#160;</i>(<i>S&#160;O</i>)&#160;(<i>S&#160;O</i>).<br/>
Inductive&#160;<i>sommeProlog&#160;</i>:&#160;<i>entier&#160;</i>→&#160;<i>entier&#160;</i>→&#160;<i>entier&#160;</i>→&#160;Prop&#160;:=<br/>|&#160;<i>SommeO&#160;</i>:&#160;∀&#160;<i>x</i>,&#160;<i>sommeProlog&#160;x&#160;O&#160;x<br/></i>|&#160;<i>SommeS&#160;</i>:&#160;∀&#160;<i>x&#160;y&#160;z</i>,&#160;<i>sommeProlog&#160;x&#160;y&#160;z&#160;</i>→&#160;<i>sommeProlog&#160;x&#160;</i>(<i>S&#160;y</i>)&#160;(<i>S&#160;z</i>).<br/>
Example&#160;<i>un&#160;plus&#160;un&#160;</i>:&#160;<i>sommeProlog&#160;</i>(<i>S&#160;O</i>)&#160;(<i>S&#160;O</i>)&#160;(<i>S&#160;</i>(<i>S&#160;O</i>)).<br/>
Proof.<br/>
apply&#160;<i>SommeS</i>.&#160;apply&#160;<i>SommeO</i>.<br/>
Defined.<br/>
Theorem&#160;<i>somme&#160;deux&#160;entiers&#160;</i>:&#160;∀&#160;<i>e1&#160;e2</i>,&#160;<i>sommeProlog&#160;e1&#160;e2&#160;</i>(<i>somme&#160;e1&#160;e2&#160;</i>).<br/>
Proof.<br/>
intros&#160;<i>e1&#160;e2</i>.<br/>
85<br/>
<hr/>
<a name=86></a>induction&#160;<i>e2</i>.<br/>
rewrite&#160;<i>somme&#160;O</i>.<br/>
apply&#160;<i>SommeO</i>.<br/>
rewrite&#160;<i>somme&#160;S</i>.<br/>
apply&#160;<i>SommeS</i>.<br/>
exact&#160;<i>IHe2</i>.<br/>
Qed.<br/>
<b>5.6.4</b><br/>
<b>La&#160;base&#160;généalogique</b><br/>
(*&#160;généalogie&#160;*)<br/>
let&#160;grecs&#160;=&#160;[&#160;[Func(&#34;mere&#34;,&#160;[Func(&#34;gaia&#34;,[]);Func(&#34;chronos&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;mere&#34;,&#160;[Func(&#34;rhea&#34;,[]);Func(&#34;zeus&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;mere&#34;,&#160;[Func(&#34;rhea&#34;,[]);Func(&#34;hades&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;pere&#34;,&#160;[Func(&#34;zeus&#34;,[]);Func(&#34;pollux&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;pere&#34;,&#160;[Func(&#34;ourance&#34;,[]);Func(&#34;chronos&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;pere&#34;,&#160;[Func(&#34;chronos&#34;,[]);Func(&#34;zeus&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;pere&#34;,&#160;[Func(&#34;zeus&#34;,[]);Func(&#34;helene&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;pere&#34;,&#160;[Func(&#34;zeux&#34;,[]);Func(&#34;castor&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;pere&#34;,&#160;[Func(&#34;gaia&#34;,[]);Func(&#34;chronos&#34;,[])&#160;]&#160;)&#160;]&#160;;<br/>
[Func(&#34;parent&#34;,&#160;[Var(&#34;x&#34;);&#160;Var(&#34;y&#34;)])&#160;;&#160;Func(&#34;pere&#34;,&#160;[Var(&#34;x&#34;);&#160;Var(&#34;y&#34;)])&#160;]<br/>
;<br/>
[Func(&#34;parent&#34;,&#160;[Var(&#34;x&#34;);&#160;Var(&#34;y&#34;)])&#160;;&#160;Func(&#34;mere&#34;,&#160;[Var(&#34;x&#34;);&#160;Var(&#34;y&#34;)])&#160;]<br/>
;<br/>
[Func(&#34;gd-parent&#34;,&#160;[Var(&#34;i&#34;);&#160;Var(&#34;k&#34;)])&#160;;&#160;Func(&#34;parent&#34;,&#160;[Var(&#34;i&#34;);&#160;Var(&#34;j&#34;)])&#160;;<br/>
Func(&#34;parent&#34;,&#160;[Var(&#34;j&#34;);&#160;Var(&#34;k&#34;)])]&#160;;<br/>
[Func(&#34;frere&#34;,&#160;[Var(&#34;y&#34;);&#160;Var(&#34;z&#34;)])&#160;;&#160;Func(&#34;parent&#34;,&#160;[Var(&#34;x&#34;);&#160;Var(&#34;y&#34;)])&#160;;<br/>
Func(&#34;parent&#34;,&#160;[Var(&#34;x&#34;);&#160;Var(&#34;z&#34;)])]<br/>
]&#160;;;<br/>
let&#160;but&#160;=&#160;Func(&#34;gd-parent&#34;,&#160;[Func(&#34;chronos&#34;,&#160;[])&#160;;&#160;Var(&#34;x&#34;)])&#160;;;<br/>
vincent@HP-Notebook:~/vsc$&#160;./prolog.byte<br/>
x<br/>
&lt;-&gt;<br/>
pollux<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
x<br/>
&lt;-&gt;<br/>
helene<br/>
autre&#160;solution&#160;1/2&#160;(1=oui,&#160;2=non)&#160;?&#160;:1<br/>
<b>5.7</b><br/>
<b>L’algorithme&#160;de&#160;complétion&#160;de&#160;Knuth-Bendix</b><br/>
<b>5.7.1</b><br/>
<b>Confluence&#160;et&#160;paires&#160;critiques</b><br/>
Le&#160;lemme&#160;de&#160;Newman&#160;nous&#160;dit&#160;qu’un&#160;système&#160;de&#160;réécriture&#160;noethérien&#160;(qui&#160;termine)&#160;est<br/>
confluent&#160;ssi&#160;il&#160;est&#160;localement&#160;confluent.<br/>
La&#160;situation&#160;générale&#160;se&#160;présente&#160;comme&#160;cela&#160;:<br/>
86<br/>
<hr/>
<a name=87></a><i>s</i><br/>
<i>l</i>1&#160;→&#160;<i>r</i>1<br/>
<i>l</i>2&#160;→&#160;<i>r</i>2<br/>
<i>t</i>1<br/>
<i>t</i>2<br/>
∗<br/>
∗<br/>
La&#160;confluence&#160;locale&#160;sera&#160;assurée&#160;si&#160;nous&#160;trouvons&#160;un&#160;terme&#160;<i>t&#160;</i>tel&#160;que&#160;<i>t</i>1&#160;→&#160;<i>t&#160;</i>←&#160;<i>t</i>2<br/>
Nous&#160;avons&#160;ainsi&#160;2&#160;règles&#160;<i>l</i>1&#160;→&#160;<i>r</i>1&#160;et&#160;<i>l</i>2&#160;→&#160;<i>r</i>2.&#160;Cela&#160;donne&#160;par&#160;définition&#160;de&#160;la&#160;réécriture&#160;:<br/>
<i>s</i>|<i>p&#160;</i>=&#160;<i>σ</i><br/>
1<br/>
1<i>l</i>1&#160;<i>avec&#160;t</i>1&#160;=&#160;<i>s</i>[<i>σ</i>1<i>r</i>1]<i>p</i>1<br/>
<i>s</i>|<i>p&#160;</i>=&#160;<i>σ</i><br/>
2<br/>
2<i>l</i>2&#160;<i>avec&#160;t</i>2&#160;=&#160;<i>s</i>[<i>σ</i>2<i>r</i>2]<i>p</i>2<br/>
∗<br/>
∗<br/>
On&#160;montre&#160;facilement&#160;(de&#160;manière&#160;visuelle)&#160;que&#160;nous&#160;pouvons&#160;trouver&#160;<i>t</i>1&#160;→&#160;<i>t&#160;</i>←&#160;<i>t</i>2&#160;lorsque&#160;<i>p</i>1&#160;et<br/>
∗<br/>
∗<br/>
<i>p</i>2&#160;ne&#160;se&#160;chevauchent&#160;pas.&#160;Et&#160;lorsqu’il&#160;y&#160;a&#160;chevauchement,&#160;on&#160;peut&#160;également&#160;trouver&#160;<i>t</i>1&#160;→&#160;<i>t&#160;</i>←&#160;<i>t</i>2<br/>si&#160;la&#160;position&#160;de&#160;<i>σ</i>2<i>l</i>2&#160;dans&#160;<i>l</i>1&#160;est&#160;une&#160;variable.<br/>
Sinon,&#160;il&#160;y&#160;a&#160;un&#160;chevauchement&#160;<i>critique&#160;</i>:<br/>
<i>σ</i>1<i>l</i>1<br/>
<i>σ</i>2<i>l</i>2<br/>
(1)<br/>
(2)<br/>
<i>σ</i>1<i>r</i>1<br/>
<i>σ</i>1<i>l</i>1<br/>
<i>σ</i>2<i>r</i>2<br/>
Posons&#160;<i>θ&#160;</i>=&#160;<i>σ</i>1&#160;∪&#160;<i>σ</i>2,&#160;l’unificateur&#160;principal&#160;de&#160;<i>σ</i>1&#160;et&#160;<i>σ</i>2.&#160;Nous&#160;appelerons&#160;la&#160;paire&#160;des&#160;deux&#160;termes<br/>
en&#160;bleu&#160;et&#160;rouge&#160;une&#160;<i>paire&#160;critique&#160;&lt;&#160;θr</i>1<i>,&#160;</i>(<i>θl</i>1)[<i>θr</i>2]<i>p&#160;&gt;&#160;</i>Si&#160;deux&#160;règles&#160;génèrent&#160;une&#160;paire&#160;critique,<br/>on&#160;dit&#160;qu’elles&#160;se&#160;superposent.&#160;L’existence&#160;de&#160;paires&#160;critiques&#160;est&#160;un&#160;signe&#160;d’ambiguïté&#160;du&#160;système<br/>de&#160;réécriture.<br/>
Si&#160;ces&#160;paires&#160;critiques&#160;sont&#160;joignable,&#160;le&#160;système&#160;de&#160;réécriture&#160;est&#160;alors&#160;localement&#160;confluent.<br/>
<b>Théorème&#160;4&#160;</b>(Knuth-Bendix)<b>.&#160;</b><i>Un&#160;système&#160;de&#160;réécriture&#160;noethérien&#160;est&#160;confluent&#160;si&#160;ses&#160;paires<br/>critiques&#160;sont&#160;joignables.</i><br/>
let&#160;superpose&#160;l1&#160;l2&#160;=<br/>
let&#160;rec&#160;super&#160;l1&#160;l2&#160;occ&#160;=<br/>
match&#160;occ&#160;with<br/>
|&#160;a::b&#160;-&gt;<br/>
begin<br/>
try<br/>
let&#160;t&#160;=&#160;cut&#160;a&#160;l1&#160;in<br/>
match&#160;t&#160;with<br/>
|&#160;Var&#160;_&#160;-&gt;&#160;raise&#160;Impossible<br/>
87<br/>
<hr/>
<a name=88></a>|&#160;_&#160;-&gt;&#160;let&#160;sigma&#160;=&#160;unifier&#160;((cut&#160;a&#160;l1),&#160;l2)<br/>
in&#160;(a,&#160;sigma)<br/>
with&#160;Impossible&#160;-&gt;&#160;super&#160;l1&#160;l2&#160;b<br/>
end<br/>
|&#160;[]&#160;-&gt;&#160;raise&#160;Impossible<br/>
in&#160;super&#160;l1&#160;l2&#160;(occurences&#160;0&#160;l1)<br/>
let&#160;rec&#160;cp&#160;(l1,r1)&#160;(l2,r2)&#160;=<br/>
let&#160;(oc,&#160;sigma)&#160;=&#160;superpose&#160;l1&#160;l2&#160;in<br/>
((substituer<br/>
r1&#160;sigma),&#160;(greffe&#160;oc&#160;(substituer&#160;l1&#160;sigma)&#160;(substituer&#160;r2&#160;sigma)))&#160;;;<br/>
<b>5.7.2</b><br/>
<b>Terminaison</b><br/>
<b>Indécidabilité&#160;de&#160;la&#160;terminaison&#160;dans&#160;le&#160;cas&#160;&#34;général&#34;</b><br/>
Soient&#160;<i>a</i>1<i>,&#160;a</i>2<i>,&#160;a</i>3<i>,&#160;.&#160;.&#160;.&#160;</i>une&#160;numérotation&#160;de&#160;tous&#160;les&#160;algorithmes.&#160;On&#160;définit&#160;la&#160;fonction&#160;suivante&#160;:<br/>
<i>diag</i>(<i>i</i>)&#160;≡&#160;si&#160;<i>ai&#160;</i>termine&#160;alors&#160;boucler,&#160;sinon&#160;s’arrêter<br/>
Pour&#160;tout&#160;<i>i</i>,&#160;<i>diag</i>(<i>i</i>)&#160;termine&#160;ssi&#160;<i>ai&#160;</i>ne&#160;termine&#160;pas.&#160;Mais&#160;il&#160;y&#160;a&#160;un&#160;<i>aj&#160;</i>tel&#160;que&#160;<i>diag&#160;</i>=&#160;<i>aj&#160;</i>.&#160;Nous<br/>
avons&#160;donc&#160;<i>diag</i>(<i>j</i>)&#160;termine&#160;ssi&#160;<i>aj&#160;</i>ne&#160;termine&#160;pas,&#160;ce&#160;qui&#160;donne&#160;<i>aj&#160;</i>termine&#160;ssi&#160;<i>aj&#160;</i>ne&#160;termine&#160;pas.<br/>
De&#160;manière&#160;peut-être&#160;plus&#160;formelle,&#160;en&#160;mettant&#160;en&#160;évidence&#160;la&#160;diagonalisation&#160;négative&#160;de&#160;Can-<br/>
tor&#160;:<br/>
Soit&#160;<i>f&#160;</i>(<i>x,&#160;y</i>)&#160;la&#160;fonction&#160;de&#160;terminaison&#160;de&#160;l’algorithme&#160;<i>ax&#160;</i>sur&#160;l’entrée&#160;<i>y</i>.&#160;On&#160;peut&#160;définir&#160;<i>f&#160;</i>(<i>x,&#160;y</i>)<br/>
comme&#160;<i>f&#160;</i>(<i>x,&#160;y</i>)&#160;=&#160;1&#160;si&#160;<i>ax&#160;</i>termine&#160;sur&#160;<i>y&#160;</i>et&#160;0&#160;sinon.&#160;Soit&#160;<i>g&#160;</i>telle&#160;que&#160;<i>g</i>(0)&#160;=&#160;1&#160;et&#160;<i>g</i>(1)&#160;=&#160;0&#160;Considérons<br/><i>h</i>(<i>i</i>)&#160;=&#160;<i>g</i>(<i>f&#160;</i>(<i>i,&#160;i</i>)).&#160;Alors&#160;on&#160;a&#160;<i>f&#160;</i>(<i>a,&#160;a</i>)&#160;=&#160;<i>h</i>(<i>a</i>)&#160;=&#160;<i>g</i>(<i>f&#160;</i>(<i>a,&#160;a</i>))&#160;6=&#160;<i>f&#160;</i>(<i>a,&#160;a</i>)&#160;car&#160;<i>g&#160;</i>n’admet&#160;pas&#160;de&#160;point&#160;fixe.<br/>C’est-à-dire&#160;que&#160;l’on&#160;ne&#160;peut&#160;décider&#160;si&#160;l’algorithme&#160;<i>aa&#160;</i>termine&#160;sur&#160;lui-même.<br/>
<b>Système&#160;de&#160;réécriture&#160;noethérien</b><br/>
Un&#160;système&#160;de&#160;réécriture&#160;est&#160;noethérien&#160;si&#160;et&#160;seulement&#160;s’il&#160;existe&#160;un&#160;ordre&#160;bien&#160;fondé&#160;&#160;sur<br/>
l’ensemble&#160;des&#160;termes&#160;tel&#160;que<br/>
i)&#160;<i>σP&#160;</i>&#160;<i>σQ&#160;</i>pour&#160;toute&#160;règle&#160;(<i>P,&#160;Q</i>)&#160;∈&#160;R&#160;et&#160;toute&#160;substitution&#160;<i>σ</i><br/>
ii)&#160;<i>Mi&#160;</i>&#160;<i>M&#160;</i>0&#160;entraîne&#160;<i>f&#160;M</i><br/>
<i>.&#160;.&#160;.&#160;M</i><br/>
<i>i</i><br/>
1&#160;<i>.&#160;.&#160;.&#160;Mi&#160;.&#160;.&#160;.&#160;Mn&#160;</i>&#160;<i>f&#160;M</i>1&#160;<i>.&#160;.&#160;.&#160;M&#160;</i>0<i>i</i><br/>
<i>n</i><br/>
On&#160;dit&#160;que&#160;&#160;est&#160;clos&#160;par&#160;substitution,&#160;et&#160;qu’il&#160;est&#160;compatible&#160;avec&#160;Σ.&#160;En&#160;pratique,&#160;on&#160;utilise<br/>
une&#160;fonction&#160;externe&#160;<i>h&#160;</i>:&#160;<i>T</i>Σ[<i>X</i>]&#160;→&#160;N&#160;et&#160;la&#160;relation&#160;d’ordre&#160;<i>&gt;&#160;</i>sur&#160;N.<br/>
Pour&#160;un&#160;terme&#160;<i>t&#160;</i>et&#160;une&#160;variable&#160;<i>x&#160;</i>,&#160;on&#160;note&#160;|<i>t</i>|&#160;le&#160;cardinal&#160;de&#160;<i>t&#160;</i>et&#160;|<i>t</i>|<i>x&#160;</i>le&#160;nombre&#160;d’occurrences<br/>
de&#160;<i>x&#160;</i>dans&#160;<i>t</i>.&#160;On&#160;définit&#160;un&#160;ordre&#160;strict&#160;&#160;sur&#160;<i>T&#160;</i>[<i>X</i>]&#160;par&#160;:<br/>
<i>s&#160;&gt;&#160;t&#160;</i>⇔&#160;|<i>s</i>|&#160;<i>&gt;&#160;</i>|<i>t</i>|&#160;<i>et&#160;</i>∀<i>x&#160;</i>∈&#160;<i>X,&#160;</i>|<i>s</i>|<i>x&#160;</i>≥&#160;|<i>t</i>|<i>x</i><br/>
<b>5.7.3</b><br/>
<b>Complétion&#160;de&#160;Knuth-Bendix</b><br/>
Nous&#160;pourrons&#160;ici&#160;nous&#160;référer&#160;au&#160;livre&#160;très&#160;didactique&#160;<i>Term&#160;Rewriting&#160;and&#160;All&#160;That</i><a href="documents.html#127">[6]</a><br/>
let&#160;rec&#160;super_liste&#160;l1&#160;l2&#160;occ&#160;=<br/>
match&#160;occ&#160;with<br/>
|&#160;a::b&#160;-&gt;<br/>
88<br/>
<hr/>
<a name=89></a>begin<br/>
try<br/>
let&#160;t&#160;=&#160;cut&#160;a&#160;l1&#160;in<br/>
match&#160;t&#160;with<br/>
|&#160;Var&#160;_&#160;-&gt;&#160;raise&#160;Impossible<br/>
|&#160;_&#160;-&gt;&#160;let&#160;sigma&#160;=&#160;unifier&#160;((cut&#160;a&#160;l1),&#160;l2)<br/>
in&#160;(a,&#160;sigma)<br/>
with&#160;Impossible&#160;-&gt;&#160;super_liste&#160;l1&#160;l2&#160;b<br/>
end<br/>
|&#160;[]&#160;-&gt;&#160;raise&#160;Impossible<br/>
let&#160;superpose_liste&#160;(l1,r1)&#160;(l2,r2)&#160;=<br/>
let&#160;rec&#160;superpose_liste_aux&#160;l1&#160;l2&#160;occ&#160;=&#160;(*&#160;rend&#160;liste&#160;des&#160;occurences&#160;et&#160;substitution&#160;*)<br/>
if<br/>
alpha_equiv&#160;(l1,r1)&#160;(l2,r2)&#160;then<br/>
try<br/>
let&#160;(oc,&#160;sigma)&#160;=&#160;super_liste&#160;l1&#160;(rename&#160;l2&#160;l1)&#160;(remove&#160;0&#160;occ)&#160;(*&#160;retire&#160;0&#160;car&#160;occurence&#160;triviale&#160;si&#160;alpha_equiv&#160;*)<br/>
in<br/>
begin<br/>
print_string&#160;&#34;superposition&#160;à&#160;l’occurence&#160;&#34;;&#160;print_int&#160;oc&#160;;<br/>
print_string&#160;&#34;\n&#34;&#160;;<br/>
print_string&#160;&#34;sur&#160;le&#160;termes&#160;l1&#160;:&#34;&#160;;&#160;imprime&#160;l1&#160;;&#160;print_string&#160;&#34;\n&#34;&#160;;<br/>
print_string&#160;&#34;sur&#160;le&#160;terme&#160;l2&#160;:&#34;&#160;;&#160;imprime&#160;l2&#160;;&#160;print_string&#160;&#34;\n&#34;&#160;;<br/>
print_string&#160;&#34;avec&#160;la&#160;substitution&#160;:&#34;;&#160;imprime_sigma&#160;sigma;&#160;print_string&#160;&#34;\n&#34;&#160;;<br/>
(oc,&#160;sigma)::superpose_liste_aux&#160;l1&#160;l2&#160;(remove&#160;oc&#160;occ)<br/>
end<br/>
with&#160;Impossible&#160;-&gt;&#160;[]<br/>
else<br/>
try<br/>
let&#160;(oc,&#160;sigma)&#160;=&#160;super_liste&#160;l1&#160;(rename&#160;l2&#160;l1)&#160;occ<br/>
in<br/>
begin&#160;print_string&#160;&#34;superposition&#160;à&#160;l’occurence&#160;&#34;;&#160;print_int&#160;oc&#160;;<br/>
print_string&#160;&#34;\n&#34;&#160;;<br/>
print_string&#160;&#34;sur&#160;le&#160;terme&#160;l1&#160;:&#34;&#160;;&#160;imprime&#160;l1&#160;;&#160;print_string&#160;&#34;\n&#34;&#160;;<br/>
print_string&#160;&#34;sur&#160;le&#160;terme&#160;l2&#160;:&#34;&#160;;&#160;imprime&#160;l2&#160;;&#160;print_string&#160;&#34;\n&#34;&#160;;<br/>
print_string&#160;&#34;avec&#160;la&#160;substitution&#160;:&#34;;&#160;imprime_sigma&#160;sigma;&#160;print_string&#160;&#34;\n&#34;&#160;;<br/>
(oc,&#160;sigma)::superpose_liste_aux&#160;l1&#160;l2&#160;(remove&#160;oc&#160;occ)<br/>
end<br/>
with&#160;Impossible&#160;-&gt;&#160;[]<br/>
in&#160;superpose_liste_aux&#160;l1&#160;l2&#160;(occurences&#160;l1)&#160;;;<br/>
89<br/>
<hr/>
<a name=90></a>90<br/>
<hr/>
<a name=91></a><b>Chapitre&#160;6</b><br/>
<b>Calculabilité&#160;et&#160;complexité</b><br/>
<b>6.1</b><br/>
<b>Les&#160;fonctions&#160;récursives</b><br/>
Commençons&#160;par&#160;définir&#160;les&#160;fonctions&#160;récursives&#160;<i>primitives&#160;</i>telles&#160;que&#160;formalisées&#160;par&#160;Gödel.<br/>Un&#160;ensemble&#160;<i>E&#160;</i>de&#160;fonctions&#160;numériques&#160;de<br/>
<i>p</i><br/>
N&#160;dans&#160;N&#160;est&#160;dit&#160;:<br/>
i)&#160;clos&#160;par&#160;composition&#160;si&#160;pour&#160;tout&#160;<i>h,&#160;g</i>1<i>,&#160;.&#160;.&#160;.&#160;,&#160;gp&#160;</i>∈&#160;<i>E</i>,&#160;si&#160;on&#160;définit&#160;<i>f&#160;</i>par<br/>
<i>f&#160;</i>(<i>n</i>)&#160;=&#160;<i>h</i>(<i>g</i>1(<i>n</i>)<i>,&#160;.&#160;.&#160;.&#160;,&#160;gp</i>(<i>n</i>))<br/>
alors&#160;<i>f&#160;</i>∈&#160;<i>E</i><br/>
ii)&#160;clos&#160;par&#160;récursion&#160;primitive&#160;si&#160;pour&#160;tout&#160;<i>h,&#160;g&#160;</i>∈&#160;<i>E</i>,&#160;si&#160;on&#160;définit&#160;<i>f&#160;</i>par<br/>
<i>f&#160;</i>(0<i>,&#160;n</i>)&#160;=&#160;<i>g</i>(<i>n</i>)<br/>
<i>f&#160;</i>(<i>m&#160;</i>+&#160;1<i>,&#160;n</i>)&#160;=&#160;<i>h</i>(<i>f&#160;</i>(<i>m,&#160;n</i>)<i>,&#160;m,&#160;n</i>)<br/>
alors&#160;<i>f&#160;</i>∈&#160;<i>E</i><br/>
Les&#160;fonctions&#160;de&#160;base&#160;sont&#160;la&#160;constante&#160;0&#160;:&#160;N&#160;→&#160;N,&#160;le&#160;successeur&#160;<i>s&#160;</i>:&#160;N&#160;→&#160;N,&#160;les&#160;projections<br/><i>pri&#160;</i>:<br/>
<i>k&#160;</i>→<br/>
<i>k</i><br/>
N<br/>
N<br/>
Les&#160;fonctions&#160;récursives&#160;primitives&#160;sont&#160;les&#160;éléments&#160;du&#160;plus&#160;petit&#160;ensemble&#160;<i>E&#160;</i>contenant&#160;les<br/>
fonctions&#160;de&#160;base&#160;et&#160;clos&#160;par&#160;composition&#160;et&#160;récursion&#160;primitive.<br/>
La&#160;quasi&#160;totalité&#160;des&#160;fonctions&#160;est&#160;récursive&#160;primitive.&#160;Considérons&#160;par&#160;exemple&#160;l’addition.<br/>
0&#160;+&#160;<i>y&#160;</i>=&#160;<i>y</i><br/>
<i>s</i>(<i>x</i>)&#160;+&#160;<i>y&#160;</i>=&#160;<i>s</i>(<i>x&#160;</i>+&#160;<i>y</i>)<br/>
Autrement&#160;dit&#160;:<br/>
+(0<i>,&#160;y</i>)&#160;=&#160;<i>g</i>(<i>y</i>)&#160;avec&#160;<i>g&#160;</i>=&#160;<i>pr</i>11(<i>y</i>)<br/>
+(<i>s</i>(<i>x</i>)<i>,&#160;y</i>)&#160;=&#160;<i>h</i>(+(<i>x,&#160;y</i>)<i>,&#160;x,&#160;y</i>)&#160;avec&#160;<i>h&#160;</i>=&#160;<i>s&#160;</i>◦&#160;<i>pr</i>13<br/>
Voici&#160;un&#160;opérateur&#160;de&#160;récursion&#160;primitive&#160;en&#160;ML<br/>
let&#160;rec_prim&#160;g&#160;h&#160;=<br/>
let&#160;rec&#160;f&#160;m&#160;n&#160;=<br/>
if&#160;m=0&#160;then&#160;g&#160;n<br/>
else&#160;h&#160;(f&#160;(m-1)&#160;n)&#160;(m-1)&#160;n<br/>
in&#160;f<br/>
91<br/>
<hr/>
<a name=92></a>Nous&#160;pouvons&#160;ainsi&#160;exprimer&#160;la&#160;fonction&#160;add&#160;:<br/>
let&#160;s&#160;n&#160;=&#160;n+1&#160;;;<br/>
let&#160;pr_11&#160;n&#160;=&#160;n&#160;;;<br/>
let&#160;pr_31&#160;x&#160;y&#160;z&#160;=<br/>
x&#160;;;<br/>
let&#160;g&#160;y&#160;=&#160;pr_11&#160;y&#160;;;<br/>
let&#160;h&#160;x&#160;y&#160;z&#160;=<br/>
s&#160;(pr_31&#160;x&#160;y&#160;z);;<br/>
let&#160;add&#160;=&#160;rec_prim&#160;g&#160;h&#160;;;<br/>
utop&#160;#&#160;add&#160;5&#160;8&#160;;;<br/>
-&#160;:&#160;int&#160;=&#160;13<br/>
Toute&#160;fonction&#160;récursive&#160;primitive&#160;peut&#160;s’écrire&#160;avec&#160;une&#160;simple&#160;boucle&#160;for.&#160;Le&#160;nombre&#160;d’itérations<br/>est&#160;déterminé&#160;;&#160;il&#160;ne&#160;dépend&#160;pas&#160;d’une&#160;condition&#160;d’évaluation&#160;du&#160;programme.&#160;Ainsi,&#160;nous&#160;pouvons<br/>code&#160;de&#160;la&#160;manière&#160;suivante&#160;:<br/>
let&#160;add&#160;x&#160;y&#160;=<br/>
let&#160;r&#160;=&#160;ref&#160;(g&#160;y)&#160;in<br/>
(for&#160;i=1&#160;to&#160;x&#160;do&#160;r&#160;:=&#160;h&#160;!r&#160;i&#160;y&#160;done&#160;;<br/>
!r<br/>
)<br/>
Existe-t’il&#160;des&#160;fonctions&#160;caculables&#160;qui&#160;ne&#160;sont&#160;pas&#160;primitives&#160;récursives&#160;?&#160;La&#160;réponse&#160;est&#160;oui.&#160;No-<br/>tamment&#160;toute&#160;fonction&#160;qui&#160;ne&#160;termine&#160;pas&#160;(boucle&#160;while&#160;infinie)&#160;ne&#160;pourra&#160;s’écrire&#160;en&#160;fonction<br/>récursive&#160;primitive.&#160;Il&#160;est&#160;cependant&#160;beaucoup&#160;plus&#160;complexe&#160;d’identifier&#160;des&#160;fonctions&#160;qui&#160;terminent<br/>et&#160;qui&#160;soient&#160;non&#160;récursives&#160;primitives.&#160;La&#160;fonction&#160;d’<i>Ackermann&#160;</i>est&#160;traditionnelement&#160;donnée&#160;en<br/>exemple,&#160;bien&#160;que&#160;cette&#160;fonction&#160;n’a&#160;pas&#160;de&#160;réalité&#160;pratique.&#160;.&#160;.<br/>
La&#160;fonction&#160;d’Ackermann&#160;<i>A&#160;</i>est&#160;définie&#160;sur&#160;N&#160;×&#160;N&#160;par&#160;:<br/>
<i>A</i>(0<i>,&#160;p</i>)&#160;=&#160;<i>p&#160;</i>+&#160;1&#160;pour&#160;<i>p&#160;</i>≥&#160;0<br/><i>A</i>(<i>n,&#160;</i>0)&#160;=&#160;<i>A</i>(<i>n&#160;</i>−&#160;1<i>,&#160;</i>1)&#160;pour&#160;<i>n&#160;</i>≥&#160;1<br/><i>A</i>(<i>n,&#160;p</i>)&#160;=&#160;<i>A</i>(<i>n&#160;</i>−&#160;1<i>,&#160;A</i>(<i>n,&#160;p&#160;</i>−&#160;1))&#160;si&#160;<i>n&#160;</i>≥&#160;1<i>,&#160;p&#160;</i>≥&#160;1<br/>
let&#160;rec&#160;ack&#160;=&#160;function<br/>
|&#160;(0,p)&#160;-&gt;&#160;p+1<br/>
|&#160;(n,0)&#160;-&gt;&#160;ack&#160;(n-1,&#160;1)<br/>
|&#160;(n,p)&#160;-&gt;&#160;ack&#160;(n-1,&#160;ack&#160;(n,&#160;p-1))<br/>
La&#160;fonction&#160;d’Ackermann&#160;croît&#160;très&#160;rapidement,&#160;en&#160;particulier&#160;<i>n&#160;</i>→&#160;<i>A</i>(<i>n,&#160;n</i>)&#160;croît&#160;plus&#160;rapidement<br/>
que&#160;n’importe&#160;quelle&#160;fonction&#160;polynôme&#160;ou&#160;exponentielle.<br/>
Gödel&#160;a&#160;ainsi&#160;introduit&#160;un&#160;troisième&#160;critère&#160;permettant&#160;d’étendre&#160;le&#160;scope&#160;de&#160;définition&#160;des<br/>
fonctions&#160;numériques&#160;au-delà&#160;des&#160;fonctions&#160;récursives&#160;primitives.&#160;C’est&#160;le&#160;critère&#160;de&#160;clôture&#160;par<br/>minimisation&#160;totale.<br/>
Nous&#160;dirons&#160;qu’un&#160;ensemble&#160;<i>E&#160;</i>de&#160;fonctions&#160;numériques&#160;est&#160;clos&#160;par&#160;minimisation&#160;si&#160;pour&#160;tout<br/>
<i>g&#160;</i>∈&#160;<i>E</i>,&#160;tel&#160;que&#160;pour&#160;chaque&#160;<i>n</i>,&#160;il&#160;existe&#160;<i>p&#160;</i>tel&#160;que&#160;<i>g</i>(<i>n,&#160;p</i>)&#160;=&#160;0,&#160;si&#160;on&#160;définit&#160;<i>f&#160;</i>par<br/>
<i>f&#160;</i>(<i>n</i>)&#160;=&#160;<i>min</i>{<i>p&#160;</i>∈&#160;N;&#160;<i>g</i>(<i>n,&#160;p</i>)&#160;=&#160;0}<br/>
92<br/>
<hr/>
<a name=93></a>alors&#160;<i>f&#160;</i>∈&#160;<i>E</i>.&#160;On&#160;notera&#160;<i>f&#160;</i>=&#160;<i>µp</i>[<i>g</i>(<i>.,&#160;p</i>)&#160;=&#160;0].<br/>
Les&#160;<i>fonctions&#160;récursives&#160;</i>sont&#160;les&#160;éléments&#160;du&#160;plus&#160;petit&#160;ensemble&#160;de&#160;fonctions&#160;numériques&#160;conte-<br/>
nant&#160;les&#160;fonctions&#160;de&#160;base&#160;et&#160;clos&#160;par&#160;composition,&#160;récursion&#160;primitive&#160;et&#160;minimisation&#160;totale.<br/>
<b>6.2</b><br/>
<b>La&#160;machine&#160;de&#160;Turing</b><br/>
Une&#160;machine&#160;de&#160;Turing&#160;est&#160;un&#160;automate&#160;à&#160;état&#160;(<i>state&#160;machine</i>)&#160;qui&#160;a&#160;la&#160;capacité&#160;de&#160;lire&#160;puis<br/>
d’enregistrer&#160;un&#160;caractère&#160;sur&#160;une&#160;bande&#160;de&#160;longueur&#160;infinie.<br/>
La&#160;machine&#160;change&#160;d’état&#160;sur&#160;la&#160;base&#160;de&#160;trois&#160;éléments&#160;:&#160;l’état&#160;courant,&#160;le&#160;caractère&#160;lu&#160;de&#160;la<br/>
bande&#160;et&#160;une&#160;table&#160;externe&#160;de&#160;transition.&#160;La&#160;table&#160;de&#160;transition&#160;est&#160;externe&#160;à&#160;la&#160;bande&#160;et&#160;elle&#160;est<br/>statique.&#160;L’action&#160;résultante&#160;est&#160;un&#160;changement&#160;potentiel&#160;d’état,&#160;une&#160;écriture&#160;de&#160;caractère&#160;sur&#160;la<br/>bande&#160;et&#160;un&#160;déplacement&#160;à&#160;droite&#160;ou&#160;à&#160;gauche&#160;de&#160;la&#160;tête&#160;de&#160;lecture.<br/>
Nous&#160;implémentons&#160;cela&#160;avec&#160;le&#160;concept&#160;de&#160;<i>box&#160;</i>présenté&#160;dans&#160;le&#160;chapitre&#160;précédent.&#160;La&#160;lambda&#160;va<br/>
encapsuler&#160;l’état&#160;courant,&#160;la&#160;position&#160;de&#160;la&#160;tête&#160;de&#160;lecture,&#160;la&#160;bande&#160;et&#160;la&#160;table&#160;de&#160;transition.&#160;La&#160;table<br/>de&#160;transition&#160;est&#160;modélisée&#160;par&#160;une&#160;a-liste&#160;d’a-listes.&#160;La&#160;première&#160;a-liste&#160;permet&#160;de&#160;faire&#160;matcher<br/>l’état&#160;courant.&#160;La&#160;seconde&#160;a-liste&#160;permet&#160;de&#160;faire&#160;matcher&#160;le&#160;caractère&#160;lu.&#160;Ces&#160;deux&#160;informations<br/>combinées&#160;fournissent&#160;le&#160;triplet&#160;de&#160;sortie&#160;(état_suivant,&#160;caractère_écrit,&#160;direction)<br/>
let&#160;matable&#160;=&#160;[&#160;(&#34;q0&#34;&#160;,&#160;[&#160;(&#34;&gt;&#34;,&#160;(&#34;q1&#34;,&#160;&#34;X&#34;,&#160;&#34;G&#34;))&#160;;<br/>
(&#34;&lt;&#34;,&#160;(&#34;q0&#34;,&#160;&#34;&lt;&#34;,&#160;&#34;D&#34;))&#160;;<br/>
(&#34;&#160;&#34;,&#160;(&#34;q2&#34;,&#160;&#34;&#160;&#34;,&#160;&#34;G&#34;))&#160;;<br/>
(&#34;X&#34;,&#160;(&#34;q0&#34;,&#160;&#34;X&#34;,<br/>
&#34;D&#34;))&#160;])&#160;;<br/>
(&#34;q1&#34;&#160;,&#160;[&#160;(&#34;&gt;&#34;,&#160;(&#34;q1&#34;,&#160;&#34;&gt;&#34;,&#160;&#34;G&#34;))&#160;;<br/>
(&#34;&lt;&#34;,&#160;(&#34;q0&#34;,&#160;&#34;X&#34;,&#160;&#34;D&#34;))&#160;;<br/>
(&#34;&#160;&#34;,&#160;(&#34;qf&#34;,&#160;&#34;non&#34;,&#160;&#34;G&#34;))&#160;;<br/>
(&#34;X&#34;,&#160;(&#34;q1&#34;,&#160;&#34;X&#34;,&#160;&#34;G&#34;))&#160;])&#160;;<br/>
(&#34;q2&#34;&#160;,&#160;[&#160;(&#34;&gt;&#34;,&#160;(&#34;q2&#34;,&#160;&#34;&gt;&#34;,&#160;&#34;G&#34;))&#160;;<br/>
(&#34;&lt;&#34;,&#160;(&#34;qf&#34;,&#160;&#34;non&#34;,&#160;&#34;G&#34;))&#160;;<br/>
(&#34;&#160;&#34;,&#160;(&#34;qf&#34;,&#160;&#34;oui&#34;,&#160;&#34;G&#34;))&#160;;<br/>
(&#34;X&#34;,&#160;(&#34;q2&#34;,&#160;&#34;X&#34;,&#160;&#34;G&#34;))&#160;])&#160;;<br/>
]&#160;;;<br/>
Cette&#160;table&#160;de&#160;transition&#160;va&#160;nous&#160;permettre&#160;de&#160;vérifier&#160;le&#160;bon&#160;parenthésage&#160;d’une&#160;expression&#160;en<br/>
entrée&#160;fournie&#160;sur&#160;la&#160;bande&#160;représentée&#160;par&#160;une&#160;liste&#160;let&#160;mabande&#160;=<br/>
[&#34;&#160;&#34;;&#160;&#34;&lt;&#34;;&#160;&#34;&gt;&#34;;&#160;&#34;&#160;&#34;]<br/>
L’état&#160;q0&#160;va&#160;rechercher&#160;une&#160;parenthèse&#160;&gt;&#160;en&#160;allant&#160;vers&#160;la&#160;droite.<br/>L’état&#160;q1&#160;va&#160;rechercher&#160;une&#160;parenthèse&#160;&lt;&#160;en&#160;allant&#160;vers&#160;la&#160;gauche.<br/>L’état&#160;q2&#160;va&#160;rechercher&#160;une&#160;parenthèse&#160;&gt;&#160;en&#160;allant&#160;vers&#160;la&#160;gauche.<br/>Les&#160;parenthèses&#160;matchées&#160;sont&#160;remplacées&#160;par&#160;le&#160;caractère&#160;X.&#160;Le&#160;passage&#160;à&#160;l’état&#160;final&#160;qf&#160;est<br/>
accompagné&#160;par&#160;l’écriture&#160;oui&#160;ou&#160;non&#160;sur&#160;la&#160;bande&#160;suivant&#160;si&#160;l’expression&#160;est&#160;ou&#160;non&#160;correctement<br/>parenthésée.<br/>
let&#160;make_turing&#160;table&#160;etat0&#160;position0&#160;bande0&#160;=<br/>
let&#160;etat&#160;=&#160;ref&#160;etat0&#160;in<br/>
let&#160;position&#160;=&#160;ref&#160;position0&#160;in<br/>
let&#160;bande&#160;=&#160;ref&#160;bande0&#160;in<br/>
93<br/>
<hr/>
<a name=94></a>let&#160;fct_transition&#160;state&#160;input&#160;=&#160;assoc&#160;input&#160;(assoc&#160;state&#160;table)&#160;in<br/>
let&#160;lire&#160;()&#160;=&#160;nth&#160;!bande&#160;!position&#160;in<br/>
let&#160;deplacer&#160;=&#160;function<br/>
|&#160;&#34;G&#34;&#160;-&gt;&#160;if&#160;(!position&#160;=&#160;0)&#160;then&#160;(bande&#160;:=&#160;&#34;&#160;&#34;&#160;::&#160;!bande)&#160;else&#160;(position&#160;:=&#160;!position&#160;-&#160;1)<br/>
|&#160;&#34;D&#34;&#160;-&gt;<br/>
begin<br/>
position&#160;:=&#160;!position&#160;+&#160;1&#160;;<br/>
if&#160;((lire&#160;())&#160;=&#160;&#34;&#160;&#34;)&#160;then&#160;(bande&#160;:=&#160;!bande&#160;@&#160;(&#34;&#160;&#34;::&#160;[]))<br/>
end<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;Erreur<br/>
in<br/>
let&#160;rec&#160;liste_tail&#160;liste&#160;pos&#160;=<br/>
match&#160;pos&#160;with<br/>
|&#160;0&#160;-&gt;&#160;liste<br/>
|&#160;n&#160;-&gt;&#160;liste_tail&#160;(tl&#160;liste)&#160;(pos&#160;-&#160;1)<br/>
in<br/>
let&#160;rec&#160;liste_tete&#160;liste&#160;pos&#160;=<br/>
match&#160;pos&#160;with<br/>
|&#160;0&#160;-&gt;&#160;[]<br/>
|&#160;n&#160;-&gt;&#160;(hd&#160;liste)&#160;::&#160;liste_tete&#160;(tl&#160;liste)&#160;(pos&#160;-&#160;1)<br/>
in<br/>
let&#160;ecrire&#160;symb&#160;=<br/>
bande&#160;:=&#160;(liste_tete&#160;!bande&#160;!position)&#160;@&#160;(symb&#160;::&#160;[])&#160;@&#160;(&#160;liste_tail&#160;(tl&#160;!bande)&#160;!position)<br/>
in<br/>
fun&#160;instruction&#160;-&gt;<br/>
match&#160;instruction&#160;with<br/>
|&#160;&#34;executer&#34;&#160;-&gt;<br/>
let&#160;(e,&#160;s,&#160;d)&#160;=&#160;fct_transition&#160;!etat&#160;(lire&#160;())&#160;in<br/>
begin<br/>
ecrire&#160;s&#160;;<br/>
deplacer&#160;d;<br/>
etat&#160;:=&#160;e&#160;;<br/>
if&#160;(!etat&#160;=&#160;&#34;qf&#34;)&#160;then&#160;raise&#160;Final<br/>
end<br/>
|&#160;&#34;reset&#34;&#160;-&gt;&#160;begin&#160;etat&#160;:=&#160;etat0&#160;;&#160;bande&#160;:=&#160;bande0;&#160;position&#160;:=&#160;position0&#160;end<br/>
|&#160;&#34;affiche&#34;<br/>
-&gt;<br/>
begin&#160;print_string&#160;&#34;etat:&#34;&#160;;&#160;print_string&#160;!etat&#160;;<br/>
print_string&#160;&#34;<br/>
position:&#34;;&#160;print_int&#160;!position&#160;;<br/>
print_string&#160;&#34;<br/>
lire:&#34;;&#160;print_string&#160;(lire&#160;())&#160;;<br/>
print_string&#160;&#34;<br/>
bande:<br/>
&#34;;&#160;print_liste&#160;!bande<br/>
end<br/>
|&#160;_&#160;-&gt;&#160;raise&#160;Erreur<br/>
let&#160;executer_turing&#160;turing&#160;trace&#160;=<br/>
let&#160;rec&#160;iterer&#160;()&#160;=<br/>
94<br/>
<hr/>
<a name=95></a>turing&#160;&#34;executer&#34;&#160;;&#160;if&#160;trace&#160;then&#160;turing&#160;&#34;affiche&#34;;&#160;iterer&#160;()<br/>
in<br/>
begin<br/>
turing&#160;&#34;reset&#34;&#160;;<br/>
try<br/>
iterer&#160;()<br/>
with&#160;Final&#160;-&gt;&#160;turing&#160;&#34;affiche&#34;<br/>
end<br/>
Voici&#160;le&#160;résultat&#160;sur&#160;l’expression&#160;<i>&lt;&gt;</i><br/>
#&#160;let&#160;turing_par&#160;=&#160;make_turing&#160;matable&#160;etatinit&#160;posinit<br/>
[&#34;&#160;&#34;;&#160;&#34;&lt;&#34;;&#160;&#34;&gt;&#34;;&#160;&#34;&#160;&#34;]<br/>
;;<br/>
#&#160;executer_turing&#160;turing_par&#160;true&#160;;;<br/>
etat:q0<br/>
position:2<br/>
lire:&gt;<br/>
bande:<br/>
&lt;&gt;<br/>
etat:q1<br/>
position:1<br/>
lire:&lt;<br/>
bande:<br/>
&lt;X<br/>
etat:q0<br/>
position:2<br/>
lire:X<br/>
bande:<br/>
XX<br/>
etat:q0<br/>
position:3<br/>
lire:<br/>
bande:<br/>
XX<br/>
etat:q2<br/>
position:2<br/>
lire:X<br/>
bande:<br/>
XX<br/>
etat:q2<br/>
position:1<br/>
lire:X<br/>
bande:<br/>
XX<br/>
etat:q2<br/>
position:0<br/>
lire:<br/>
bande:<br/>
XX<br/>
etat:qf<br/>
position:0<br/>
lire:<br/>
bande:<br/>
ouiXX<br/>
Et&#160;voici&#160;le&#160;résultat&#160;sur&#160;l’expression&#160;<i>&lt;&lt;&gt;&lt;&gt;</i><br/>
#&#160;let&#160;turing_par&#160;=&#160;make_turing&#160;matable&#160;etatinit&#160;posinit<br/>
[&#34;&#160;&#34;;&#160;&#34;&lt;&#34;;&#160;&#34;&lt;&#34;;&#160;&#34;&gt;&#34;;&#160;&#34;&lt;&#34;;&#160;&#34;&gt;&#34;;&#160;&#34;&#160;&#34;]&#160;;;<br/>
#&#160;executer_turing&#160;turing_par&#160;true&#160;;;<br/>
etat:q0<br/>
position:2<br/>
lire:&lt;<br/>
bande:<br/>
&lt;&lt;&gt;&lt;&gt;<br/>
etat:q0<br/>
position:3<br/>
lire:&gt;<br/>
bande:<br/>
&lt;&lt;&gt;&lt;&gt;<br/>
etat:q1<br/>
position:2<br/>
lire:&lt;<br/>
bande:<br/>
&lt;&lt;X&lt;&gt;<br/>
etat:q0<br/>
position:3<br/>
lire:X<br/>
bande:<br/>
&lt;XX&lt;&gt;<br/>
etat:q0<br/>
position:4<br/>
lire:&lt;<br/>
bande:<br/>
&lt;XX&lt;&gt;<br/>
etat:q0<br/>
position:5<br/>
lire:&gt;<br/>
bande:<br/>
&lt;XX&lt;&gt;<br/>
etat:q1<br/>
position:4<br/>
lire:&lt;<br/>
bande:<br/>
&lt;XX&lt;X<br/>
etat:q0<br/>
position:5<br/>
lire:X<br/>
bande:<br/>
&lt;XXXX<br/>
etat:q0<br/>
position:6<br/>
lire:<br/>
bande:<br/>
&lt;XXXX<br/>
etat:q2<br/>
position:5<br/>
lire:X<br/>
bande:<br/>
&lt;XXXX<br/>
etat:q2<br/>
position:4<br/>
lire:X<br/>
bande:<br/>
&lt;XXXX<br/>
etat:q2<br/>
position:3<br/>
lire:X<br/>
bande:<br/>
&lt;XXXX<br/>
etat:q2<br/>
position:2<br/>
lire:X<br/>
bande:<br/>
&lt;XXXX<br/>
etat:q2<br/>
position:1<br/>
lire:&lt;<br/>
bande:<br/>
&lt;XXXX<br/>
etat:qf<br/>
position:0<br/>
lire:<br/>
bande:<br/>
nonXXXX<br/>
<b>6.3</b><br/>
<b>La&#160;thèse&#160;de&#160;Church</b><br/>
<b>Théorème&#160;5.&#160;</b><i>Thèse&#160;de&#160;Church&#160;:&#160;toute&#160;fonction&#160;effectivement&#160;calculable&#160;est&#160;récursive.</i><br/>
95<br/>
<hr/>
<a name=96></a><b>Théorème&#160;6.&#160;</b><i>Thèse&#160;forte&#160;de&#160;Church&#160;:&#160;si&#160;une&#160;fonction&#160;f&#160;est&#160;calculable&#160;par&#160;un&#160;algorithme,&#160;alors<br/>celui-ci&#160;est&#160;effectivement&#160;transformable&#160;en&#160;une&#160;machine&#160;de&#160;Turing&#160;calculant&#160;f</i><br/>
<b>Théorème&#160;7.&#160;</b><i>Pour&#160;f&#160;</i>:<br/>
<i>p</i><br/>
N&#160;→&#160;N<i>,&#160;les&#160;propriétés&#160;</i>(<i>i</i>)<i>f&#160;est&#160;λ-définissable&#160;et&#160;</i>(<i>ii</i>)<i>f&#160;est&#160;récursive&#160;sont</i><br/>
<i>équivalentes.</i><br/>
<b>6.4</b><br/>
<b>Complexité</b><br/>
<b>6.4.1</b><br/>
<b>Théorème&#160;de&#160;Cook</b><br/>
<b>Définition&#160;7.&#160;</b><i>Un&#160;problème&#160;est&#160;appelé&#160;NP-complet&#160;s’il&#160;vérifie&#160;les&#160;deux&#160;propriétés&#160;suivantes&#160;:</i><br/>
<i>1.&#160;Toute&#160;solution&#160;pourra&#160;être&#160;vérifiée&#160;en&#160;temps&#160;polynomial</i><br/>
<i>2.&#160;Tous&#160;les&#160;problèmes&#160;de&#160;la&#160;classe&#160;NP&#160;se&#160;ramènent&#160;à&#160;celui-ci&#160;via&#160;une&#160;réduction&#160;polynomiale</i><br/>
L’algorithme&#160;SAT&#160;est&#160;significatif&#160;car&#160;il&#160;a&#160;été&#160;prouvé&#160;comme&#160;étant&#160;<i>NP-complet</i>.<br/>
<b>Définition&#160;8.&#160;</b><i>SAT&#160;(satisfaisabilité&#160;en&#160;logique&#160;propositionnelle).<br/>Instance&#160;:&#160;une&#160;formule&#160;conjonctive&#160;φ&#160;</i>∈&#160;<i>P&#160;rop</i>[<i>X</i>]<br/><i>Requête&#160;:&#160;φ&#160;est-elle&#160;satisfaisable&#160;?</i><br/>
<b>Théorème&#160;8.&#160;</b><i>(COOK,&#160;1971)&#160;-&#160;Le&#160;problème&#160;SAT&#160;est&#160;NP-complet.</i><br/>
<b>Théorème&#160;9.&#160;</b><i>Conjecture&#160;:&#160;P&#160;</i>6=&#160;<i>N&#160;P</i><br/>
<b>6.4.2</b><br/>
<b>Implémentation&#160;de&#160;l’algorithme&#160;SAT</b><br/>
Pour&#160;des&#160;raisons&#160;d’efficacité,&#160;nous&#160;utilisons&#160;ici&#160;un&#160;principe&#160;de&#160;l’algorithme&#160;DPLL&#160;qui&#160;est&#160;la<br/>
<i>propagation&#160;unitaire</i>.&#160;L’algorithme&#160;recherche&#160;des&#160;solutions&#160;en&#160;parcourant&#160;l’arbre&#160;de&#160;recherche&#160;en<br/>profondeur.&#160;Cela&#160;s’implémente&#160;de&#160;manière&#160;intuitive&#160;avec&#160;une&#160;fonction&#160;récursive.&#160;L’algorithme&#160;s’ar-<br/>rête&#160;dès&#160;qu’une&#160;solution&#160;a&#160;été&#160;trouvée.<br/>
let&#160;sat&#160;c&#160;:&#160;(bool*env)&#160;=<br/>
let&#160;rec&#160;sat_aux&#160;c&#160;liste_litt&#160;e&#160;:&#160;(bool*env)<br/>
=<br/>
let&#160;c’&#160;=&#160;propag_unitaire&#160;c&#160;in<br/>
let&#160;e’&#160;=&#160;extend_env&#160;c’&#160;e&#160;in<br/>
if&#160;eval_cnf&#160;e’&#160;c’&#160;then&#160;(true,e’)<br/>
else<br/>
let&#160;liste_litt’&#160;=&#160;(diff&#160;(recup_litteral&#160;c’)&#160;(find_units_cnf2&#160;c’))&#160;in<br/>
match&#160;liste_litt’&#160;with<br/>
|&#160;hd::tl&#160;-&gt;&#160;let&#160;(b1,&#160;e1)&#160;=&#160;sat_aux&#160;([P&#160;hd]::c’)&#160;tl&#160;((hd,true)::e’)&#160;in<br/>
if&#160;b1&#160;then&#160;(b1,e1)<br/>
else&#160;sat_aux&#160;([N&#160;hd]::c’)&#160;tl&#160;((hd,&#160;false)::e’)<br/>
|&#160;[]&#160;-&gt;&#160;(false,&#160;[])<br/>
in&#160;sat_aux&#160;c&#160;(diff&#160;(recup_litteral&#160;c)&#160;(find_units_cnf2&#160;c))&#160;(init_env&#160;c)&#160;;;<br/>
Voici&#160;la&#160;fonction&#160;de&#160;progation&#160;unitaire.<br/>
96<br/>
<hr/>
<a name=97></a>let&#160;rec&#160;propag_unitaire&#160;c&#160;=<br/>
let&#160;units&#160;=&#160;find_units_cnf&#160;c<br/>
in<br/>
let&#160;rec&#160;propag_unitaire_aux&#160;c&#160;units&#160;=<br/>
match&#160;units&#160;with<br/>
|&#160;[]&#160;-&gt;&#160;c<br/>
|&#160;hd::tl&#160;-&gt;&#160;propag_unitaire_aux&#160;(map&#160;(retire_unit&#160;hd)&#160;c)&#160;tl<br/>
in<br/>
let&#160;res&#160;=&#160;propag_unitaire_aux&#160;c&#160;units<br/>
in&#160;if&#160;c=res&#160;then&#160;(filter&#160;(fun&#160;x&#160;-&gt;&#160;not&#160;(x=[]))&#160;c)&#160;else&#160;propag_unitaire&#160;res&#160;;;<br/>
(*&#160;on&#160;propage&#160;jusqu’à&#160;l’obtention&#160;d’un&#160;point&#160;fixe&#160;*)<br/>
Nous&#160;travaillons&#160;ici&#160;exclusivement&#160;sur&#160;des&#160;clauses&#160;normales&#160;conjonctives.&#160;Une&#160;clause&#160;normale<br/>
conjonctive&#160;est&#160;une&#160;une&#160;conjonction&#160;de&#160;plusieurs&#160;disjonctions&#160;de&#160;plusieurs&#160;littéraux.&#160;Un&#160;littéral&#160;est<br/>un&#160;atome&#160;ou&#160;la&#160;négation&#160;d’un&#160;atome.<br/>
type&#160;atome&#160;=<br/>
string&#160;;;<br/>
type&#160;lit&#160;=<br/>
P&#160;of&#160;atome&#160;|&#160;N&#160;of&#160;atome&#160;;;<br/>
type&#160;disj&#160;=&#160;lit&#160;list&#160;;;<br/>
type&#160;cnf&#160;=&#160;disj&#160;list&#160;;;<br/>
<b>6.4.3</b><br/>
<b>Sudoku&#160;-&#160;SAT&#160;encoding</b><br/>
L’algorithme&#160;permettant&#160;de&#160;résoudre&#160;les&#160;sudokus&#160;peut&#160;être&#160;réalisé&#160;par&#160;l’algorithme&#160;SAT&#160;en<br/>
modélisant&#160;les&#160;contraintes&#160;du&#160;sodoku&#160;sous&#160;la&#160;forme&#160;de&#160;clauses&#160;propositionnelles.&#160;Une&#160;variable&#160;<i>sxyz<br/></i>représente&#160;que&#160;la&#160;case&#160;de&#160;la&#160;ligne&#160;<i>x&#160;</i>et&#160;colonne&#160;<i>y&#160;</i>porte&#160;le&#160;nombre&#160;<i>z</i>.<br/>
1.&#160;Contrainte&#160;<i>C</i>1.&#160;Il&#160;y&#160;a&#160;au&#160;moins&#160;un&#160;nombre&#160;pour&#160;chaque&#160;case<br/>
9<br/>
9<br/>
9<br/>
^<br/>
^<br/>
_<br/>
<i>C</i>1&#160;,<br/>
<i>sxyz</i><br/>
<i>x</i>=1&#160;<i>y</i>=1&#160;<i>z</i>=1<br/>
2.&#160;Contrainte&#160;<i>C</i>2.&#160;Chaque&#160;nombre&#160;apparait&#160;au&#160;plus&#160;une&#160;fois&#160;dans&#160;une&#160;ligne<br/>
9<br/>
9<br/>
8<br/>
9<br/>
^<br/>
^<br/>
^<br/>
^<br/>
<i>C</i>2&#160;,<br/>
(¬<i>sxyz&#160;</i>∨&#160;¬<i>siyz</i>)<br/>
<i>y</i>=1&#160;<i>z</i>=1&#160;<i>x</i>=1&#160;<i>i</i>=<i>x</i>+1<br/>
3.&#160;Contrainte&#160;<i>C</i>3.&#160;Chaque&#160;nombre&#160;apparait&#160;au&#160;plus&#160;une&#160;fois&#160;dans&#160;une&#160;colonne<br/>
9<br/>
9<br/>
8<br/>
9<br/>
^<br/>
^<br/>
^<br/>
^<br/>
<i>C</i>3&#160;,<br/>
(¬<i>sxyz&#160;</i>∨&#160;¬<i>sxiz</i>)<br/>
<i>y</i>=1&#160;<i>z</i>=1&#160;<i>y</i>=1&#160;<i>i</i>=<i>y</i>+1<br/>
4.&#160;Contraintes&#160;<i>C</i>1&#160;et&#160;<i>C</i>5.&#160;Chaque&#160;nombre&#160;apparait&#160;au&#160;plus&#160;une&#160;fois&#160;dans&#160;une&#160;sous-grille&#160;3x3<br/>
9<br/>
2<br/>
3<br/>
3<br/>
3<br/>
^<br/>
^<br/>
^<br/>
^<br/>
^<br/>
<i>C</i>4&#160;,<br/>
(¬<i>s</i>(3<i>i</i>+<i>x</i>)(3<i>j</i>+<i>y</i>)<i>z&#160;</i>∨&#160;¬<i>s</i>(3<i>i</i>+<i>x</i>)(3<i>j</i>+<i>k</i>)<i>z</i>)<br/>
<i>z</i>=1&#160;<i>i</i>=0&#160;<i>x</i>=1&#160;<i>y</i>=1&#160;<i>k</i>=<i>y</i>+1<br/>
9<br/>
2<br/>
3<br/>
3<br/>
3<br/>
3<br/>
^<br/>
^<br/>
^<br/>
^<br/>
^<br/>
^<br/>
<i>C</i>5&#160;,<br/>
(¬<i>s</i>(3<i>i</i>+<i>x</i>)(3<i>j</i>+<i>y</i>)<i>z&#160;</i>∨&#160;¬<i>s</i>(3<i>i</i>+<i>k</i>)(3<i>j</i>+<i>l</i>)<i>z</i>)<br/>
<i>z</i>=1&#160;<i>i</i>=0&#160;<i>x</i>=1&#160;<i>y</i>=1&#160;<i>k</i>=<i>x</i>+1&#160;<i>l</i>=1<br/>
97<br/>
<hr/>
<a name=98></a>let&#160;produce_C1&#160;=<br/>
print_string&#160;&#34;let&#160;c1&#160;=&#160;[&#34;;<br/>for&#160;x=1&#160;to&#160;9&#160;do<br/>
for&#160;y=1&#160;to&#160;9&#160;do<br/>
print_string&#160;&#34;[&#34;&#160;;<br/>for&#160;z=1&#160;to&#160;9&#160;do<br/>
print_string&#160;(&#34;P&#160;\&#34;x&#34;<br/>
^&#160;string_of_int&#160;x&#160;^&#160;string_of_int&#160;y&#160;^&#160;string_of_int&#160;z&#160;^&#160;(if&#160;z&lt;&gt;9&#160;then&#160;&#34;\&#34;;&#160;&#34;&#160;else&#160;&#34;\&#34;&#34;)<br/>
)<br/>
done&#160;;<br/>print_string&#160;(&#34;]&#34;&#160;^&#160;(if&#160;(x=9&#160;&amp;&amp;&#160;y=9)<br/>
then&#160;&#34;&#34;&#160;else&#160;&#34;;&#34;)&#160;^&#160;&#34;\n&#34;)<br/>
;<br/>
done<br/>
done&#160;;<br/>print_string&#160;&#34;]\n&#34;;<br/>
;;<br/>
(*&#160;C2&#160;Each&#160;number&#160;appears&#160;at&#160;most&#160;once&#160;in&#160;each&#160;column&#160;*)<br/>let&#160;produce_C2&#160;=<br/>
print_string&#160;&#34;let&#160;c2&#160;=&#160;[&#34;;<br/>for&#160;y=1&#160;to&#160;9&#160;do<br/>
for&#160;z=1&#160;to&#160;9&#160;do<br/>
for&#160;x=1&#160;to&#160;8&#160;do<br/>
for&#160;i=(x+1)&#160;to&#160;9&#160;do<br/>
print_string&#160;(&#34;[&#160;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;x&#160;^&#160;string_of_int&#160;y&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;;&#160;&#34;&#160;^<br/>
&#34;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;i&#160;^&#160;string_of_int&#160;y&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;];\n&#160;&#34;)<br/>
done<br/>
done<br/>
done<br/>
done&#160;;<br/>print_string&#160;&#34;]\n&#34;<br/>
;;<br/>
(*&#160;C3&#160;Each&#160;number&#160;appears&#160;at&#160;most&#160;once&#160;in&#160;each&#160;column&#160;*)<br/>let&#160;produce_C3&#160;=<br/>
print_string&#160;&#34;let&#160;c3&#160;=&#160;[&#34;;<br/>for&#160;x=1&#160;to&#160;9&#160;do<br/>
for&#160;z=1&#160;to&#160;9&#160;do<br/>
for&#160;y=1&#160;to&#160;8&#160;do<br/>
for&#160;i=(y+1)&#160;to&#160;9&#160;do<br/>
print_string&#160;(&#34;[&#160;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;x&#160;^&#160;string_of_int&#160;y&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;;&#160;&#34;&#160;^<br/>
&#34;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;x&#160;^&#160;string_of_int&#160;i&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;];\n&#160;&#34;)<br/>
done<br/>
done<br/>
done<br/>
done&#160;;<br/>print_string&#160;&#34;]\n&#34;<br/>
;;<br/>
(*&#160;C4&#160;Each&#160;number&#160;appears&#160;at&#160;most&#160;once&#160;in&#160;each&#160;3x3&#160;sub-grid&#160;*)<br/>let&#160;produce_C4&#160;=<br/>
print_string&#160;&#34;let&#160;c4&#160;=&#160;[&#34;;<br/>for&#160;z=1&#160;to&#160;9&#160;do<br/>
for&#160;i=0&#160;to&#160;2&#160;do<br/>
for&#160;j=0&#160;to&#160;2&#160;do<br/>
for&#160;x=1&#160;to&#160;3&#160;do<br/>
for&#160;y=1&#160;to&#160;3&#160;do<br/>
for&#160;k=(y+1)&#160;to&#160;3&#160;do<br/>
print_string&#160;(&#34;[&#160;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;(3*i+x)&#160;^&#160;string_of_int&#160;(3*j+y)&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;;&#160;&#34;&#160;^<br/>
&#34;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;(3*i+x)&#160;^&#160;string_of_int&#160;(3*j+k)&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;];\n&#160;&#34;)<br/>
done<br/>
done<br/>
done<br/>
done<br/>
done<br/>
done;<br/>
print_string&#160;&#34;]\n&#34;<br/>
;;<br/>let&#160;produce_C5&#160;=<br/>
print_string&#160;&#34;let&#160;c5&#160;=&#160;[&#34;;<br/>for&#160;z=1&#160;to&#160;9&#160;do<br/>
for&#160;i=0&#160;to&#160;2&#160;do<br/>
for&#160;j=0&#160;to&#160;2&#160;do<br/>
for&#160;x=1&#160;to&#160;3&#160;do<br/>
for&#160;y=1&#160;to&#160;3&#160;do<br/>
for&#160;k=(x+1)&#160;to&#160;3&#160;do<br/>
for&#160;l=1&#160;to&#160;3&#160;do<br/>
print_string&#160;(&#34;[&#160;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;(3*i+x)&#160;^&#160;string_of_int&#160;(3*j+y)&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;;&#160;&#34;&#160;^<br/>
&#34;N&#160;\&#34;x&#34;&#160;^&#160;string_of_int&#160;(3*i+k)&#160;^&#160;string_of_int&#160;(3*j+l)&#160;^&#160;string_of_int&#160;z<br/>
^&#160;&#34;\&#34;];\n&#160;&#34;)<br/>
done<br/>
done<br/>
done<br/>
done<br/>
done<br/>
done<br/>done;&#160;print_string&#160;&#34;]\n&#34;<br/>;;<br/>
98<br/>
<hr/>
<a name=99></a><b>Chapitre&#160;7</b><br/>
<b>Annexes&#160;/&#160;Divers</b><br/>
<b>7.1</b><br/>
<b>Quelques&#160;fonctions&#160;sur&#160;les&#160;listes</b><br/>
SCHEME<br/>
OCAML<br/>
(define&#160;(somme&#160;l)<br/>
let&#160;rec&#160;somme&#160;l&#160;=<br/>
(if&#160;(null?&#160;l)<br/>
match&#160;l&#160;with<br/>
0<br/>
|&#160;[]&#160;-&gt;&#160;0<br/>
(+&#160;(car&#160;l)&#160;(somme&#160;(cdr&#160;l)))))<br/>
|&#160;hd::tl&#160;-&gt;&#160;hd&#160;+&#160;somme(tl)<br/>
f&#160;hd&#160;(f&#160;hd&#160;(...&#160;(f&#160;hd&#160;acc)...))<br/>
f&#160;car&#160;(f&#160;car&#160;(...&#160;(f&#160;car&#160;acc)...))<br/>
let&#160;rec&#160;foldright&#160;f&#160;acc&#160;l&#160;=<br/>
(define&#160;(foldright&#160;f&#160;acc&#160;l)<br/>
match&#160;l&#160;with<br/>
(if&#160;(null?&#160;l)<br/>
|&#160;[]&#160;-&gt;&#160;acc<br/>
acc<br/>
|&#160;hd::tl&#160;-&gt;&#160;f&#160;hd&#160;(foldright&#160;f&#160;acc&#160;tl)<br/>
(f&#160;(car&#160;l)&#160;(foldright&#160;f&#160;acc&#160;(cdr&#160;l)))))<br/>
f&#160;(...&#160;(f&#160;(f&#160;acc&#160;car)&#160;car)...)&#160;car)<br/>
f&#160;(...&#160;(f&#160;(f&#160;acc&#160;hd)&#160;hd)...)&#160;hd)<br/>
(define&#160;(foldleft&#160;f&#160;acc&#160;l)<br/>
let&#160;rec&#160;foldleft&#160;f&#160;acc&#160;l&#160;=<br/>
(if&#160;(null?&#160;l)<br/>
match&#160;l&#160;with<br/>
acc<br/>
|&#160;[]&#160;-&gt;&#160;acc<br/>
(foldleft&#160;f&#160;(f&#160;(car&#160;l)&#160;acc)&#160;(cdr&#160;l))))<br/>
|&#160;hd::tl&#160;-&gt;&#160;foldleft&#160;f&#160;(f&#160;acc&#160;hd)&#160;tl<br/>
(foldleft&#160;*&#160;1&#160;’(1&#160;2&#160;3&#160;4))<br/>
#&#160;foldleft&#160;(&#160;*&#160;)&#160;1&#160;[1;2;3;4]&#160;;;<br/>
-&gt;&#160;24<br/>
-&#160;:&#160;int&#160;=&#160;24<br/>
<b>7.2</b><br/>
<b>Les&#160;listes&#160;mutables</b><br/>
En&#160;SCHEME,&#160;nous&#160;avons&#160;les&#160;fonctions&#160;set-car!&#160;et&#160;set-cdr!&#160;qui&#160;nous&#160;permettent&#160;de&#160;modifier<br/>
physiquement&#160;le&#160;car&#160;et&#160;le&#160;cdr&#160;d’un&#160;doublet.&#160;Nous&#160;pouvons&#160;par&#160;exemple&#160;définir&#160;la&#160;liste&#160;circulaire<br/>
(a&#160;b&#160;c&#160;a&#160;b&#160;c&#160;...)<br/>
(define&#160;maliste&#160;(list&#160;’a&#160;’b&#160;’c))<br/>
(set-cdr!&#160;(cddr&#160;maliste)&#160;maliste)<br/>
maliste<br/>
-&gt;&#160;#0=&#160;(a&#160;b&#160;c&#160;.&#160;#0#)<br/>
L’affichage&#160;de&#160;la&#160;liste&#160;infine&#160;provient&#160;de&#160;l’interprète&#160;DrRacket.<br/>
99<br/>
<hr/>
<a name=100></a>Essayons&#160;de&#160;reproduire&#160;cela&#160;en&#160;OCAML&#160;(de&#160;manière&#160;intuitive&#160;et&#160;sûrement&#160;très&#160;maladroite.&#160;.&#160;.&#160;)<br/>
exception&#160;Listenulle<br/>
type&#160;liste&#160;=&#160;Nil&#160;|&#160;Cons&#160;of&#160;int&#160;ref&#160;*&#160;liste&#160;ref&#160;;;<br/>
let&#160;set_car&#160;d&#160;v&#160;=<br/>
match&#160;d&#160;with<br/>
|&#160;Nil&#160;-&gt;&#160;raise&#160;Listenulle<br/>
|&#160;Cons(car,cdr)&#160;-&gt;&#160;car:=v<br/>
;;<br/>
let&#160;set_cdr&#160;d&#160;v&#160;=<br/>
match&#160;d&#160;with<br/>
|&#160;Nil&#160;-&gt;&#160;raise&#160;Listenulle<br/>
|&#160;Cons(car,cdr)&#160;-&gt;&#160;cdr:=v&#160;;;<br/>
let<br/>
cdr&#160;l&#160;=<br/>
match&#160;l&#160;with<br/>
|&#160;Nil&#160;-&gt;&#160;raise&#160;Listenulle<br/>
|&#160;Cons(tete,&#160;reste)&#160;when&#160;!reste&#160;&lt;&gt;&#160;Nil&#160;-&gt;&#160;reste<br/>
let&#160;maliste&#160;=&#160;Cons(ref&#160;1&#160;,&#160;ref&#160;(&#160;Cons&#160;(ref&#160;2,&#160;ref&#160;(&#160;Cons&#160;(ref&#160;3,&#160;ref&#160;Nil)))&#160;))<br/>
set_cdr&#160;(!cdr&#160;!(cdr&#160;maliste))&#160;maliste&#160;;;<br/>
#&#160;maliste;;<br/>
-&#160;:&#160;liste&#160;=<br/>
Cons&#160;({contents&#160;=&#160;1},<br/>
{contents&#160;=<br/>
Cons&#160;({contents&#160;=&#160;2},<br/>
{contents&#160;=<br/>
Cons&#160;({contents&#160;=&#160;3},<br/>
{contents&#160;=<br/>
Cons&#160;({contents&#160;=&#160;1},<br/>
{contents&#160;=<br/>
Cons&#160;({contents&#160;=&#160;2},<br/>
{contents&#160;=<br/>
Cons&#160;({contents&#160;=&#160;3},<br/>
...<br/>
<b>7.3</b><br/>
<b>Les&#160;listes&#160;infinies&#160;ou&#160;<i>streams</i></b><br/>
Les&#160;<i>streams&#160;</i>sont&#160;des&#160;listes&#160;infinies.<br/>
Pour&#160;pouvoir&#160;les&#160;représenter,&#160;nous&#160;utilisons&#160;le&#160;fait&#160;que&#160;le&#160;corps&#160;d’une&#160;lambda&#160;n’est&#160;pas&#160;évalué,<br/>
comme&#160;nous&#160;l’avons&#160;vu&#160;en&#160;<i>λ</i>-calcul&#160;avec&#160;la&#160;stratégie&#160;de&#160;<i>β</i>-réduction&#160;faible.&#160;Une&#160;lambda&#160;fun()-&gt;2*2<br/>
100<br/>
<hr/>
<a name=101></a>D<br/>
D<br/>
-&#160;:&#160;unit&#160;-&gt;&#160;int&#160;=&#160;&lt;fun&gt;&#160;est&#160;en&#160;fait&#160;considérée&#160;comme&#160;une&#160;<i>valeur</i>.&#160;Seul&#160;son&#160;appel&#160;provoquera<br/>
l’évaluation&#160;de&#160;la&#160;lambda&#160;(fun()&#160;-&gt;&#160;2*2)&#160;()<br/>
-&#160;:&#160;int&#160;=&#160;4<br/>
Un&#160;<i>stream&#160;</i>sera&#160;ainsi&#160;représenté&#160;comme&#160;une&#160;liste,&#160;mais&#160;dont&#160;le&#160;cdr&#160;ne&#160;pointera&#160;plus&#160;directement<br/>
sur&#160;une&#160;liste,&#160;mais&#160;sera&#160;une&#160;fonction&#160;dont&#160;le&#160;corps&#160;sera&#160;la&#160;liste.&#160;L’évaluation&#160;du&#160;cdr&#160;est&#160;ainsi&#160;retardé.<br/>
type&#160;’a&#160;stream&#160;=&#160;Cons&#160;of&#160;’a&#160;*&#160;(unit&#160;-&gt;&#160;’a&#160;stream)&#160;;;<br/>
let&#160;hd&#160;(Cons&#160;(h,&#160;_))&#160;=&#160;h&#160;;;<br/>
let&#160;tl&#160;(Cons&#160;(_,&#160;tf))&#160;=&#160;tf&#160;()&#160;;;<br/>
let&#160;rec&#160;from&#160;n&#160;=&#160;Cons&#160;(n,&#160;fun&#160;()&#160;-&gt;&#160;from&#160;(n+1));;<br/>
let&#160;entiers&#160;=&#160;from&#160;0&#160;;;<br/>
let&#160;rec&#160;take&#160;n&#160;s&#160;=<br/>
if&#160;n=0&#160;then&#160;[]<br/>
else&#160;hd&#160;s&#160;::&#160;take&#160;(n-1)&#160;(tl&#160;s)&#160;;;<br/>
#&#160;take&#160;30&#160;entiers<br/>
-&#160;:&#160;int&#160;list&#160;=<br/>
[0;&#160;1;&#160;2;&#160;3;&#160;4;&#160;5;&#160;6;&#160;7;&#160;8;&#160;9;&#160;10;&#160;11;&#160;12;&#160;13;&#160;14;&#160;15;&#160;16;&#160;17;&#160;18;&#160;19;&#160;20;<br/>
21;&#160;22;&#160;23;&#160;24;&#160;25;&#160;26;&#160;27;&#160;28;&#160;29]<br/>
√<br/>
Nous&#160;pouvons&#160;aussi&#160;modéliser&#160;la&#160;fraction&#160;continue&#160;représentant<br/>
2&#160;:<br/>
√<br/>
1<br/>
2&#160;=&#160;1&#160;+<br/>
1<br/>
2&#160;+<br/>
1<br/>
2&#160;+&#160;<i>...</i><br/>
Voici&#160;le&#160;code&#160;OCAML.&#160;Je&#160;n’ai&#160;pas&#160;trouvé&#160;manière&#160;plus&#160;élégante&#160;pour&#160;exprimer&#160;le&#160;stream.<br/>
let&#160;rec&#160;square2&#160;iter&#160;=<br/>
if&#160;(iter&#160;=&#160;1)&#160;then&#160;1.<br/>
else<br/>
1.&#160;+.&#160;(&#160;1.&#160;/.&#160;(&#160;1.&#160;+.&#160;square2&#160;(iter&#160;-&#160;1)))<br/>
let&#160;rec&#160;racine2cons&#160;n&#160;=&#160;Cons(square2&#160;n,&#160;fun&#160;()&#160;-&gt;&#160;racine2cons&#160;(n+1))<br/>
let&#160;rec&#160;racine2stream&#160;=&#160;racine2cons&#160;1<br/>
in&#160;take&#160;10&#160;racine2stream&#160;;;<br/>
-&#160;:&#160;float&#160;list&#160;=<br/>
[1.;&#160;1.5;&#160;1.4;&#160;1.41666666666666674;&#160;1.4137931034482758;&#160;1.41428571428571437;<br/>
1.41420118343195256;&#160;1.41421568627450989;&#160;1.41421319796954315;<br/>
1.41421362489486957]<br/>
Nous&#160;voyons&#160;la&#160;convergence&#160;très&#160;rapide&#160;de&#160;la&#160;fraction&#160;continue.<br/>
Cependant,&#160;le&#160;calcul&#160;OCAML&#160;est&#160;très&#160;inefficace,&#160;car&#160;chaque&#160;nouvel&#160;élément&#160;de&#160;la&#160;liste&#160;recalcule<br/>
la&#160;totalité&#160;de&#160;la&#160;fraction&#160;continue&#160;en&#160;passant&#160;par&#160;la&#160;fonction&#160;square2&#160;iter.&#160;Si&#160;nous&#160;essayons&#160;par<br/>
101<br/>
<hr/>
<a name=102></a>exemple&#160;de&#160;calculer&#160;les&#160;10000&#160;premiers&#160;éléments&#160;du&#160;stream,&#160;cela&#160;prend&#160;sur&#160;ma&#160;machine&#160;une&#160;dizaine<br/>de&#160;seconde.<br/>
En&#160;utilisant&#160;le&#160;module&#160;Lazy&#160;d’OCAML,&#160;nous&#160;pouvons&#160;utiliser&#160;le&#160;mécanisme&#160;de&#160;<i>mémoisation</i>.<br/>
Les&#160;valeurs&#160;du&#160;stream&#160;ne&#160;seront&#160;pas&#160;recalculées&#160;au&#160;2ème&#160;appel.<br/>
open&#160;Lazy&#160;;;<br/>
let&#160;racine2_10000&#160;=&#160;take&#160;10000&#160;racine2stream<br/>
(*&#160;environ&#160;10&#160;secondes&#160;à&#160;chaque&#160;appel&#160;*)<br/>
let&#160;racine2_10000_lazy&#160;=&#160;lazy&#160;(take&#160;10000&#160;racine2stream)&#160;;;<br/>
let&#160;racine2_force&#160;=&#160;force&#160;racine2_10000_lazy&#160;;;&#160;(*&#160;uniquement&#160;long&#160;au&#160;1er&#160;appel&#160;*)<br/>
<b>7.4</b><br/>
<b>Le&#160;module&#160;Graphics&#160;d’OCAML,&#160;les&#160;fractales</b><br/>
Nous&#160;allons&#160;ici&#160;présenter&#160;tres&#160;brievement&#160;le&#160;module&#160;Graphics.&#160;Je&#160;reprends&#160;le&#160;code&#160;de&#160;Xavier<br/>
Leroy&#160;tiré&#160;de&#160;son&#160;livre&#160;<i>le&#160;langage&#160;CAML&#160;</i><a href="documents.html#127">[20].</a><br/>
open&#160;Graphics&#160;;;<br/>
Graphics.open_graph&#160;&#34;&#34;;;<br/>
Graphics.set_window_title&#160;&#34;THE&#160;WINDOW&#34;&#160;;;<br/>
type<br/>
etat&#160;=&#160;{&#160;mutable&#160;x&#160;:&#160;float;&#160;mutable&#160;y&#160;:&#160;float;<br/>
mutable&#160;visee&#160;:&#160;float;&#160;mutable&#160;levee&#160;:&#160;bool&#160;};;<br/>
let&#160;crayon&#160;=&#160;{&#160;x&#160;=&#160;0.0;&#160;y&#160;=&#160;0.0;&#160;visee&#160;=&#160;0.0;&#160;levee&#160;=&#160;false&#160;};;<br/>
let&#160;fixe_crayon&#160;b&#160;=&#160;crayon.levee&#160;&lt;-&#160;b;;<br/>
let&#160;pi_sur_180&#160;=let&#160;pi&#160;=&#160;4.0&#160;*.&#160;(atan&#160;1.0)&#160;in&#160;pi&#160;/.&#160;180.0<br/>
let&#160;tourne&#160;angle&#160;=&#160;crayon.visee&#160;&lt;-&#160;(crayon.visee&#160;+.&#160;angle&#160;*.&#160;pi_sur_180)&#160;;;<br/>
let&#160;zero_x&#160;=&#160;float_of_int&#160;((size_x&#160;())&#160;/&#160;2);;<br/>
let&#160;zero_y&#160;=&#160;float_of_int&#160;((size_y&#160;())&#160;/&#160;2);;<br/>
let&#160;vide_ecran&#160;()&#160;=<br/>
set_color&#160;white;<br/>
fill_rect&#160;0&#160;0&#160;(size_x&#160;())&#160;(size_y&#160;());<br/>
set_color&#160;black;<br/>
crayon.x&#160;&lt;-&#160;zero_x;<br/>
crayon.y&#160;&lt;-&#160;zero_y;<br/>
crayon.visee&#160;&lt;-&#160;0.0;<br/>
crayon.levee&#160;&lt;-&#160;false;<br/>
moveto&#160;(round&#160;crayon.x)&#160;(round&#160;crayon.y);;<br/>
let&#160;avance&#160;d&#160;=<br/>
102<br/>
<hr/>
<a name=103></a><img src="document-103_1.png"/><br/>
<img src="document-103_2.png"/><br/>
<img src="document-103_3.png"/><br/>
<img src="document-103_4.png"/><br/>
<img src="document-103_5.jpg"/><br/>
let&#160;dx&#160;=&#160;d&#160;*.&#160;cos&#160;(crayon.visee)<br/>
and&#160;dy&#160;=&#160;d&#160;*.&#160;sin&#160;(crayon.visee)&#160;in<br/>
crayon.x&#160;&lt;-&#160;crayon.x&#160;+.&#160;dx;<br/>
crayon.y&#160;&lt;-&#160;crayon.y&#160;+.&#160;dy;<br/>
if&#160;crayon.levee&#160;then&#160;moveto&#160;(round&#160;crayon.x)&#160;(round&#160;crayon.y)<br/>
else&#160;lineto&#160;(round&#160;crayon.x)&#160;(round&#160;crayon.y);;<br/>
let&#160;rec&#160;motif&#160;n&#160;c&#160;=<br/>
if&#160;n&#160;=&#160;0&#160;then&#160;avance&#160;c<br/>
else<br/>
begin<br/>
motif&#160;(n&#160;-1)&#160;(c&#160;/.&#160;3.0);<br/>
tourne&#160;60.0;<br/>
motif&#160;(n&#160;-1)&#160;(c&#160;/.&#160;3.0);<br/>
tourne&#160;(-120.0);<br/>
motif&#160;(n&#160;-1)&#160;(c&#160;/.&#160;3.0);<br/>
tourne&#160;60.0;<br/>
motif&#160;(n&#160;-1)&#160;(c&#160;/.&#160;3.0)<br/>
end;;<br/>
let&#160;flocon&#160;n&#160;c&#160;=<br/>
for&#160;i&#160;=&#160;1&#160;to&#160;3<br/>
do<br/>
motif&#160;n&#160;c;&#160;tourne&#160;(-120.0)<br/>
done;;<br/>
flocon&#160;1&#160;100.0;<br/>
flocon&#160;2&#160;100.0;<br/>
flocon&#160;3&#160;100.0;<br/>
flocon&#160;4&#160;100.0;<br/>
Figure&#160;7.1&#160;–&#160;Les&#160;côtes&#160;de&#160;la&#160;Bretagne<br/>
Les&#160;objets&#160;fractales&#160;ont&#160;une&#160;propriété&#160;surprenante&#160;:&#160;ils&#160;ont&#160;une&#160;aire&#160;finie,&#160;mais&#160;un&#160;périmètre<br/>
infini.&#160;A&#160;l’itération&#160;<i>n</i>,&#160;le&#160;périmètre&#160;de&#160;notre&#160;flocon&#160;est&#160;de&#160;3<i>.</i>(&#160;4&#160;)<i>n</i>.&#160;Et&#160;nous&#160;avons&#160;bien&#160;entendu<br/>
3<br/>
lim<i>n</i>→∞&#160;3<i>.</i>(&#160;4&#160;)<i>n&#160;</i>=&#160;∞<br/>
3<br/>
103<br/>
<hr/>
<a name=104></a>La&#160;longueur&#160;des&#160;côtes&#160;de&#160;la&#160;Bretagne&#160;est-elle&#160;aussi&#160;infinie&#160;?&#160;<i>L’Atlantique&#160;ronge&#160;nos&#160;côtes.&#160;</i><a href="documents.html#127">[10]</a><br/>
<b>L’ensemble&#160;de&#160;Mandelbrot</b><br/>
l’ensemble&#160;de&#160;Mandelbrot&#160;est&#160;une&#160;fractale&#160;définie&#160;comme&#160;l’ensemble&#160;des&#160;points&#160;<i>c&#160;</i>du&#160;plan&#160;com-<br/>
plexe&#160;pour&#160;lesquels&#160;la&#160;suite&#160;des&#160;nombres&#160;complexes&#160;définie&#160;comme&#160;ci-dessous&#160;est&#160;<b>bornée</b>.<br/>
(<i>z</i>0&#160;=&#160;0<br/>
<i>zn</i>+1&#160;=&#160;<i>z</i>2<i>n&#160;</i>+&#160;<i>c</i><br/>
Voir&#160;le&#160;bon&#160;article&#160;<a href="https://fr.wikipedia.org/wiki/Ensemble_de_Mandelbrot">https://fr.wikipedia.org/wiki/Ensemble_de_Mandelbrot</a><br/>
On&#160;montre&#160;que&#160;si&#160;la&#160;suite&#160;des&#160;modules&#160;des&#160;<i>zn&#160;</i>est&#160;strictement&#160;supérieure&#160;à&#160;2&#160;pour&#160;un&#160;certain<br/>
indice&#160;alors,&#160;cette&#160;suite&#160;est&#160;croissante&#160;à&#160;partir&#160;de&#160;cet&#160;indice,&#160;et&#160;elle&#160;tend&#160;vers&#160;l’infini.&#160;Donc&#160;notre<br/>test&#160;d’appartenance&#160;à&#160;l’ensemble&#160;s’arrêtera&#160;au-delà&#160;de&#160;la&#160;valeur&#160;2.<br/>
Pour&#160;estimer&#160;la&#160;convergence,&#160;nous&#160;nous&#160;arrêterons&#160;à&#160;la&#160;valeur&#160;<i>z</i>300.&#160;Nous&#160;utilisons&#160;également<br/>
l’hypothèse&#160;que&#160;l’ensemble&#160;de&#160;Mandelbrot&#160;se&#160;situe&#160;dans&#160;le&#160;plan&#160;complexe&#160;(−2<i>.</i>00&#160;:&#160;0<i>.</i>50)<i>,&#160;</i>(−1<i>.</i>25&#160;:<br/>1<i>.</i>25)<br/>
open&#160;Complex&#160;;;<br/>
(*&#160;{re=2.;&#160;im=4.}&#160;*)<br/>
let&#160;appartient&#160;c&#160;=<br/>
let&#160;rec&#160;loop&#160;n&#160;z&#160;=<br/>
if&#160;(n&#160;&gt;&#160;300)&#160;then&#160;true<br/>
else&#160;if&#160;((norm2&#160;z)&#160;&gt;&#160;4.)&#160;then&#160;false<br/>
else&#160;loop&#160;(n+1)&#160;(add&#160;c&#160;(mul&#160;z&#160;z))<br/>
in&#160;loop&#160;0&#160;c<br/>
#load&#160;&#34;/home/vincent/.opam/ocaml-base-compiler/lib/graphics/graphics.cma&#34;&#160;;;<br/>
#require&#160;&#34;graphics&#34;&#160;;;<br/>
open&#160;Graphics&#160;;;<br/>
Graphics.open_graph&#160;&#34;&#160;500x200+0-0&#34;&#160;;;<br/>
Graphics.set_window_title&#160;&#34;Mandelbrot&#34;&#160;;;<br/>
Graphics.set_color&#160;Graphics.blue;;<br/>
let&#160;mandelbrot&#160;()&#160;=<br/>
for&#160;i&#160;=&#160;(-200)&#160;to&#160;50<br/>
do<br/>
for&#160;j=(-125)&#160;to&#160;125<br/>
do<br/>
if&#160;(appartient&#160;{re=((float_of_int&#160;i)/.100.);&#160;im=((float_of_int&#160;j)/.100.)})<br/>
then&#160;plot&#160;(200+i)&#160;(200+j)<br/>
done<br/>
done<br/>
104<br/>
<hr/>
<a name=105></a><img src="document-105_1.png"/><br/>
<img src="document-105_2.png"/><br/>
Figure&#160;7.2&#160;–&#160;L’ensemble&#160;de&#160;Mandelbrot<br/>
<b>7.5</b><br/>
<b>Utilisation&#160;de&#160;</b>METAFONT<br/>
METAFONT&#160;est&#160;un&#160;langage&#160;créé&#160;par&#160;D.&#160;Knuth&#160;<a href="documents.html#127">[11].&#160;</a>Il&#160;permet&#160;le&#160;design&#160;de&#160;nouvelles&#160;fontes&#160;de<br/>
D<br/>
manière&#160;très&#160;élégante&#160;sous&#160;forme&#160;d’équations.&#160;La&#160;programmation&#160;se&#160;fait&#160;principalement&#160;de&#160;manière<br/>déclarative.<br/>
Je&#160;me&#160;suis&#160;amusé&#160;ici&#160;à&#160;créer&#160;le&#160;symbole<br/>
que&#160;j’ai&#160;souvent&#160;utilisé&#160;dans&#160;cet&#160;article,&#160;principalement<br/>
dans&#160;la&#160;section&#160;sur&#160;le&#160;<i>λ</i>-calcul.<br/>
DFigure7.3–<br/>
Voici&#160;le&#160;bout&#160;de&#160;code&#160;qui&#160;a&#160;permis&#160;de&#160;définir&#160;ce&#160;symbole&#160;:<br/>
%file&#160;name:&#160;beta.mf<br/>
beginchar(&#34;D&#34;,15pt#,10pt#,3pt#);<br/>
%&#160;proportion&#160;ligne&#160;vs&#160;triangle&#160;3/4&#160;1/4<br/>
prop:=3/4;<br/>
y1=h-d;&#160;y2=1/5h-d;&#160;y3=4/5h-d;<br/>
y4=2/5h-d;&#160;y5=3/5h-d;&#160;y6=1/2h-d;<br/>
y7=3/4h-d;&#160;y8=1/4h-d;&#160;y9=h/2-d;<br/>
x1=0;&#160;x2=1/5*prop*w;&#160;x3=2/5*prop*w;<br/>
x4=3/5*prop*w;&#160;x5=4/5*prop*w;&#160;x6=prop*w;<br/>
x7=x8=x6;&#160;x9=w;<br/>
pickup&#160;pencircle&#160;scaled&#160;0.3pt;<br/>
draw&#160;z1{right}..tension&#160;6..z2{right}..tension&#160;5..z3{right}<br/>
105<br/>
<hr/>
<a name=106></a>..tension&#160;4..z4{right}..tension&#160;4..z5{right}..tension&#160;3..z6;<br/>
draw&#160;z7--z8--z9--cycle;<br/>
labels(range&#160;1&#160;thru&#160;9);<br/>
endchar;<br/>
S<br/>
end<br/>
Nous&#160;avons&#160;également&#160;représenté&#160;notre&#160;fractale<br/>
avec&#160;le&#160;langage&#160;METAFONT.&#160;Cela&#160;s’écrit<br/>
très&#160;facilement,&#160;car&#160;le&#160;langage&#160;de&#160;Knuth&#160;permet&#160;l’utilisation&#160;de&#160;macros&#160;récursives.<br/>
%file&#160;name:&#160;snow.mf<br/>
%mode_setup;<br/>
%shape&#160;for&#160;the&#160;character&#160;S<br/>
i:=1;<br/>
def&#160;dessine(expr&#160;debut,&#160;fin)&#160;=<br/>
z[i]=debut;<br/>
z[i+1]=1/3[debut,&#160;fin];<br/>
z[i+2]=&#160;(z[i+1]-z[i])&#160;rotated&#160;60&#160;shifted&#160;z[i+1];<br/>
z[i+3]&#160;=&#160;2/3[debut,&#160;fin]&#160;;<br/>
z[i+4]&#160;=&#160;fin&#160;;<br/>
pickup&#160;pencircle&#160;scaled&#160;0.1pt;<br/>
draw&#160;z[i]--z[i+1]--z[i+2]--z[i+3]--z[i+4];<br/>
i:=i+5;<br/>
enddef;<br/>
def&#160;motif&#160;(expr&#160;debut,&#160;fin,&#160;n)&#160;=<br/>
if&#160;(n=1):dessine(debut,fin)&#160;else:<br/>
motif(debut,&#160;1/3[debut,fin],&#160;n-1)&#160;;<br/>
motif(1/3[debut,fin],<br/>
(1/3[debut,fin]&#160;-&#160;debut)&#160;rotated&#160;60&#160;shifted&#160;(1/3[debut,fin]),&#160;n-1)&#160;;<br/>
motif((1/3[debut,fin]&#160;-&#160;debut)&#160;rotated&#160;60&#160;shifted&#160;(1/3[debut,fin]),<br/>
(1/3[debut,fin]&#160;-debut)&#160;shifted&#160;(1/3[debut,fin]),&#160;n-1)&#160;;<br/>
motif((1/3[debut,fin]&#160;-&#160;debut)&#160;shifted&#160;(1/3[debut,fin]),&#160;fin,&#160;n-1)&#160;;<br/>
fi;<br/>
enddef;<br/>
beginchar(&#34;S&#34;,15pt#,15pt#,5pt#);&#160;&#34;The&#160;snowflake&#34;&#160;;<br/>
motif((0,0),&#160;(w/2,h),4);<br/>
motif((w/2,h),&#160;(w,0),4);<br/>
motif((w,0),&#160;(0,0),4);<br/>
endchar;<br/>
end<br/>
Voici&#160;le&#160;résultat&#160;:<br/>
106<br/>
<hr/>
<a name=107></a><img src="document-107_1.png"/><br/>
SFigure7.4–<br/>
<b>7.6</b><br/>
<b>The&#160;boxes</b><br/>
Nous&#160;avons&#160;vu&#160;comment&#160;représenter&#160;un&#160;environnement&#160;comme&#160;une&#160;liste&#160;d’associations&#160;avec<br/>
des&#160;paires&#160;variable.valeur.&#160;Une&#160;autre&#160;méthode&#160;est&#160;d’utiliser&#160;le&#160;principe&#160;de&#160;<i>box&#160;</i>qui&#160;encapsule&#160;la<br/>valeur&#160;dans&#160;une&#160;lambda.&#160;La&#160;<i>box&#160;</i>est&#160;une&#160;lambda&#160;qui&#160;prend&#160;une&#160;valeur&#160;à&#160;sa&#160;création.&#160;Puis&#160;elle&#160;réagit<br/>à&#160;deux&#160;messages&#160;qui&#160;permettent&#160;respectivement&#160;d’afficher&#160;la&#160;valeur&#160;capturée&#160;ou&#160;de&#160;la&#160;modifier&#160;avec<br/>la&#160;procédure&#160;set!<br/>
Voici&#160;l’implémentation&#160;en&#160;Scheme&#160;:<br/>
(define&#160;(box&#160;value)<br/>
(lambda&#160;(msg)<br/>
(case&#160;msg<br/>
(&#34;get&#34;&#160;value)<br/>
(&#34;set&#34;&#160;(lambda&#160;(new-value)&#160;(set!&#160;value&#160;new-value))))))<br/>
(define&#160;(make-box&#160;value)<br/>
(box&#160;value))<br/>
(define&#160;maboite&#160;(make-box&#160;4))<br/>
(maboite&#160;&#34;get&#34;)<br/>
((maboite&#160;&#34;set&#34;)&#160;5)<br/>
En&#160;CAML,&#160;nous&#160;pouvons&#160;rédiger&#160;le&#160;code&#160;ci-dessous&#160;:<br/>
exception&#160;Erreur<br/>
let&#160;box&#160;value0&#160;=<br/>
let&#160;value&#160;=&#160;ref&#160;value0&#160;in<br/>
fun&#160;message&#160;-&gt;<br/>
match&#160;message&#160;with<br/>
|&#160;&#34;get&#34;&#160;-&gt;&#160;(fun&#160;any&#160;-&gt;&#160;print_int&#160;!value)<br/>
|&#160;&#34;set&#34;&#160;-&gt;&#160;(fun&#160;newvalue&#160;-&gt;&#160;(value&#160;:=&#160;newvalue&#160;;&#160;print_int&#160;!value&#160;))<br/>
|&#160;&#34;reset&#34;-&gt;&#160;(fun&#160;any&#160;-&gt;&#160;(value&#160;:=&#160;value0&#160;;&#160;print_int&#160;!value))<br/>
107<br/>
<hr/>
<a name=108></a>|&#160;_&#160;-&gt;&#160;raise&#160;Erreur<br/>
let&#160;maboite&#160;=&#160;box&#160;5&#160;;;<br/>
(maboite&#160;&#34;get&#34;)&#160;0&#160;;;<br/>
(maboite&#160;&#34;set&#34;)&#160;1976&#160;;;<br/>
(maboite&#160;&#34;get&#34;)&#160;0&#160;;;<br/>
(maboite&#160;&#34;reset&#34;)&#160;0&#160;;;<br/>
<b>7.7</b><br/>
<b>Les&#160;modules&#160;OCAML.&#160;Modélisation&#160;d’un&#160;monoïde</b><br/>
Un&#160;monoïde&#160;est&#160;une&#160;structure&#160;algébrique&#160;qui&#160;possède&#160;une&#160;loi&#160;de&#160;composition&#160;interne&#160;associa-<br/>
tive&#160;et&#160;un&#160;élément&#160;neutre.&#160;Représentons&#160;cette&#160;structure&#160;en&#160;OCAML,&#160;en&#160;définissant&#160;un&#160;module.<br/>Nous&#160;reprenons&#160;ici&#160;l’excellent&#160;article&#160;https&#160;://blog.derniercri.io/observons-une-premiere-structure-<br/>algebrique-appliquee-a-linformatique-le-monoide/<br/>
module&#160;type&#160;MONOID&#160;=<br/>
sig<br/>
type&#160;t<br/>
val&#160;(&#160;&lt;+&gt;&#160;)&#160;:&#160;t&#160;-&gt;&#160;t&#160;-&gt;&#160;t<br/>
val&#160;neutral&#160;:&#160;t<br/>
end<br/>
module&#160;String_monoid&#160;:&#160;MONOID&#160;with&#160;type&#160;t&#160;=&#160;string<br/>
=<br/>
struct<br/>
type&#160;t&#160;=&#160;string<br/>
let&#160;(&#160;&lt;+&gt;&#160;)&#160;=&#160;(^)<br/>
let&#160;neutral&#160;=&#160;&#34;&#34;<br/>
end<br/>
String_monoid.(&#34;abc&#34;&#160;&lt;+&gt;&#160;&#34;def&#34;&#160;&lt;+&gt;&#160;neutral)<br/>
-&gt;&#160;String_monoid.t&#160;=&#160;&#34;abcdef&#34;<br/>
En&#160;algèbre,&#160;un&#160;morphisme&#160;(ou&#160;homomorphisme)&#160;est&#160;une&#160;application&#160;entre&#160;deux&#160;structures&#160;al-<br/>
gébriques&#160;de&#160;même&#160;espèce.<br/>
Pour&#160;les&#160;monoïdes,&#160;un&#160;morphisme&#160;est&#160;une&#160;application&#160;<i>f&#160;</i>:&#160;(<i>M,&#160;</i>∗<i>,&#160;e</i>)&#160;−→&#160;(<i>M&#160;</i>0<i>,&#160;?,&#160;e</i>0)&#160;,&#160;entre&#160;deux<br/>
monoïdes&#160;(<i>M,&#160;</i>∗<i>,&#160;e</i>)&#160;et&#160;(<i>M&#160;</i>0<i>,&#160;?,&#160;e</i>0)&#160;qui&#160;vérifie&#160;:<br/>
—&#160;∀(<i>g,&#160;h</i>)&#160;∈&#160;<i>M&#160;</i>2<i>,&#160;f&#160;</i>(<i>g&#160;</i>∗&#160;<i>h</i>)&#160;=&#160;<i>f&#160;</i>(<i>g</i>)&#160;<i>?&#160;f&#160;</i>(<i>h</i>)<br/>—&#160;<i>f&#160;</i>(<i>e</i>)&#160;=&#160;<i>e</i>0<br/>
#load&#160;&#34;Str.cma&#34;<br/>
let&#160;count<br/>
t&#160;=<br/>
split&#160;(regexp&#160;&#34;&#160;&#34;)&#160;t<br/>
|&gt;&#160;List.length&#160;;;<br/>
let&#160;pageA&#160;=&#160;&#34;Hello&#160;World&#160;&#34;<br/>
let&#160;pageB&#160;=&#160;&#34;Foo&#160;bar&#160;&#34;<br/>
108<br/>
<hr/>
<a name=109></a>let&#160;pageC&#160;=&#160;&#34;O&#160;Caml&#160;&#34;&#160;;;<br/>
count&#160;String_monoid.(pageA&#160;&lt;+&gt;&#160;pageB&#160;&lt;+&gt;<br/>
pageC)&#160;;;<br/>
count(String_monoid.(pageA))&#160;+&#160;count(String_monoid.(pageB))&#160;+&#160;count(String_monoid.(pageC));;<br/>
Nous&#160;avons&#160;ici&#160;utilisé&#160;l’opérateur&#160;|&gt;&#160;défini&#160;comme&#160;suit&#160;let&#160;(&#160;|&gt;&#160;)&#160;x&#160;f&#160;=&#160;f&#160;x<br/>
Cette&#160;fonction&#160;count&#160;est&#160;ainsi&#160;un&#160;morphisme&#160;entre&#160;le&#160;monoïde&#160;String_monoid&#160;et&#160;le&#160;monoïde<br/>
des&#160;entiers&#160;(avec&#160;+&#160;comme&#160;fonction&#160;de&#160;composition&#160;interne&#160;et&#160;0&#160;comme&#160;élément&#160;neutre)<br/>
<b>7.8</b><br/>
<b>Machine&#160;Learning&#160;and&#160;Neural&#160;Networks</b><br/>
<b>7.8.1</b><br/>
<b>Introduction</b><br/>
Nous&#160;implémentons&#160;en&#160;R&#160;un&#160;réseau&#160;de&#160;neurones&#160;réduit&#160;à&#160;sa&#160;plus&#160;simple&#160;expression.&#160;Il&#160;n’aura<br/>
que&#160;deux&#160;couches&#160;de&#160;neurones.&#160;Le&#160;langage&#160;R&#160;est&#160;ici&#160;commode&#160;pour&#160;ses&#160;opérations&#160;natives&#160;sur&#160;les<br/>matrices.&#160;Nous&#160;pourrons&#160;voir&#160;ensuite&#160;comme&#160;transposer&#160;ce&#160;code&#160;en&#160;OCAML.<br/>
Nous&#160;entraînerons&#160;notre&#160;NN&#160;sur&#160;la&#160;base&#160;du&#160;jeu&#160;de&#160;test&#160;MNIST.&#160;Le&#160;&#34;training&#160;set&#34;&#160;contient&#160;60000<br/>
exemples,&#160;et&#160;le&#160;&#34;test&#160;set&#34;&#160;10000&#160;exemples.&#160;Nous&#160;pourrons&#160;nous&#160;documenter&#160;plus&#160;précisément&#160;avec<br/>l’excellent&#160;ouvrage&#160;de&#160;François&#160;Chollet&#160;<a href="documents.html#127">[5].</a><br/>
<b>7.8.2</b><br/>
<b>Un&#160;peu&#160;de&#160;théorie</b><br/>
Soit&#160;les&#160;150&#160;observations&#160;suivantes&#160;représentées&#160;par&#160;la&#160;matrice&#160;<i>X</i>150<i>,</i>784&#160;(ou&#160;tensor&#160;2&#160;dimen-<br/>
sions)&#160;comprenant&#160;150&#160;lignes&#160;pour&#160;les&#160;150&#160;observations&#160;et&#160;784&#160;colonnes&#160;pour&#160;les&#160;784&#160;features&#160;des<br/>observations.<br/>
2&#160;matrices&#160;de&#160;poids&#160;<i>W&#160;</i>1<br/>
32<i>,</i>150&#160;et&#160;<i>W&#160;</i>2<br/>
10<i>,</i>150&#160;sont&#160;utilisées.<br/>
—&#160;1er&#160;layer&#160;de&#160;32&#160;neurones<br/>—&#160;2nd&#160;layer&#160;de&#160;10&#160;neurones<br/>
La&#160;sortie&#160;<i>OU&#160;T&#160;P&#160;U&#160;T</i>150<i>,</i>10&#160;est&#160;une&#160;matrice&#160;de&#160;150&#160;lignes&#160;avec&#160;les&#160;10&#160;colonnes&#160;représentant&#160;les&#160;10<br/>
features&#160;que&#160;l’on&#160;cherche&#160;à&#160;reconnaître.<br/>
Voici&#160;le&#160;schéma&#160;simplifié&#160;du&#160;NN&#160;à&#160;2&#160;couches&#160;:<br/>
<i>X&#160;</i>−→&#160;⊗<i>W&#160;</i>1&#160;→&#160;<i>Z</i>1&#160;→&#160;<i>σ&#160;</i>→&#160;<i>LAY&#160;ER</i>1&#160;−→&#160;⊗<i>W&#160;</i>2&#160;→&#160;<i>Z</i>2&#160;→&#160;<i>σ&#160;</i>→&#160;ˆ<br/>
<i>Y&#160;&gt;&gt;&#160;LOSS</i>(&#160;ˆ<br/>
<i>Y&#160;,&#160;Y&#160;</i>)<br/>
109<br/>
<hr/>
<a name=110></a><b>7.8.3</b><br/>
<b>Calcul&#160;matriciel</b><br/>
Cela&#160;donne&#160;le&#160;calcul&#160;matriciel&#160;ci-dessous&#160;:<br/>
&#160;<i>x</i><br/>
<br/>
<br/>
<br/>
<br/>
<br/>
1<i>,</i>1<br/>
<i>x</i>1<i>,</i>2<br/>
·&#160;·&#160;·<br/>
<i>x</i>1<i>,</i>784<br/>
<i>camlw</i>1<br/>
·&#160;·&#160;·<br/>
·&#160;·&#160;·<br/>
1<i>,</i>1<br/>
<i>w</i>11<i>,</i>2<br/>
<i>w</i>11<i>,</i>32<br/>
<i>z</i>1<br/>
1<i>,</i>1<br/>
<i>z</i>1<br/>
1<i>,</i>2<br/>
<i>z</i>1<br/>
1<i>,</i>32<br/>
<i>x</i>2<i>,</i>1<br/>
<i>x</i>2<i>,</i>2<br/>
·&#160;·&#160;·<br/>
<i>x</i>2<i>,</i>784<br/>
<i>w</i>1<br/>
·&#160;·&#160;·<br/>
·&#160;·&#160;·<br/>
2<i>,</i>1<br/>
<i>w</i>12<i>,</i>2<br/>
<i>w</i>12<i>,</i>32<br/>
<i>z</i>1<br/>
2<i>,</i>1<br/>
<i>z</i>1<br/>
2<i>,</i>2<br/>
<i>z</i>1<br/>
2<i>,</i>32<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
×<br/>
.<br/>
.<br/>
.<br/>
=<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<i>x</i>150<i>,</i>1<br/>
<i>x</i>150<i>,</i>2<br/>
·&#160;·&#160;·<br/>
<i>x</i>150<i>,</i>784<br/>
<i>w</i>1<br/>
·&#160;·&#160;·<br/>
·&#160;·&#160;·<br/>
784<i>,</i>1<br/>
<i>w</i>1784<i>,</i>2<br/>
<i>w</i>1784<i>,</i>32<br/>
<i>z</i>1<br/>
150<i>,</i>1<br/>
<i>z</i>1<br/>
150<i>,</i>2<br/>
<i>z</i>1<br/>
150<i>,</i>32<br/>
&#160;<i>z</i>1<br/>
·&#160;·&#160;·<br/>
<br/>
<br/>
·&#160;·&#160;·<br/>
<br/>
<br/>
·&#160;·&#160;·<br/>
<br/>
1<i>,</i>1<br/>
<i>z</i>1<br/>
1<i>,</i>2<br/>
<i>z</i>1<br/>
1<i>,</i>32<br/>
<i>w</i>21<i>,</i>1<br/>
<i>w</i>21<i>,</i>2<br/>
<i>w</i>21<i>,</i>10<br/>
<i>z</i>2<br/>
1<i>,</i>1<br/>
<i>z</i>2<br/>
1<i>,</i>2<br/>
<i>z</i>2<br/>
1<i>,</i>10<br/>
<i>z</i>1<br/>
·&#160;·&#160;·<br/>
·&#160;·&#160;·<br/>
·&#160;·&#160;·<br/>
2<i>,</i>1<br/>
<i>z</i>1<br/>
2<i>,</i>2<br/>
<i>z</i>1<br/>
2<i>,</i>32<br/>
<i>w</i>22<i>,</i>1<br/>
<i>w</i>22<i>,</i>2<br/>
<i>w</i>22<i>,n</i><br/>
<i>z</i>2<br/>
2<i>,</i>1<br/>
<i>z</i>2<br/>
2<i>,</i>2<br/>
<i>z</i>2<br/>
2<i>,</i>10<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<i>σ</i>(<br/>
.<br/>
.<br/>
.<br/>
)&#160;×<br/>
.<br/>
.<br/>
.<br/>
=<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<i>z</i>1<br/>
·&#160;·&#160;·<br/>
·&#160;·&#160;·<br/>
·&#160;·&#160;·<br/>
150<i>,</i>1<br/>
<i>z</i>1<br/>
150<i>,</i>2<br/>
<i>z</i>1<br/>
150<i>,</i>32<br/>
<i>w</i>232<i>,</i>1<br/>
<i>w</i>232<i>,</i>2<br/>
<i>w</i>232<i>,</i>10<br/>
<i>z</i>2<br/>
150<i>,</i>1<br/>
<i>z</i>2<br/>
150<i>,</i>2<br/>
<i>z</i>2<br/>
150<i>,</i>10<br/>
&#160;<i>z</i>2<br/>
·&#160;·&#160;·<br/>
<br/>
<br/>
<br/>
1<i>,</i>1<br/>
<i>z</i>2<br/>
1<i>,</i>2<br/>
<i>z</i>2<br/>
1<i>,</i>10<br/>
ˆ<br/>
<i>y</i>1<i>,</i>1<br/>
ˆ<br/>
<i>y</i>1<i>,</i>2<br/>
·&#160;·&#160;·<br/>
ˆ<br/>
<i>y</i>1<i>,</i>10<br/>
<i>z</i>2<br/>
·&#160;·&#160;·<br/>
2<i>,</i>1<br/>
<i>z</i>2<br/>
2<i>,</i>2<br/>
<i>z</i>2<br/>
2<i>,</i>10<br/>
ˆ<br/>
<i>y</i>2<i>,</i>1<br/>
ˆ<br/>
<i>y</i>2<i>,</i>2<br/>
·&#160;·&#160;·<br/>
ˆ<br/>
<i>y</i>2<i>,</i>10<br/>
<br/>
<br/>
<br/>
<br/>
<i>σ</i>(<br/>
.<br/>
.<br/>
.<br/>
)&#160;=<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<i>z</i>2<br/>
·&#160;·&#160;·<br/>
150<i>,</i>1<br/>
<i>z</i>2<br/>
150<i>,</i>2<br/>
<i>z</i>2<br/>
150<i>,</i>10<br/>
ˆ<br/>
<i>y</i>150<i>,</i>1<br/>
ˆ<br/>
<i>y</i>150<i>,</i>2<br/>
·&#160;·&#160;·<br/>
ˆ<br/>
<i>y</i>150<i>,</i>10<br/>
&#160;ˆ<br/>
<i>y</i><br/>
<br/>
<br/>
<br/>
1<i>,</i>1<br/>
ˆ<br/>
<i>y</i>1<i>,</i>2<br/>
·&#160;·&#160;·<br/>
ˆ<br/>
<i>y</i>1<i>,</i>10<br/>
<i>y</i>1<i>,</i>1<br/>
<i>y</i>1<i>,</i>2<br/>
·&#160;·&#160;·<br/>
<i>y</i>1<i>,</i>10<br/>
ˆ<br/>
<i>y</i>2<i>,</i>1<br/>
ˆ<br/>
<i>y</i>2<i>,</i>2<br/>
·&#160;·&#160;·<br/>
ˆ<br/>
<i>y</i>2<i>,</i>10<br/>
<i>y</i>2<i>,</i>1<br/>
<i>y</i>2<i>,</i>2<br/>
·&#160;·&#160;·<br/>
<i>y</i>2<i>,</i>10<br/>
X&#160;<br/>
<br/>
<br/>
<br/>
<i>LOSS</i>(<i>Y,&#160;</i>ˆ<br/>
<i>Y&#160;</i>)&#160;=<br/>
(<br/>
.<br/>
.<br/>
.<br/>
−<br/>
.<br/>
.<br/>
.<br/>
)2<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.&#160;.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
<br/>
.<br/>
.<br/>
.<br/>
.<br/>
<br/>
ˆ<br/>
<i>y</i>150<i>,</i>1<br/>
ˆ<br/>
<i>y</i>150<i>,</i>2<br/>
·&#160;·&#160;·<br/>
ˆ<br/>
<i>y</i>150<i>,</i>10<br/>
<i>y</i>150<i>,</i>1<br/>
<i>y</i>150<i>,</i>2<br/>
·&#160;·&#160;·<br/>
<i>y</i>150<i>,</i>10<br/>
<i>Z</i>1&#160;=&#160;<i>X.W</i>1<br/>
<i>LAY&#160;ER</i>1&#160;=&#160;<i>σ</i>(<i>Z</i>1)<br/>
<i>Z</i>2&#160;=&#160;<i>LAY&#160;ER</i>1&#160;∗&#160;<i>W</i>2<br/>
ˆ<br/>
<i>Y&#160;</i>=&#160;<i>σ</i>(<i>Z</i>2)<br/>
<i>LOSS&#160;</i>=&#160;(&#160;ˆ<br/>
<i>Y&#160;</i>−&#160;<i>Y&#160;</i>)2<br/>
Calculons&#160;la&#160;dérivée&#160;de&#160;la&#160;fonction&#160;<i>LOSS&#160;</i>en&#160;fonction&#160;de&#160;<i>W&#160;</i>1<br/>
<i>δLOSS</i><br/>
<i>δLOSS&#160;δ&#160;</i>ˆ<br/>
<i>Y</i><br/>
<i>δZ</i>2<br/>
<i>δLAY&#160;ER</i>1&#160;<i>δZ</i>1<br/>
=<br/>
<i>.</i><br/>
<i>.</i><br/>
<i>.</i><br/>
<i>.</i><br/>
<i>δW</i>1<br/>
<i>δ&#160;</i>ˆ<br/>
<i>Y</i><br/>
<i>δZ</i>2&#160;<i>δLAY&#160;ER</i>1<br/>
<i>δZ</i>1<br/>
<i>δW</i>1<br/>
=&#160;2(&#160;ˆ<br/>
<i>Y&#160;</i>−&#160;<i>Y&#160;</i>)<i>.σ</i>0(<i>Z</i>2)<i>.W</i>2<i>.σ</i>0(<i>Z</i>1)<i>.X</i><br/>
2(&#160;ˆ<br/>
<i>Y&#160;</i>−&#160;<i>Y&#160;</i>)&#160;est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(150<i>,&#160;</i>10)<br/>
<i>σ</i>0(<i>Z</i>2)&#160;est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(150<i>,&#160;</i>10)<br/><i>W</i>2&#160;est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(32<i>,&#160;</i>10)<br/><i>σ</i>0(<i>Z</i>1)&#160;est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(150<i>,&#160;</i>32)<br/><i>X&#160;</i>est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(150<i>,&#160;</i>784)<br/>Le&#160;calcul&#160;matriciel&#160;qui&#160;sera&#160;fait&#160;est&#160;<i>t</i>(<i>X</i>)&#160;∗&#160;{(2(&#160;ˆ<br/>
<i>Y&#160;</i>−&#160;<i>Y&#160;</i>)<i>.σ</i>0(<i>Z</i>2)&#160;∗&#160;<i>t</i>(<i>W&#160;</i>2)<i>.σ</i>0(<i>Z</i>1)},&#160;où&#160;∗&#160;est&#160;le&#160;produit<br/>
matriciel&#160;et&#160;<i>.&#160;</i>le&#160;produit&#160;d’Hadamard.&#160;Le&#160;résultat&#160;donne&#160;une&#160;matrice&#160;de&#160;dimension&#160;(784<i>,&#160;</i>32)&#160;qui&#160;est<br/>de&#160;même&#160;dimension&#160;que&#160;<i>W</i>1<br/>
<i>t</i>(150<i>,&#160;</i>784)&#160;∗&#160;{(150<i>,&#160;</i>10)<i>.</i>(150<i>,&#160;</i>10)&#160;∗&#160;<i>t</i>(32<i>,&#160;</i>10)<i>.</i>(150<i>,&#160;</i>32))}&#160;=&#160;(784<i>,&#160;</i>150)&#160;∗&#160;{(150<i>,&#160;</i>10)&#160;∗&#160;(10<i>,&#160;</i>32)<i>.</i>(150<i>,&#160;</i>32)}<br/>
=&#160;(784<i>,&#160;</i>150)&#160;∗&#160;(150<i>,&#160;</i>32)<br/>
=&#160;(784<i>,&#160;</i>32)<br/>
110<br/>
<hr/>
<a name=111></a><img src="document-111_1.png"/><br/>
<b>7.8.4</b><br/>
<b>Fonctions&#160;d’activation</b><br/>
Pour&#160;la&#160;fonction&#160;d’activation,&#160;ici&#160;appelée&#160;<i>σ</i>,&#160;nous&#160;utiliserons&#160;pour&#160;la&#160;première&#160;couche&#160;la&#160;fonction<br/>
<i>relu</i>(<i>x</i>)&#160;=&#160;<i>max</i>(<i>o,&#160;x</i>)<br/>
Pour&#160;la&#160;seconde&#160;couche,&#160;nous&#160;utiliserons&#160;la&#160;fonction&#160;sigmoid&#160;<i>f&#160;</i>(<i>x</i>)&#160;=<br/>
1<br/>
1+<i>e</i>−<i>x</i><br/>
Figure&#160;7.5&#160;–&#160;La&#160;fonction&#160;sigmoid<br/>
Voici&#160;le&#160;code&#160;en&#160;R&#160;:<br/>
#&#160;the&#160;activation&#160;function<br/>
sigmoid&#160;&lt;-&#160;function(x)&#160;{<br/>
1.0&#160;/&#160;(1.0&#160;+&#160;exp(-x))<br/>
}<br/>
x=seq(0,10,0.1)<br/>
plot(x,&#160;sigmoid(x),&#160;type=&#34;l&#34;)<br/>
#&#160;the&#160;derivative&#160;of&#160;the&#160;activation&#160;function<br/>
sigmoid_derivative&#160;&lt;-&#160;function(x)&#160;{<br/>
sigmoid(x)&#160;*&#160;(1.0&#160;-&#160;sigmoid(x))<br/>
}<br/>
Calculons&#160;la&#160;dérivée&#160;de&#160;la&#160;fonction&#160;<i>LOSS&#160;</i>en&#160;fonction&#160;de&#160;<i>W&#160;</i>2<br/>
<i>δLOSS</i><br/>
<i>δLOSS&#160;δ&#160;</i>ˆ<br/>
<i>Y</i><br/>
<i>δZ</i>2<br/>
=<br/>
<i>.</i><br/>
<i>.</i><br/>
(7.1)<br/>
<i>δW</i>2<br/>
<i>δ&#160;</i>ˆ<br/>
<i>Y</i><br/>
<i>δZ</i>2&#160;<i>δW</i>2<br/>
=&#160;2(&#160;ˆ<br/>
<i>Y&#160;</i>−&#160;<i>Y&#160;</i>)<i>.σ</i>0(<i>Z</i>2)<i>.LAY&#160;ER</i>1<br/>
(7.2)<br/>
2(&#160;ˆ<br/>
<i>Y&#160;</i>−&#160;<i>Y&#160;</i>)&#160;est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(150<i>,&#160;</i>10)<br/>
<i>σ</i>0(<i>Z</i>2)&#160;est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(150<i>,&#160;</i>10)<br/><i>LAY&#160;ER</i>1&#160;est&#160;une&#160;matrice&#160;de&#160;dimension&#160;(150<i>,&#160;</i>32)<br/>Le&#160;calcul&#160;matriciel&#160;qui&#160;sera&#160;fait&#160;est&#160;<i>t</i>(<i>LAY&#160;ER</i>1)&#160;∗&#160;(2(&#160;ˆ<br/>
<i>Y&#160;</i>−&#160;<i>Y&#160;</i>)<i>.σ</i>0(<i>Z</i>2)),&#160;où&#160;∗&#160;est&#160;le&#160;produit&#160;matriciel<br/>
et&#160;<i>.&#160;</i>le&#160;produit&#160;d’Hadamard.&#160;Le&#160;résultat&#160;donne&#160;une&#160;matrice&#160;de&#160;dimension&#160;(32<i>,&#160;</i>10)&#160;qui&#160;est&#160;de&#160;même<br/>dimension&#160;que&#160;<i>W</i>2<br/>
<i>t</i>(150<i>,&#160;</i>32)&#160;∗&#160;(150<i>,&#160;</i>10)<i>.</i>(150<i>.</i>10)&#160;=&#160;(32<i>,&#160;</i>150)&#160;∗&#160;(150<i>,&#160;</i>10)&#160;=&#160;(32<i>,&#160;</i>10)<br/>
111<br/>
<hr/>
<a name=112></a><b>7.9</b><br/>
<b>Les&#160;nombres&#160;premiers.&#160;L’algorithme&#160;RSA</b><br/>
—&#160;Le&#160;crible&#160;d’Erathostène&#160;(΄Ερατοσθένης)<br/>—&#160;Leur&#160;répartition<br/>—&#160;Les&#160;nombres&#160;premiers&#160;jumeaux<br/>—&#160;La&#160;constante&#160;de&#160;Brun<br/>—&#160;La&#160;fonction&#160;zêta<br/>—&#160;Le&#160;produit&#160;eulérien&#160;et&#160;sa&#160;convergence&#160;avec&#160;la&#160;suite&#160;harmonique<br/>—&#160;Le&#160;petit&#160;théorème&#160;de&#160;Fermat<br/>—&#160;La&#160;fonction&#160;<i>indicatrice&#160;</i>d’Euler<br/>—&#160;L’algorithme&#160;RSA<br/>
<b>Le&#160;crible</b><br/>
type&#160;’a&#160;stream&#160;=&#160;Cons&#160;of&#160;’a&#160;*&#160;(unit&#160;-&gt;&#160;’a&#160;stream)&#160;;;<br/>
let&#160;hd&#160;(Cons&#160;(h,&#160;_))&#160;=&#160;h&#160;;;<br/>
let&#160;tl&#160;(Cons&#160;(_,&#160;tf))&#160;=&#160;tf&#160;()&#160;;;<br/>
let&#160;rec&#160;take&#160;n&#160;s&#160;=<br/>
if&#160;n=0&#160;then&#160;[]<br/>
else&#160;hd&#160;s&#160;::&#160;take&#160;(n-1)&#160;(tl&#160;s)<br/>
let&#160;rec&#160;entiers&#160;x&#160;=&#160;Cons(x,&#160;fun()&#160;-&gt;&#160;entiers(x+1))<br/>
let&#160;rec&#160;filtre&#160;m&#160;(Cons(x,l))&#160;=<br/>
if&#160;x&#160;mod&#160;m&#160;=&#160;0&#160;then&#160;filtre&#160;m&#160;(l())<br/>
else&#160;Cons(x,&#160;fun()&#160;-&gt;&#160;(filtre&#160;m&#160;(l())))<br/>
let&#160;rec&#160;crible&#160;(Cons(x,l))&#160;=&#160;Cons(x,&#160;fun()-&gt;&#160;crible(filtre&#160;x&#160;(l())))<br/>
let&#160;premiers&#160;=&#160;crible(entiers&#160;2)&#160;;;<br/>
utop&#160;#&#160;take&#160;100&#160;premiers&#160;;;<br/>
-&#160;:&#160;int&#160;list&#160;=<br/>
[2;&#160;3;&#160;5;&#160;7;&#160;11;&#160;13;&#160;17;&#160;19;&#160;23;&#160;29;&#160;31;&#160;37;&#160;41;&#160;43;&#160;47;&#160;53;&#160;59;&#160;61;&#160;67;&#160;71;<br/>
73;&#160;79;&#160;83;&#160;89;&#160;97;&#160;101;&#160;103;&#160;107;&#160;109;&#160;113;&#160;127;&#160;131;&#160;137;&#160;139;&#160;149;&#160;151;<br/>
157;&#160;163;&#160;167;&#160;173;&#160;179;&#160;181;&#160;191;&#160;193;&#160;197;&#160;199;&#160;211;&#160;223;&#160;227;&#160;229;&#160;233;<br/>
239;&#160;241;&#160;251;&#160;257;&#160;263;&#160;269;&#160;271;&#160;277;&#160;281;&#160;283;&#160;293;&#160;307;&#160;311;&#160;313;&#160;317;<br/>
331;&#160;337;&#160;347;&#160;349;&#160;353;&#160;359;&#160;367;&#160;373;&#160;379;&#160;383;&#160;389;&#160;397;&#160;401;&#160;409;&#160;419;<br/>
421;&#160;431;&#160;433;&#160;439;&#160;443;&#160;449;&#160;457;&#160;461;&#160;463;&#160;467;&#160;479;&#160;487;&#160;491;&#160;499;&#160;503;<br/>
509;&#160;521;&#160;523;&#160;541]<br/>
<b>Le&#160;produit&#160;d’Euler&#160;aka&#160;le&#160;produit&#160;eulérien</b><br/>
La&#160;fonction&#160;zêta&#160;est&#160;égale&#160;au&#160;produit&#160;eulérien<br/>
∞<br/>
∞<br/>
∞<br/>
<i>ps</i><br/>
X<br/>
1<br/>
Y<br/>
1<br/>
Y<br/>
<i>ζ</i>(<i>s</i>)&#160;=<br/>
=<br/>
=<br/>
<i>i</i><br/>
<i>ns</i><br/>
1&#160;−&#160;<i>p</i>−<i>s</i><br/>
<i>ps&#160;</i>−&#160;1<br/>
<i>n</i>=1<br/>
<i>i</i>=1<br/>
<i>i</i><br/>
<i>i</i>=1<br/>
<i>i</i><br/>
112<br/>
<hr/>
<a name=113></a>Exemple&#160;pour&#160;<i>s&#160;</i>=&#160;1&#160;avec&#160;la&#160;suite&#160;harmonique<br/>
1&#160;+&#160;1&#160;+&#160;1&#160;+&#160;1&#160;+&#160;1&#160;+&#160;<i>...</i><br/>
=<br/>
1<br/>
<i>.&#160;</i>1&#160;<i>.&#160;</i>1&#160;<i>.&#160;</i>1&#160;<i>.</i>(<i>...</i>)<br/>
2<br/>
3<br/>
4<br/>
5<br/>
1−&#160;1&#160;1−&#160;1&#160;1−&#160;1&#160;1−&#160;1<br/>
2<br/>
3<br/>
5<br/>
7<br/>
=&#160;2<i>.</i>3<i>.</i>5<i>.</i>7<i>.</i>11<i>.</i>13<i>.</i>17<i>.</i>19<i>...</i><br/>
1<i>.</i>2<i>.</i>4<i>.</i>6<i>.</i>10<i>.</i>12<i>.</i>16<i>.</i>18<i>...</i><br/>
Démontrons&#160;cela<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
<i>ζ</i>(1)&#160;=&#160;1&#160;+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+&#160;<i>...</i><br/>
2<br/>
3<br/>
4<br/>
5<br/>
6<br/>
7<br/>
8<br/>
Divisons&#160;par&#160;2<br/>
<i>ζ</i>(1)<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
=<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+&#160;<i>...</i><br/>
2<br/>
2<br/>
4<br/>
6<br/>
8<br/>
10<br/>
12<br/>
14<br/>
16<br/>
La&#160;différence&#160;de&#160;ces&#160;2&#160;équations&#160;donne&#160;:<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
<i>ζ</i>(1)<i>.</i>(1&#160;−<br/>
)&#160;=&#160;1&#160;+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+&#160;<i>...</i><br/>
2<br/>
3<br/>
5<br/>
7<br/>
9<br/>
11<br/>
13<br/>
Divisons&#160;par&#160;3<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
<i>.</i>(1&#160;−<br/>
)<i>.ζ</i>(1)&#160;=<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+<br/>
+&#160;<i>...</i><br/>
3<br/>
2<br/>
3<br/>
9<br/>
15<br/>
21<br/>
27<br/>
33<br/>
39<br/>
La&#160;différence&#160;donne&#160;:<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
(1&#160;−<br/>
)<i>.</i>(1&#160;−<br/>
)<i>.ζ</i>(1)&#160;=&#160;1&#160;+<br/>
+<br/>
+<br/>
+<br/>
+&#160;<i>...</i><br/>
3<br/>
2<br/>
5<br/>
7<br/>
11<br/>
13<br/>
Divisons&#160;par&#160;5<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
<i>.</i>(1&#160;−<br/>
)<i>.</i>(1&#160;−<br/>
)<i>.ζ</i>(1)&#160;=<br/>
+<br/>
+<br/>
+<br/>
+&#160;<i>...</i><br/>
5<br/>
3<br/>
2<br/>
5<br/>
25<br/>
35<br/>
55<br/>
La&#160;différence&#160;donne&#160;:<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
(1&#160;−<br/>
)<i>.</i>(1&#160;−<br/>
)<i>.</i>(1&#160;−<br/>
)<i>.ζ</i>(1)&#160;=&#160;1&#160;+<br/>
+<br/>
+<br/>
+&#160;<i>...</i><br/>
5<br/>
3<br/>
2<br/>
7<br/>
11<br/>
13<br/>
Nous&#160;pouvons&#160;poursuivre&#160;sur&#160;le&#160;principe&#160;du&#160;crible&#160;d’Erathostène<br/>
1<br/>
1<br/>
1<br/>
<i>.&#160;.&#160;.&#160;</i>(1&#160;−<br/>
)<i>.</i>(1&#160;−<br/>
)<i>.</i>(1&#160;−<br/>
)<i>.ζ</i>(1)&#160;=&#160;1<br/>
5<br/>
3<br/>
2<br/>
D’où&#160;:<br/>
<i>ζ</i>(1)<br/>
=<br/>
1<br/>
(1−&#160;1&#160;)<i>.</i>(1−&#160;1&#160;)<i>.</i>(1−&#160;1&#160;)<i>...</i><br/>
2<br/>
3<br/>
5<br/>
<i>ζ</i>(1)<br/>
=<br/>
1<br/>
1&#160;<i>.&#160;</i>2&#160;<i>.&#160;</i>4&#160;<i>...</i><br/>
2&#160;3&#160;5<br/>
<i>ζ</i>(1)<br/>
=<br/>
2<i>.</i>3<i>.</i>5<i>.</i>7<i>.</i>11<i>.</i>13<i>.</i>17<i>.</i>19<i>...<br/></i>1<i>.</i>2<i>.</i>4<i>.</i>6<i>.</i>10<i>.</i>12<i>.</i>16<i>.</i>18<i>...</i><br/>
Le&#160;numérateur&#160;est&#160;le&#160;produit&#160;de&#160;l’ensemble&#160;des&#160;nombres&#160;premiers.&#160;Le&#160;dénominateur&#160;est&#160;le&#160;produit<br/>
de&#160;l’ensemble&#160;des&#160;nombres&#160;premiers&#160;moins&#160;1.<br/>
Exemple&#160;pour&#160;<i>s&#160;</i>=&#160;2&#160;avec&#160;la&#160;suite&#160;carrée<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1&#160;+<br/>
+<br/>
+<br/>
+&#160;<i>...&#160;</i>=<br/>
<i>.</i><br/>
<i>.</i><br/>
<i>.</i><br/>
<i>.</i>(<i>...</i>)<br/>
4<br/>
9<br/>
16<br/>
1&#160;−&#160;1&#160;1&#160;−&#160;1&#160;1&#160;−&#160;1&#160;1&#160;−&#160;1<br/>
4<br/>
9<br/>
25<br/>
49<br/>
113<br/>
<hr/>
<a name=114></a><b>Les&#160;nombres&#160;premiers&#160;jumeaux&#160;et&#160;la&#160;constante&#160;de&#160;Brun</b><br/>
La&#160;somme&#160;inverse&#160;des&#160;nombres&#160;premiers&#160;jumeaux.&#160;Il&#160;y&#160;en&#160;aurait&#160;une&#160;infinité.&#160;Cependant,&#160;cette<br/>
somme&#160;converge&#160;vers&#160;la&#160;constante&#160;de&#160;Brun.<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
<i>Brun&#160;</i>=&#160;(<br/>
+<br/>
)&#160;+&#160;(<br/>
+<br/>
)&#160;+&#160;(<br/>
+<br/>
)&#160;+&#160;(<br/>
+<br/>
)&#160;+&#160;(<br/>
+<br/>
)&#160;+&#160;<i>...</i><br/>
3<br/>
5<br/>
5<br/>
7<br/>
11<br/>
13<br/>
17<br/>
19<br/>
29<br/>
31<br/>
<i>Brun&#160;</i>≈&#160;1<i>,&#160;</i>90216<br/>
let&#160;rec&#160;filtre_jumeaux&#160;=&#160;function<br/>
|&#160;Cons(x,l)&#160;-&gt;&#160;if&#160;(hd&#160;(l())&#160;=&#160;(x+2))&#160;then<br/>
Cons(x,&#160;fun()&#160;-&gt;&#160;Cons&#160;((hd&#160;(l()))&#160;,&#160;(fun()&#160;-&gt;<br/>
(filtre_jumeaux<br/>
(l())))))<br/>
else&#160;filtre_jumeaux&#160;(l())&#160;;;<br/>
take&#160;100&#160;(filtre_jumeaux&#160;premiers)&#160;;;<br/>
let&#160;rec&#160;inverse&#160;(Cons(x,l))&#160;=&#160;Cons(1.&#160;/.&#160;float_of_int&#160;x,&#160;fun()&#160;-&gt;&#160;inverse(l()))&#160;;;<br/>
let&#160;inverse_jumeaux&#160;=&#160;inverse&#160;(filtre_jumeaux&#160;premiers)&#160;;;<br/>
let&#160;rec&#160;somme&#160;n&#160;s&#160;=<br/>
if&#160;n=0&#160;then&#160;0.<br/>
else&#160;hd&#160;s&#160;+.&#160;somme&#160;(n-1)&#160;(tl&#160;s)&#160;;;<br/>
somme&#160;10000&#160;inverse_jumeaux&#160;;;<br/>
Avec&#160;les&#160;10000&#160;premières&#160;paires,&#160;nous&#160;sommes&#160;encore&#160;loin&#160;de&#160;1<i>,&#160;</i>90216.&#160;.&#160;.<br/>
<b>Le&#160;petit&#160;théorème&#160;de&#160;Fermat</b><br/>
Si&#160;<i>p&#160;</i>est&#160;premier&#160;et&#160;si&#160;<i>a&#160;</i>n’est&#160;pas&#160;un&#160;multiple&#160;de&#160;<i>p</i>,&#160;alors&#160;<i>ap</i>−1&#160;≡&#160;1&#160;mod&#160;<i>p</i><br/>
<b>Le&#160;théorème&#160;d’Euler</b><br/>
L’indicatrice&#160;d’Euler&#160;est&#160;une&#160;fonction,&#160;qui&#160;à&#160;tout&#160;entier&#160;naturel&#160;<i>n&#160;</i>non&#160;nul&#160;associe&#160;le&#160;nombre<br/>
d’entiers&#160;compris&#160;entre&#160;1&#160;et&#160;<i>n&#160;</i>et&#160;premiers&#160;avec&#160;<i>n</i>.&#160;Cette&#160;fonction&#160;est&#160;nommée&#160;en&#160;anglais&#160;<i>Euler’s<br/>totient&#160;function</i><br/>
<i>ϕ</i><br/>
:<br/>
∗<br/>
∗<br/>
N<br/>
−→&#160;N<br/>
<i>n</i><br/>
7−→&#160;card{<i>m&#160;</i>∈<br/>
∗<br/>
N&#160;|&#160;<i>m&#160;</i>≤&#160;<i>n&#160;</i>et&#160;<i>m&#160;</i>premier&#160;avec&#160;<i>n</i>}<br/>
Le&#160;théorème&#160;d’Euler&#160;nous&#160;dit&#160;que&#160;<i>aϕ</i>(<i>n</i>)&#160;≡&#160;1&#160;mod&#160;<i>n</i>,&#160;si&#160;<i>a&#160;</i>est&#160;un&#160;entier&#160;premier&#160;à&#160;<i>n</i>.&#160;C’est&#160;une<br/>
généralisation&#160;du&#160;petit&#160;théorème&#160;de&#160;Fermat.<br/>
<b>Le&#160;théorème&#160;de&#160;Bezout</b><br/>
∀<i>x,&#160;y&#160;</i>∈&#160;N<i>,&#160;</i>∃<i>u,&#160;v&#160;</i>∈&#160;Z&#160;tel&#160;que&#160;<i>ux&#160;</i>+&#160;<i>vy&#160;</i>=&#160;pgcd(<i>x,&#160;y</i>)<br/>
114<br/>
<hr/>
<a name=115></a><b>L’inverse&#160;modulaire</b><br/>
Avec&#160;<i>x&#160;</i>et&#160;<i>n&#160;</i>premiers&#160;entre&#160;eux,&#160;en&#160;prenant&#160;<i>u&#160;</i>et&#160;<i>v&#160;</i>dans&#160;Z&#160;tels&#160;que&#160;<i>ux&#160;</i>+&#160;<i>vn&#160;</i>=&#160;1,&#160;on&#160;a&#160;:<br/>
<i>u.x&#160;</i>≡&#160;1<br/>
mod&#160;<i>n</i><br/>
<i>u&#160;</i>≡&#160;<i>x</i>−1<br/>
mod&#160;<i>n</i><br/>
<b>L’algorithme&#160;RSA</b><br/>
Soient&#160;<i>p&#160;&gt;&#160;</i>1&#160;et&#160;<i>q&#160;&gt;&#160;</i>1&#160;deux&#160;nombres&#160;premiers&#160;distincts,&#160;<i>n&#160;</i>=&#160;<i>pq&#160;</i>leur&#160;produit,&#160;<i>e&#160;</i>un&#160;nombre<br/>
premier&#160;avec&#160;<i>ϕ</i>(<i>n</i>)&#160;=&#160;(<i>p&#160;</i>−&#160;1)(<i>q&#160;</i>−&#160;1)&#160;et&#160;<i>d&#160;</i>=&#160;<i>e</i>−1&#160;mod&#160;(<i>p&#160;</i>−&#160;1)(<i>q&#160;</i>−&#160;1).<br/>
Pour&#160;tout&#160;entier&#160;positif&#160;<i>m&#160;&lt;&#160;n</i>,&#160;on&#160;a&#160;<i>med&#160;</i>≡&#160;<i>m&#160;</i>mod&#160;<i>n<br/></i>La&#160;clé&#160;publique&#160;est&#160;le&#160;couple&#160;<i>P&#160;</i>=&#160;(<i>n,&#160;e</i>),&#160;la&#160;clé&#160;secrète&#160;est&#160;le&#160;couple&#160;<i>S&#160;</i>=&#160;(<i>n,&#160;d</i>).<br/><i>Raisonnement&#160;:<br/>ed&#160;</i>≡&#160;1&#160;mod&#160;(<i>p&#160;</i>−&#160;1)(<i>q&#160;</i>−&#160;1),&#160;donc&#160;il&#160;existe&#160;<i>k&#160;</i>tel&#160;que&#160;<i>ed&#160;</i>=&#160;1&#160;+&#160;<i>k</i>(<i>p&#160;</i>−&#160;1)(<i>q&#160;</i>−&#160;1).<br/>Si&#160;<i>m&#160;</i>n’est&#160;pas&#160;multiple&#160;de&#160;<i>p&#160;</i>ni&#160;de&#160;<i>q</i>,&#160;d’après&#160;le&#160;petit&#160;théorème&#160;de&#160;Fermat,<br/>
(<i>med&#160;</i>=&#160;<i>m</i>1+<i>k</i>(<i>p</i>−1)(<i>q</i>−1)&#160;=&#160;<i>m</i>(<i>mp</i>−1)<i>k</i>(<i>q</i>−1)&#160;≡&#160;<i>m&#160;</i>mod&#160;<i>p</i><br/>
<i>med&#160;</i>=&#160;<i>m</i>1+<i>k</i>(<i>p</i>−1)(<i>q</i>−1)&#160;=&#160;<i>m</i>(<i>mq</i>−1)<i>k</i>(<i>q</i>−1)&#160;≡&#160;<i>m</i><br/>
mod&#160;<i>q</i><br/>
et&#160;si&#160;<i>m&#160;</i>est&#160;un&#160;multiple&#160;de&#160;<i>p</i>,&#160;<i>m&#160;</i>≡&#160;0&#160;mod&#160;<i>p&#160;</i>et&#160;<i>med&#160;</i>≡&#160;0&#160;mod&#160;<i>p&#160;</i>(de&#160;même&#160;avec&#160;<i>q</i>).<br/>
L’entier&#160;<i>ued&#160;</i>−&#160;<i>m&#160;</i>est&#160;donc&#160;un&#160;multiple&#160;de&#160;<i>p&#160;</i>et&#160;de&#160;<i>q</i>,&#160;qui&#160;sont&#160;premiers&#160;distincts,&#160;donc&#160;un&#160;multiple<br/>
de&#160;leur&#160;produit&#160;<i>pq&#160;</i>=&#160;<i>n</i><br/>
Donc,&#160;pour&#160;tout&#160;entier&#160;<i>m,&#160;med&#160;</i>≡&#160;<i>m&#160;</i>mod&#160;<i>n</i><br/>
<b>Le&#160;code</b><br/>
open&#160;List<br/>
open&#160;Random<br/>
let&#160;p&#160;=&#160;61&#160;and&#160;q&#160;=&#160;53&#160;;;<br/>
let&#160;n&#160;=&#160;p*q&#160;;;<br/>
let&#160;phi&#160;=&#160;(p-1)*(q-1)&#160;;;&#160;(*&#160;phi=3233&#160;*)<br/>
let&#160;m&#160;=&#160;65&#160;;;<br/>
let&#160;rec&#160;pgcd&#160;a&#160;b&#160;=<br/>
if&#160;b&#160;=&#160;0&#160;then&#160;a<br/>
else&#160;pgcd&#160;b&#160;(a&#160;mod&#160;b)<br/>
let&#160;rec&#160;calcule_e&#160;p&#160;q&#160;=<br/>
let&#160;e&#160;=&#160;Random.int&#160;((p-1)*(q-1))<br/>
in&#160;if&#160;pgcd&#160;e&#160;((p-1)*(q-1))&#160;=&#160;1&#160;then&#160;e<br/>
else&#160;calcule_e&#160;p&#160;q<br/>
let&#160;rec&#160;euclide&#160;a&#160;b&#160;=<br/>
if&#160;b&#160;=&#160;0&#160;then&#160;(&#160;a&#160;,&#160;1&#160;,&#160;0&#160;)<br/>
else<br/>
115<br/>
<hr/>
<a name=116></a>begin<br/>
let&#160;(d’,&#160;u’,&#160;v’)&#160;=&#160;euclide&#160;b&#160;(a&#160;mod&#160;b)<br/>
in&#160;(d’,&#160;v’,&#160;u’&#160;-&#160;(a&#160;/&#160;b)&#160;*&#160;v’&#160;)<br/>
end<br/>
let&#160;calcule_d&#160;p&#160;q&#160;e&#160;=<br/>
let(_,&#160;u&#160;,_)&#160;=&#160;euclide&#160;e&#160;((&#160;p-1)*(q-1))&#160;in<br/>
u&#160;mod&#160;((p-1)*(q-1))<br/>
let&#160;rec&#160;pow&#160;a&#160;m&#160;=&#160;function<br/>
|&#160;0&#160;-&gt;&#160;1&#160;mod&#160;m<br/>
|&#160;1&#160;-&gt;&#160;a&#160;mod&#160;m<br/>
|&#160;n&#160;-&gt;<br/>
let&#160;b&#160;=&#160;pow&#160;a&#160;m&#160;(n&#160;/&#160;2)&#160;in<br/>
b&#160;*&#160;b&#160;*&#160;(if&#160;n&#160;mod&#160;2&#160;=&#160;0&#160;then&#160;1&#160;else&#160;a)&#160;mod&#160;m<br/>
;;<br/>
let&#160;e&#160;=&#160;calcule_e&#160;p&#160;q<br/>
;;<br/>
let&#160;d&#160;=&#160;calcule_d&#160;p&#160;q&#160;e&#160;;;<br/>
crypt&#160;(crypt&#160;m&#160;e&#160;n)&#160;d&#160;n;;<br/>
let&#160;factor&#160;n&#160;=<br/>
let&#160;rec&#160;aux&#160;n&#160;k&#160;l&#160;=<br/>
if&#160;n&#160;&lt;&#160;k/2&#160;then&#160;l<br/>
else&#160;if&#160;(n&#160;mod&#160;k)&#160;=&#160;0&#160;then&#160;aux&#160;(n/k)&#160;k&#160;(k::l)<br/>
else&#160;if&#160;(k=2)&#160;then&#160;aux&#160;n&#160;3&#160;l<br/>
else&#160;aux&#160;n&#160;(k+2)&#160;l<br/>
in&#160;rev&#160;(aux&#160;n&#160;2&#160;[])<br/>
<b>7.10</b><br/>
<b>Approximation&#160;du&#160;nombre&#160;</b><i>π</i><br/>
Que<br/>
j’<br/>
aime<br/>
à<br/>
faire<br/>
connaître<br/>
ce<br/>
nombre<br/>
utile<br/>
aux<br/>
sages.<br/>
3,<br/>
1<br/>
4<br/>
1<br/>
5<br/>
9<br/>
2<br/>
6<br/>
5<br/>
3<br/>
5<br/>
Cherchons&#160;à&#160;approcher&#160;<i>π&#160;</i>par&#160;cinq&#160;méthodes&#160;:<br/>—&#160;La&#160;loi&#160;des&#160;grands&#160;nombres.&#160;Nous&#160;faisons&#160;ici&#160;un&#160;tirage&#160;aléatoire&#160;de&#160;coordonnées&#160;(<i>x,&#160;y</i>)&#160;avec&#160;<i>x</i><br/>
et&#160;<i>y&#160;</i>compris&#160;entre&#160;−1&#160;et&#160;1.&#160;Il&#160;y&#160;a&#160;<i>π&#160;</i>chances&#160;sur&#160;4&#160;que&#160;le&#160;tirage&#160;tombe&#160;dans&#160;le&#160;cercle&#160;de&#160;rayon<br/>1.<br/>
—&#160;La&#160;série&#160;alternée&#160;de&#160;Leibniz<br/>
∞<br/>
<i>π</i><br/>
X<br/>
(−1)<i>n</i><br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
=<br/>
−<br/>
+<br/>
−<br/>
+<br/>
−&#160;·&#160;·&#160;·&#160;=<br/>
2<i>n&#160;</i>+&#160;1<br/>
1<br/>
3<br/>
5<br/>
7<br/>
9<br/>
4<br/>
<i>n</i>=0<br/>
—&#160;Le&#160;calcul&#160;numérique&#160;de&#160;l’intégrale<br/>
Z<br/>
1<br/>
1<br/>
<i>dx</i><br/>
0<br/>
1&#160;+&#160;<i>x</i>2<br/>
116<br/>
<hr/>
<a name=117></a>—&#160;Le&#160;produit&#160;de&#160;Wallis<br/>
2<i>.</i>2<i>.</i>4<i>.</i>4<i>.</i>6<i>.</i>6<i>.</i>8<i>.</i>8<i>.</i>10<i>.</i>10<i>....</i><br/>
<i>π/</i>2&#160;=&#160;1<i>.</i>3<i>.</i>3<i>.</i>5<i>.</i>5<i>.</i>7<i>.</i>7<i>.</i>9<i>.</i>9<i>.</i>11<i>....</i><br/>
Ce&#160;produit&#160;s’écrira&#160;mieux&#160;sous&#160;la&#160;forme&#160;:<br/>
∞<br/>
∞<br/>
2&#160;2<br/>
4&#160;4<br/>
6&#160;6<br/>
8&#160;8<br/>
Y<br/>
2<i>n.</i>2<i>n</i><br/>
Y<br/>
4<i>n</i>2<br/>
(&#160;<i>.&#160;</i>)<i>.</i>(&#160;<i>.&#160;</i>)<i>.</i>(&#160;<i>.&#160;</i>)<i>.</i>(&#160;<i>.&#160;</i>)<i>....&#160;</i>=<br/>
=<br/>
1&#160;3<br/>
2&#160;5<br/>
5&#160;7<br/>
7&#160;9<br/>
(2<i>n&#160;</i>−&#160;1)<i>.</i>(2<i>n&#160;</i>+&#160;1)<br/>
4<i>n</i>2&#160;−&#160;1<br/>
<i>n</i>=1<br/>
<i>n</i>=1<br/>
—&#160;Les&#160;périmètres&#160;des&#160;polygones&#160;réguliers&#160;inscrits&#160;et&#160;circonscrits&#160;au&#160;cercle<br/>
<b>7.10.1</b><br/>
<b>La&#160;méthode&#160;des&#160;polygones</b><br/>
Pour&#160;calculer&#160;la&#160;valeur&#160;de&#160;<i>π</i>,&#160;il&#160;suffit&#160;de&#160;calculer&#160;pour&#160;<i>n&#160;</i>suffisament&#160;grand&#160;les&#160;périmètres&#160;des<br/>
polygones&#160;réguliers&#160;de&#160;<i>n&#160;</i>côtés&#160;inscrits&#160;et&#160;circonscrits&#160;à&#160;un&#160;cercle&#160;de&#160;diamètre&#160;2<i>R&#160;</i>=&#160;1.&#160;Nous&#160;nous<br/>reférerons&#160;à&#160;l’excellent&#160;ouvrage&#160;<a href="documents.html#127">[14].&#160;</a>Cette&#160;approche&#160;est&#160;appelée&#160;en&#160;anglais&#160;<i>the&#160;method&#160;of&#160;exhaustion</i>.<br/>
Le&#160;périmètre&#160;du&#160;polygone&#160;inscrit&#160;sera&#160;nommé&#160;<i>pn</i>.&#160;Le&#160;périmètre&#160;du&#160;polygone&#160;circonscrit&#160;sera&#160;<i>p</i>0<i>n</i>.<br/>
Comme&#160;<i>pn&#160;&lt;&#160;</i>2<i>πR&#160;&lt;&#160;p</i>0<i>n</i>,&#160;on&#160;aura&#160;<i>pn&#160;&lt;&#160;π&#160;&lt;&#160;p</i>0<i>n</i>.&#160;Nous&#160;obtiendrons&#160;alors&#160;deux&#160;valeurs&#160;approchées&#160;de<br/><i>π</i>,&#160;l’une&#160;par&#160;défaut,&#160;l’autre&#160;par&#160;excès.<br/>
<b>Calcul&#160;de&#160;</b><i>p</i>2<i>n&#160;</i><b>en&#160;fonction&#160;de&#160;</b><i>pn</i><br/>
Nous&#160;rappelons&#160;les&#160;deux&#160;définitions&#160;suivantes&#160;:<br/>
<b>Définition&#160;9.&#160;</b><i>Le&#160;rayon&#160;du&#160;polygone&#160;est&#160;le&#160;rayon&#160;du&#160;cercle&#160;circonscrit.</i><br/>
<b>Définition&#160;10.&#160;</b><i>L’apothème&#160;du&#160;polygone&#160;est&#160;le&#160;rayon&#160;du&#160;cercle&#160;inscrit.</i><br/>
Nous&#160;pouvons&#160;ainsi&#160;exprimer&#160;l’apothème&#160;en&#160;fonction&#160;du&#160;rayon&#160;par&#160;la&#160;formule&#160;<i>a&#160;</i>=&#160;<i>r&#160;</i>cos(&#160;<i>π&#160;</i>)&#160;où&#160;<i>n</i><br/>
<i>n</i><br/>
est&#160;le&#160;nombre&#160;de&#160;côté&#160;du&#160;polygone.<br/>
Soit&#160;<i>AB&#160;</i>=&#160;<i>cn&#160;</i>le&#160;côté&#160;du&#160;polygone&#160;régulier&#160;inscrit&#160;et&#160;<i>OH&#160;</i>=&#160;<i>an&#160;</i>son&#160;apothème.<br/><i>C&#160;</i>est&#160;le&#160;milieu&#160;de&#160;l’arc&#160;<i>AB</i>.&#160;On&#160;a&#160;<i>AC&#160;</i>=&#160;<i>c</i>2<i>n</i><br/>
<i>A</i><br/>
<i>c</i>2<i>n</i><br/>
<i>C</i>0<br/>
<i>a</i><br/>
<i>C</i><br/>
<i>O</i><br/>
<i>n</i><br/>
<i>H</i><br/>
<i>B</i><br/>
117<br/>
<hr/>
<a name=118></a>Dans&#160;le&#160;triangle&#160;rectangle&#160;<i>ACC</i>0&#160;:<br/>
<i>AC</i>2&#160;=&#160;<i>CC</i>0<i>.CH&#160;</i>=&#160;<i>CC</i>0(<i>OC&#160;</i>−&#160;<i>OH</i>)<br/>
⇔&#160;<i>c</i>22<i>n&#160;</i>=&#160;2<i>R&#160;</i>−&#160;(<i>R&#160;</i>−&#160;<i>an</i>)<br/>
Or<br/>
p<br/>
<i>OH&#160;</i>=<br/>
<i>OA</i>2&#160;−&#160;<i>AH</i>2<br/>
s<br/>
<i>c</i>2<br/>
⇔&#160;<i>a</i><br/>
<i>n</i><br/>
<i>n&#160;</i>=<br/>
<i>R</i>2&#160;−&#160;4<br/>
Donc<br/>
q<br/>
<i>c</i>22<i>n&#160;</i>=&#160;<i>R</i>(2<i>R&#160;</i>−<br/>
4<i>R</i>2&#160;−&#160;<i>c</i>2<i>n</i>)<br/>
Comme&#160;<i>cn&#160;</i>=&#160;<i>pn&#160;</i>,&#160;on&#160;obtient&#160;:<br/>
<i>n</i><br/>
s<br/>
<i>p</i>2<br/>
<i>p</i>2<br/>
2<i>n&#160;</i>=&#160;<i>R</i>(2<i>R&#160;</i>−<br/>
4<i>R</i>2&#160;−<br/>
)<br/>
4<i>n</i>2<br/>
<i>n</i>2<br/>
Soit&#160;pour&#160;2<i>R&#160;</i>=&#160;1<br/>
q<br/>
<i>p</i>22<i>n&#160;</i>=&#160;2<i>n</i>(<i>n&#160;</i>−<br/>
<i>n</i>2&#160;−&#160;<i>p</i>2<i>n</i>)<br/>
√<br/>
En&#160;partant&#160;d’un&#160;carré&#160;inscrit&#160;(<i>n&#160;</i>=&#160;4),&#160;nous&#160;avons&#160;<i>c</i><br/>
2<br/>
4&#160;=<br/>
et&#160;donc&#160;nous&#160;pouvons&#160;calculer&#160;les<br/>
2<br/>
valeurs&#160;de&#160;<i>p</i>8<i>,&#160;p</i>16<i>,&#160;p</i>32<i>,&#160;.&#160;.&#160;.</i><br/>
<b>Calcul&#160;de&#160;</b><i>p</i>0<i>n&#160;</i><b>en&#160;fonction&#160;de&#160;</b><i>pn</i><br/>
Les&#160;polygones&#160;inscrits&#160;et&#160;cirsconscrits&#160;étant&#160;deux&#160;polygones&#160;semblables,&#160;nous&#160;avons&#160;:<br/>
<i>p</i>0<i>n</i><br/>
<i>R</i><br/>
=<br/>
<i>pn</i><br/>
<i>an</i><br/>
<i>R</i><br/>
⇔&#160;<i>p</i>0<i>n&#160;</i>=&#160;<i>pn.an</i><br/>
2<i>R</i><br/>
⇔&#160;<i>p</i>0<i>n&#160;</i>=&#160;<i>pn.</i>p4<i>R</i>2&#160;−&#160;<i>c</i>2<i>n</i><br/>
2<i>nRp</i><br/>
⇔<br/>
<i>n</i><br/>
<i>p</i>0<i>n&#160;</i>=&#160;p4<i>n</i>2<i>R</i>2&#160;−&#160;<i>p</i>2<i>n</i><br/>
Soit&#160;pour&#160;2<i>R&#160;</i>=&#160;1<br/>
<i>npn</i><br/>
<i>p</i>0<i>n&#160;</i>=&#160;p<i>n</i>2&#160;−&#160;<i>p</i>2<i>n</i><br/>
Les&#160;valeurs&#160;approchées&#160;de&#160;<i>π&#160;</i>par&#160;défaut,&#160;et&#160;par&#160;excès&#160;en&#160;fonction&#160;du&#160;nombre&#160;<i>n&#160;</i>de&#160;côtés&#160;:<br/><i>n&#160;</i>=&#160;4&#160;→&#160;2<i>.</i>82843&#160;<i>&lt;&#160;π&#160;&lt;&#160;</i>4<i>.</i>00002<br/><i>n&#160;</i>=&#160;8&#160;→&#160;3<i>.</i>06148&#160;<i>&lt;&#160;π&#160;&lt;&#160;</i>3<i>.</i>31372<br/><i>n&#160;</i>=&#160;16&#160;→&#160;3<i>.</i>121446&#160;<i>&lt;&#160;π&#160;&lt;&#160;</i>3<i>.</i>18266<br/><i>n&#160;</i>=&#160;32&#160;→&#160;3<i>.</i>136542&#160;<i>&lt;&#160;π&#160;&lt;&#160;</i>3<i>.</i>151722<br/><i>n&#160;</i>=&#160;64&#160;→&#160;3<i>.</i>140274&#160;<i>&lt;&#160;π&#160;&lt;&#160;</i>3<i>.</i>144064<br/>
118<br/>
<hr/>
<a name=119></a>Depuis&#160;la&#160;formule&#160;<i>p</i>22<i>n&#160;</i>=&#160;2<i>n</i>(<i>n&#160;</i>−&#160;p<i>n</i>2&#160;−&#160;<i>p</i>2<i>n</i>)&#160;et&#160;sachant&#160;que&#160;<i>pn&#160;</i>=&#160;<i>n.cn</i>,&#160;nous&#160;pouvons&#160;en&#160;déduire&#160;:<br/>
r<br/>
q<br/>
<i>c</i>2<i>n&#160;</i>=<br/>
2&#160;−<br/>
4&#160;−&#160;<i>c</i>2<i>n</i><br/>
√<br/>
q<br/>
√<br/>
Pour&#160;un&#160;carré&#160;de&#160;rayon&#160;1,&#160;nous&#160;avons&#160;<i>c</i>4&#160;=<br/>
2.&#160;Ainsi&#160;<i>c</i>8&#160;=<br/>
2&#160;−<br/>
2<br/>
s<br/>
r<br/>
r<br/>
q<br/>
√<br/>
q<br/>
√<br/>
De&#160;même,&#160;<i>c</i>16&#160;=<br/>
2&#160;−<br/>
2&#160;+<br/>
2&#160;et&#160;<i>c</i>32&#160;=<br/>
2&#160;−<br/>
2&#160;+<br/>
2&#160;+<br/>
2<br/>
Comme&#160;formule&#160;générique,&#160;nous&#160;obtenons&#160;ainsi&#160;avec&#160;<i>n&#160;</i>−&#160;1&#160;racines&#160;imbriquées&#160;:<br/>
v<br/>u<br/>
s<br/>
r<br/>
u<br/>
q<br/>
√<br/>
<i>c</i><br/>
t<br/>
2<i>n&#160;</i>=<br/>
2&#160;−<br/>
2&#160;+<br/>
2&#160;+<br/>
2&#160;+<br/>
2&#160;+&#160;<i>.&#160;.&#160;.</i><br/>
Quand&#160;<i>n&#160;</i>tend&#160;vers&#160;l’infini,&#160;le&#160;2<i>n</i>-gone&#160;tend&#160;vers&#160;le&#160;cercle.&#160;D’où&#160;:<br/>
v<br/>u<br/>
s<br/>
r<br/>
u<br/>
q<br/>
√<br/>
2<i>n</i>t2&#160;−<br/>
2&#160;+<br/>
2&#160;+<br/>
2&#160;+<br/>
2&#160;+&#160;<i>.&#160;.&#160;.&#160;</i>→&#160;<i>π&#160;quand&#160;m&#160;</i>→&#160;∞<br/>
Nous&#160;pourrons&#160;nous&#160;référer&#160;à&#160;<a href="documents.html#127">[17]</a><br/>
<b>7.10.2</b><br/>
<b>La&#160;série&#160;alternée&#160;de&#160;Leibniz</b><br/>
∞<br/>
<i>π</i><br/>
X<br/>
(−1)<i>n</i><br/>
1<br/>
1<br/>
1<br/>
1<br/>
1<br/>
=<br/>
−<br/>
+<br/>
−<br/>
+<br/>
−&#160;·&#160;·&#160;·&#160;=<br/>
2<i>n&#160;</i>+&#160;1<br/>
1<br/>
3<br/>
5<br/>
7<br/>
9<br/>
4<br/>
<i>n</i>=0<br/>
Nous&#160;pouvons&#160;coder&#160;cette&#160;somme&#160;infinie&#160;en&#160;utilisant&#160;un&#160;type&#160;<i>stream</i>.<br/>
type&#160;’a&#160;stream&#160;=&#160;Cons&#160;of&#160;’a&#160;*&#160;(unit&#160;-&gt;&#160;’a&#160;stream)&#160;;;<br/>
let&#160;hd&#160;(Cons&#160;(h,&#160;_))&#160;=&#160;h&#160;;;<br/>
let&#160;tl&#160;(Cons&#160;(_,&#160;tf))&#160;=&#160;tf&#160;()&#160;;;<br/>
let&#160;rec&#160;sum&#160;n&#160;s&#160;acc&#160;=<br/>
if&#160;n=0&#160;then&#160;acc<br/>
else<br/>
sum&#160;(n-1)&#160;(tl&#160;s)&#160;(acc&#160;+.&#160;(hd&#160;s))&#160;;;<br/>
let&#160;rec&#160;take&#160;n&#160;s&#160;=<br/>
if&#160;n=0&#160;then&#160;[]<br/>
else&#160;hd&#160;s&#160;::&#160;take&#160;(n-1)&#160;(tl&#160;s)&#160;;;<br/>
let&#160;rec&#160;from&#160;i&#160;=&#160;Cons&#160;((((-1.)&#160;**&#160;i&#160;)&#160;/.&#160;(2.*.&#160;i&#160;+.&#160;1.)),&#160;fun&#160;()&#160;-&gt;&#160;from&#160;(i&#160;+.&#160;1.))&#160;;;<br/>
let&#160;leibniz&#160;=&#160;from&#160;0.&#160;;;<br/>
Cette&#160;série&#160;est&#160;belle,&#160;mais&#160;paresseuse.&#160;Elle&#160;converge&#160;très&#160;lentement&#160;vers&#160;<i>π&#160;</i>.&#160;Prenons&#160;les&#160;cinq<br/>
4<br/>
millions&#160;premières&#160;valeurs&#160;de&#160;notre&#160;stream&#160;leibniz.<br/>
#&#160;4.&#160;*.&#160;sum&#160;5000000&#160;leibniz&#160;0.&#160;;;<br/>
-&#160;:&#160;float&#160;=&#160;3.14159245358977968<br/>
119<br/>
<hr/>
<a name=120></a><b>7.10.3</b><br/>
<b>La&#160;loi&#160;des&#160;grands&#160;nombres</b><br/>
Sur&#160;un&#160;tirage&#160;aléatoire&#160;de&#160;coordonnées&#160;(<i>x,&#160;y</i>)&#160;avec&#160;<i>x&#160;</i>et&#160;<i>y&#160;</i>compris&#160;entre&#160;−1&#160;et&#160;1,&#160;il&#160;y&#160;a&#160;<i>π&#160;</i>chances<br/>
sur&#160;4&#160;que&#160;le&#160;tirage&#160;tombe&#160;dans&#160;le&#160;cercle&#160;de&#160;rayon&#160;1.<br/>
comme&#160;un&#160;jeu&#160;de&#160;fléchettes.&#160;.&#160;.<br/>
Le&#160;résultat&#160;des&#160;tirages&#160;est&#160;stocké&#160;sur&#160;notre&#160;liste&#160;&#34;infinie&#34;.&#160;Nous&#160;effectuons&#160;cinq&#160;millions&#160;de&#160;tirage<br/>
qui&#160;nous&#160;permettent&#160;d’obtenir&#160;une&#160;valeur&#160;approchée&#160;de&#160;<i>π&#160;</i>avec&#160;les&#160;deux&#160;premières&#160;décimales&#160;exactes.<br/>
let&#160;gen()&#160;=<br/>
let&#160;x&#160;=&#160;if&#160;Random.bool&#160;()&#160;then&#160;Random.float&#160;1.&#160;else&#160;(-.&#160;Random.float&#160;1.)&#160;in<br/>
let&#160;y&#160;=&#160;if&#160;Random.bool&#160;()&#160;then&#160;Random.float&#160;1.&#160;else&#160;(-.&#160;Random.float&#160;1.)&#160;in<br/>
if&#160;(x&#160;**&#160;2.&#160;+.&#160;y&#160;**&#160;2.&#160;&lt;=&#160;1.)&#160;then&#160;1.0&#160;else&#160;0.0&#160;;;<br/>
let&#160;rec&#160;from&#160;i&#160;=&#160;Cons&#160;(gen(),&#160;fun&#160;()&#160;-&gt;&#160;from&#160;(i&#160;+&#160;1))&#160;;;<br/>
let&#160;rec&#160;sum&#160;n&#160;s&#160;acc&#160;=<br/>
if&#160;n=0&#160;then&#160;acc<br/>
else<br/>
sum&#160;(n-1)&#160;(tl&#160;s)&#160;(acc&#160;+.&#160;(hd&#160;s))&#160;;;<br/>
4.&#160;*.&#160;(sum&#160;5000000<br/>
tirage&#160;0.&#160;/.&#160;5000000.)&#160;;;<br/>
-&#160;:&#160;float&#160;=&#160;3.142153<br/>
<b>7.10.4</b><br/>
<b>Le&#160;produit&#160;de&#160;Wallis</b><br/>
Pour&#160;introduire&#160;le&#160;produit&#160;infini&#160;de&#160;Wallis,&#160;nous&#160;partons&#160;du&#160;fait&#160;que&#160;tout&#160;polynome&#160;de&#160;degré&#160;<i>n</i><br/>
s’écrivant&#160;<i>f&#160;</i>(<i>x</i>)&#160;=&#160;<i>anxn&#160;</i>+&#160;<i>an</i>−1<i>xn</i>−1&#160;+&#160;·&#160;·&#160;·&#160;+&#160;<i>a</i>1<i>x&#160;</i>+&#160;<i>a</i>0&#160;peut&#160;se&#160;décomposer&#160;en&#160;:<br/>
<i>f&#160;</i>(<i>x</i>)&#160;=&#160;<i>an</i>(<i>x&#160;</i>−&#160;<i>x</i>1)(<i>x&#160;</i>−&#160;<i>x</i>2)&#160;<i>.&#160;.&#160;.&#160;</i>(<i>x&#160;</i>−&#160;<i>xn</i>)<br/>
Et&#160;en&#160;factorisant&#160;ce&#160;produit&#160;par&#160;<i>x</i>1<i>.x</i>2&#160;<i>.&#160;.&#160;.&#160;xn</i>,&#160;nous&#160;pouvons&#160;écrire&#160;:<br/>
<i>x</i><br/>
<i>x</i><br/>
<i>x</i><br/>
<i>f&#160;</i>(<i>x</i>)&#160;=&#160;<i>C</i>(1&#160;−<br/>
)(1&#160;−<br/>
)&#160;<i>.&#160;.&#160;.&#160;</i>(1&#160;−<br/>
)<br/>
<i>x</i>1<br/>
<i>x</i>2<br/>
<i>xn</i><br/>
<i>C&#160;</i>est&#160;ici&#160;une&#160;constante&#160;égale&#160;à&#160;<i>a</i>0,&#160;que&#160;nous&#160;avons&#160;calculé&#160;en&#160;posant&#160;<i>x&#160;</i>=&#160;0.<br/>
Euler&#160;aurait&#160;démontré&#160;que&#160;cette&#160;décomposition&#160;vraie&#160;pour&#160;les&#160;polynomes&#160;l’est&#160;également&#160;pour<br/>
la&#160;fonction&#160;sin(<i>x</i>),&#160;et&#160;plus&#160;particulièrement&#160;sin(<i>πx</i>).&#160;Nous&#160;avons&#160;sin(<i>π&#160;n</i>)&#160;=&#160;0&#160;∀<i>n&#160;</i>∈&#160;Z<br/>
<i>x</i>2<br/>
<i>x</i>2<br/>
<i>x</i>2<br/>
<i>x</i>2<br/>
sin(<i>πx</i>)&#160;=&#160;<i>πx</i>(1&#160;−<br/>
)(1&#160;−<br/>
)(1&#160;−<br/>
)(1&#160;−<br/>
)&#160;<i>.&#160;.&#160;.</i><br/>
12<br/>
22<br/>
32<br/>
42<br/>
Et&#160;donc&#160;pour&#160;<i>x&#160;</i>=&#160;1&#160;,&#160;nous&#160;avons&#160;:<br/>
2<br/>
<i>π</i><br/>
<i>π</i><br/>
1<br/>
1<br/>
1<br/>
sin(&#160;)&#160;=&#160;1&#160;=<br/>
(1&#160;−<br/>
)(1&#160;−<br/>
)(1&#160;−<br/>
)&#160;<i>.&#160;.&#160;.</i><br/>
2<br/>
2<br/>
22<i>.</i>12<br/>
22<i>.</i>32<br/>
22<i>.</i>42<br/>
120<br/>
<hr/>
<a name=121></a>Si&#160;nous&#160;écrivons<br/>
1<br/>
(2<i>n&#160;</i>−&#160;1)(2<i>n&#160;</i>+&#160;1)<br/>
1&#160;−<br/>
=<br/>
22<i>.n</i>2<br/>
2<i>n.</i>2<i>n</i><br/>
Nous&#160;obtenons&#160;le&#160;produit&#160;de&#160;Wallis&#160;:<br/>
<i>π</i><br/>
∞<br/>
∞<br/>
2&#160;2<br/>
4&#160;4<br/>
6&#160;6<br/>
8&#160;8<br/>
Y<br/>
2<i>n.</i>2<i>n</i><br/>
Y<br/>
4<i>n</i>2<br/>
=&#160;(&#160;<i>.&#160;</i>)<i>.</i>(&#160;<i>.&#160;</i>)<i>.</i>(&#160;<i>.&#160;</i>)<i>.</i>(&#160;<i>.&#160;</i>)<i>....&#160;</i>=<br/>
=<br/>
2<br/>
1&#160;3<br/>
2&#160;5<br/>
5&#160;7<br/>
7&#160;9<br/>
(2<i>n&#160;</i>−&#160;1)<i>.</i>(2<i>n&#160;</i>+&#160;1)<br/>
4<i>n</i>2&#160;−&#160;1<br/>
<i>n</i>=1<br/>
<i>n</i>=1<br/>
let&#160;rec&#160;from&#160;i&#160;=&#160;Cons&#160;((4.&#160;*.&#160;i**2.&#160;)&#160;/.&#160;(4.&#160;*.&#160;i**2.&#160;-.&#160;1.),&#160;fun&#160;()&#160;-&gt;&#160;from&#160;(i&#160;+.&#160;1.))&#160;;;<br/>
let&#160;wallis&#160;=&#160;from&#160;1.&#160;;;<br/>
let&#160;rec&#160;mult&#160;n&#160;s&#160;acc&#160;=<br/>
if&#160;n=0&#160;then&#160;acc<br/>
else<br/>
mult&#160;(n-1)&#160;(tl&#160;s)&#160;(acc&#160;*.&#160;(hd&#160;s))&#160;;;<br/>
Le&#160;produit&#160;converge&#160;ici&#160;rapidement&#160;vers&#160;<i>π/</i>2.&#160;Nous&#160;multiplions&#160;les&#160;cinquantes&#160;premiers&#160;millions&#160;de<br/>notre&#160;liste&#160;infinie&#160;wallis.<br/>
utop&#160;#<br/>
2.&#160;*.&#160;mult&#160;5000000&#160;wallis&#160;1.&#160;;;<br/>
-&#160;:&#160;float&#160;=&#160;3.14159249652297845<br/>
<b>7.10.5</b><br/>
<b>L’intégrale&#160;</b>R&#160;1<br/>
1<br/>
<i>dx</i><br/>
0&#160;1+<i>x</i>2<br/>
<i>y</i><br/>
<i>n</i><br/>
Z<br/>
1<br/>
1<br/>
1<br/>
<i>π</i><br/>
X<br/>
1<br/>
<i>dx&#160;</i>=&#160;lim<br/>
=<br/>
0<br/>
1&#160;+&#160;<i>x</i>2<br/>
<i>n</i>→∞&#160;<i>n</i><br/>
1&#160;+&#160;(&#160;<i>i&#160;</i>)2<br/>
4<br/>
<i>i</i>=0<br/>
<i>n</i><br/>
<i>x</i><br/>
0<br/>
1<br/>
let&#160;f&#160;x&#160;=&#160;1.&#160;/.&#160;(1.&#160;+.&#160;x**2.)<br/>
let&#160;rec&#160;somme&#160;n&#160;i&#160;acc&#160;=<br/>
if&#160;i&#160;&gt;&#160;n&#160;then&#160;(1./.&#160;n)&#160;*.&#160;acc<br/>
else&#160;somme&#160;n&#160;(i&#160;+.&#160;1.)<br/>
(acc&#160;+.&#160;(f&#160;(i&#160;/.&#160;n)))&#160;;;<br/>
utop&#160;#<br/>
4.&#160;*.&#160;somme&#160;900000000.&#160;0.&#160;0.&#160;;;<br/>
-&#160;:&#160;float&#160;=&#160;3.14159265692298773<br/>
<b>7.11</b><br/>
<b>Poésies</b><br/>
Un&#160;soir&#160;t’en&#160;souvient-il&#160;?&#160;Nous&#160;voguions&#160;en&#160;silence&#160;;<br/>On&#160;n’entendait&#160;au&#160;loin,&#160;sur&#160;l’onde&#160;et&#160;sous&#160;les&#160;cieux,<br/>Que&#160;le&#160;bruit&#160;des&#160;rameurs&#160;qui&#160;frappaient&#160;en&#160;cadence<br/>Tes&#160;flots&#160;harmonieux.<br/>
121<br/>
<hr/>
<a name=122></a>Les&#160;feuilles&#160;mortes&#160;se&#160;ramassent&#160;à&#160;la&#160;pelle<br/>Tu&#160;vois,&#160;je&#160;n’ai&#160;pas&#160;oublié...<br/>Les&#160;feuilles&#160;mortes&#160;se&#160;ramassent&#160;à&#160;la&#160;pelle,<br/>Les&#160;souvenirs&#160;et&#160;les&#160;regrets&#160;aussi<br/>
Agneau&#160;de&#160;Dieu,&#160;qui&#160;sauves&#160;les&#160;hommes,<br/>Agneau&#160;de&#160;Dieu,&#160;qui&#160;nous&#160;comptes&#160;et&#160;nous&#160;nommes,<br/>Agneau&#160;de&#160;Dieu,&#160;vois,&#160;prends&#160;pitié&#160;de&#160;ce&#160;que&#160;nous&#160;sommes.<br/>
<b>7.12</b><br/>
<b>Les&#160;fractions&#160;continues</b><br/>
32<br/>
1<br/>
=&#160;4&#160;+<br/>
7<br/>
1<br/>
1&#160;+<br/>
1<br/>
1&#160;+&#160;3<br/>
let&#160;cont&#160;a&#160;b&#160;=<br/>
let&#160;rec&#160;aux&#160;acc&#160;a&#160;b&#160;=<br/>
if&#160;a&#160;mod&#160;b&#160;=&#160;0&#160;then<br/>
a::acc<br/>
else<br/>
aux&#160;((a&#160;/&#160;b)::acc)&#160;b&#160;(a&#160;mod&#160;b)<br/>
in&#160;rev&#160;(aux&#160;[]&#160;a&#160;b)&#160;;;<br/>
(*<br/>
[4;1;1:3]<br/>
4+\cfrac{1}{1+\cfrac{1}{1+\cfrac{1}{3}}}<br/>
*)<br/>
let&#160;rec&#160;print&#160;=&#160;function<br/>
|&#160;[]&#160;-&gt;&#160;&#34;&#34;<br/>
|&#160;h::[]&#160;-&gt;&#160;string_of_int&#160;h<br/>
|&#160;h::t&#160;-&gt;<br/>
string_of_int(h)&#160;^&#160;&#34;&#160;+&#160;\\cfrac{1}{&#34;&#160;^&#160;print&#160;t&#160;^&#160;&#34;}&#34;&#160;;;<br/>
122<br/>
<hr/>
<a name=123></a>√<br/>
<b>7.13</b><br/>
<b>L’irrationalité&#160;de</b><br/>
2<br/>
<b>Démonstration&#160;par&#160;l’absurde</b><br/>
√<br/>
Considérons&#160;que<br/>
2&#160;=&#160;<i>a&#160;</i>avec&#160;la&#160;fraction&#160;<i>a&#160;</i>étant&#160;réduite.<br/>
<i>b</i><br/>
<i>b</i><br/>
<i>x</i><br/>
√<br/>
Alors,&#160;nous&#160;avons&#160;2&#160;=&#160;<i>a</i>2&#160;⇔&#160;<i>a</i>2&#160;=&#160;2<i>b</i>2<br/>
0<br/>
1<br/>
2<br/>
<i>b</i>2<br/>
Donc&#160;<i>a</i>2&#160;est&#160;pair,&#160;et&#160;donc&#160;<i>a&#160;</i>est&#160;pair.&#160;Nous&#160;écrivons&#160;<i>a&#160;</i>=&#160;2<i>r</i>.<br/>Cela&#160;donne&#160;(2<i>r</i>)2&#160;=&#160;2<i>b</i>2&#160;⇔&#160;2<i>r</i>2&#160;=&#160;<i>b</i>2<br/>Donc&#160;<i>b</i>2&#160;est&#160;pair,&#160;et&#160;donc&#160;<i>b&#160;</i>est&#160;pair.<br/>Ainsi&#160;<i>a&#160;</i>et&#160;<i>b&#160;</i>sont&#160;pairs,&#160;ce&#160;qui&#160;contredit&#160;l’hypothèse&#160;initiale<br/>
√<br/>
D2<br/>
A&#160;=<br/>
2&#160;=&#160;2<br/>
de&#160;la&#160;fraction&#160;réduite.<br/>
√2<br/>
√<br/>
A&#160;=&#160;22&#160;=&#160;4<br/>
1<br/>
2&#160;n’est&#160;pas&#160;un&#160;nombre&#160;rationnel.<br/>
1<br/>
1<br/>
<b>7.14</b><br/>
<b>Démonstration&#160;non&#160;constructive</b><br/>
Démontrons&#160;qu’il&#160;existe&#160;deux&#160;irrationnels&#160;<i>a&#160;</i>et&#160;<i>b&#160;</i>tels&#160;que&#160;<i>ab&#160;</i>soit&#160;rationnel.<br/>
√&#160;√2<br/>
Considérons<br/>
3<br/>
√&#160;√2<br/>
√<br/>
√<br/>
Si<br/>
3<br/>
∈&#160;Q&#160;alors&#160;on&#160;pose&#160;<i>a&#160;</i>=<br/>
3&#160;et&#160;<i>b&#160;</i>=<br/>
2<br/>
√<br/>
√&#160;√<br/>
√<br/>
2<br/>
2<br/>
√<br/>
√<br/>
2<br/>
Sinon,&#160;on&#160;pose&#160;<i>a&#160;</i>=<br/>
3<br/>
et&#160;<i>b&#160;</i>=<br/>
3,&#160;de&#160;sorte&#160;que&#160;(&#160;3<br/>
)<br/>
=&#160;3&#160;∈&#160;Q<br/>
Mais&#160;laquelle&#160;des&#160;deux&#160;est&#160;la&#160;solution&#160;?&#160;Faut-il&#160;abandonner&#160;le&#160;principe&#160;du&#160;<i>tiers&#160;exlus&#160;</i>de&#160;nos<br/>
démonstrations&#160;mathématiques&#160;?<br/>
<b>7.15</b><br/>
<b>L’hyperbole&#160;</b><i>xy&#160;</i>=&#160;1<br/>
<i>y</i><br/>
L’aire&#160;du&#160;rectangle&#160;rouge&#160;est&#160;égale&#160;à&#160;1<br/>
<i>x</i><br/>
123<br/>
<hr/>
<a name=124></a><b>7.16</b><br/>
<b>L’exponentielle</b><br/>
<i>x</i>2<br/>
<i>x</i>3<br/>
<i>x</i>4<br/>
<i>xn</i><br/>
<i>ex&#160;</i>=&#160;1&#160;+&#160;<i>x&#160;</i>+<br/>
+<br/>
+<br/>
+&#160;·&#160;·&#160;·&#160;+<br/>
+&#160;<i>.&#160;.&#160;.</i><br/>
2<br/>
6<br/>
24<br/>
<i>n</i>!<br/>
∞&#160;<i>xk</i><br/>
X<br/>
=<br/>
<i>k</i>!<br/>
<i>k</i>=0<br/>
Nous&#160;avons&#160;ainsi&#160;:&#160;<i>e&#160;</i>=&#160;1&#160;+&#160;1&#160;+&#160;1&#160;+&#160;1&#160;+&#160;1&#160;+&#160;·&#160;·&#160;·&#160;+&#160;+&#160;1&#160;+&#160;<i>.&#160;.&#160;.</i><br/>
2<br/>
6<br/>
24<br/>
<i>n</i>!<br/>
Et&#160;également&#160;<i>e&#160;</i>=&#160;lim<i>n</i>→∞(&#160;1&#160;)<i>n</i><br/>
1+<i>n</i><br/>
<b>7.17</b><br/>
<b>Les&#160;fonctions&#160;</b>sin&#160;1&#160;<b>et&#160;</b><i>x.&#160;</i>sin&#160;1<br/>
<i>x</i><br/>
<i>x</i><br/>
sin&#160;1<i>x</i><br/>
<i>x.&#160;</i>sin&#160;1<i>x</i><br/>
<i>x</i><br/>
<i>x</i><br/>
<b>7.18</b><br/>
<b>Srivanasa&#160;Ramanujan</b><br/>
Le&#160;mathématicien&#160;indien&#160;aurait&#160;découvert&#160;la&#160;très&#160;belle&#160;formule<br/>
s<br/>
r<br/>
q<br/>
√<br/>
3&#160;=<br/>
1&#160;+&#160;2<br/>
1&#160;+&#160;3<br/>
1&#160;+&#160;4&#160;1&#160;+&#160;<i>.&#160;.&#160;.</i><br/>
Posons&#160;<i>f&#160;</i>(<i>n</i>)&#160;=&#160;<i>n</i>(<i>n&#160;</i>+&#160;2),&#160;et&#160;sachant&#160;que&#160;<i>n</i>(<i>n&#160;</i>+&#160;2)&#160;=&#160;<i>n</i>p1&#160;+&#160;(<i>n&#160;</i>+&#160;1)(<i>n&#160;</i>+&#160;3),&#160;nous&#160;avons&#160;:<br/>
q<br/>
<i>f&#160;</i>(<i>n</i>)&#160;=&#160;<i>n</i><br/>
1&#160;+&#160;<i>f&#160;</i>(<i>n&#160;</i>+&#160;1)<br/>
r<br/>
q<br/>
=&#160;<i>n</i><br/>
1&#160;+&#160;(<i>n&#160;</i>+&#160;1)<br/>
1&#160;+&#160;<i>f&#160;</i>(<i>n&#160;</i>+&#160;2)<br/>
s<br/>
r<br/>
q<br/>
=&#160;<i>n</i><br/>
1&#160;+&#160;(<i>n&#160;</i>+&#160;1)<br/>
1&#160;+&#160;(<i>n&#160;</i>+&#160;2)<br/>
1&#160;+&#160;<i>f&#160;</i>(<i>n&#160;</i>+&#160;3)<br/>
124<br/>
<hr/>
<a name=125></a>let&#160;rec&#160;f&#160;n&#160;i&#160;=<br/>
if&#160;i&#160;=&#160;0&#160;then&#160;1.<br/>
else&#160;n&#160;*.&#160;sqrt(1.&#160;+.&#160;(f&#160;(n&#160;+.&#160;1.)&#160;(i-1)))<br/>
utop&#160;#&#160;f&#160;1.&#160;10&#160;;;<br/>
-&#160;:&#160;float&#160;=&#160;2.99480026926620502<br/>
Nous&#160;pouvons&#160;définir&#160;la&#160;fonction&#160;d’affichage&#160;f_latex&#160;comme&#160;ci-dessous&#160;:<br/>
let&#160;rec&#160;f_latex&#160;n&#160;i&#160;=<br/>
if&#160;i&#160;=&#160;0&#160;then&#160;&#34;\\ldots&#34;<br/>
else&#160;(string_of_int&#160;n)^&#160;&#34;\\sqrt{1&#160;+&#160;&#34;&#160;^&#160;(f_latex&#160;(n&#160;+&#160;1)&#160;(i-1))&#160;^&#160;&#34;}&#34;&#160;;;<br/>
print_string&#160;(f_latex&#160;1&#160;10)&#160;;;<br/>
v<br/>u<br/>
v<br/>
v<br/>
u<br/>
u<br/>
u<br/>
v<br/>
u<br/>
u<br/>
v<br/>
u<br/>
u<br/>
v<br/>
u<br/>
u<br/>
u<br/>
u<br/>
u<br/>
u<br/>
s<br/>
u<br/>
u<br/>
u<br/>
r<br/>
u<br/>
u<br/>
u<br/>
u<br/>
u<br/>
u<br/>
q<br/>
√<br/>
u<br/>
u<br/>
3&#160;=&#160;1<br/>
t<br/>
u1&#160;+&#160;2u1&#160;+&#160;3<br/>
t<br/>
t1&#160;+&#160;4t1&#160;+&#160;5<br/>
1&#160;+&#160;6<br/>
1&#160;+&#160;7<br/>
1&#160;+&#160;8<br/>
1&#160;+&#160;9<br/>
1&#160;+&#160;10&#160;1&#160;+&#160;<i>.&#160;.&#160;.</i><br/>
t<br/>
t<br/>
<b>7.19</b><br/>
<b>Le&#160;grec&#160;ancien</b><br/>
<b>7.19.1</b><br/>
<b>L’alphabet&#160;grec</b><br/>
<i>α</i><br/>
<i>β</i><br/>
<i>γ</i><br/>
<i>δ</i><br/>
<i></i><br/>
<i>ζ</i><br/>
<i>η</i><br/>
<i>θ</i><br/>
<i>ι</i><br/>
<i>κ</i><br/>
<i>λ</i><br/>
<i>µ</i><br/>
<i>ν</i><br/>
<i>ξ</i><br/>
<i>o</i><br/>
<i>π</i><br/>
<i>ρ</i><br/>
<i>σ</i><br/>
<i>τ</i><br/>
<i>υ</i><br/>
<i>φ</i><br/>
<i>χ</i><br/>
<i>ψ</i><br/>
<i>ω</i><br/>
<i>A</i><br/>
<i>B</i><br/>
Γ<br/>
∆<br/>
<i>E</i><br/>
<i>Z</i><br/>
<i>H</i><br/>
Θ<br/>
<i>I</i><br/>
<i>K</i><br/>
Λ<br/>
<i>M</i><br/>
<i>N</i><br/>
Ξ<br/>
<i>O</i><br/>
Π<br/>
<i>R</i><br/>
Σ<br/>
<i>T</i><br/>
Υ<br/>
Φ<br/>
<i>X</i><br/>
Ψ<br/>
Ω<br/>
<b>7.19.2</b><br/>
<b>Les&#160;mathématiques&#160;grecques</b><br/>
j’apprends<br/>
ματηανο<br/>
l’étude,&#160;la&#160;leçon<br/>
το&#160;ματηεμα<br/>
l’étude&#160;par&#160;excellence<br/>
τα&#160;ματηεματιθα<br/>
<b>7.19.3</b><br/>
<b>Extraits&#160;du&#160;nouveau&#160;testament</b><br/>
ΙΧΘΥΣ<br/>
᾿Ιησοῦς&#160;Χριστὸς&#160;Θεοῦ&#160;Υἱὸς&#160;Σωτήρ<br/>
᾿Εγὼ&#160;τὸ&#160;῎Αλφα&#160;καὶ&#160;τὸ&#160;Ομεγα,&#160;ὁ&#160;πρῶτος&#160;καὶ&#160;ὁ&#160;ἔσχατος,&#160;ἡ&#160;ἀρχὴ&#160;καὶ&#160;τὸ&#160;τέλος<br/>
῎Αλλην&#160;παραβολὴν&#160;παρέθηκεν&#160;αὐτοῖς,&#160;λέγων,&#160;῾Ομοία&#160;ἐστὶν&#160;ἡ&#160;βασιλεία&#160;τῶν&#160;οὐρανῶν&#160;κόκκῳ&#160;σινάπεως,<br/>
ὃν&#160;λαβὼν&#160;ἄνθρωπος&#160;ἔσπειρεν&#160;ἐν&#160;τῷ&#160;ἀγρῷ&#160;αὐτοῦ&#160;:&#160;ὃ&#160;μικρότερον&#160;μέν&#160;ἐστιν&#160;πάντων&#160;τῶν&#160;σπερμάτων&#160;:<br/>
ὅταν&#160;δὲ&#160;αὐξηθῇ,&#160;μεῖζον&#160;τῶν&#160;λαχάνων&#160;ἐστίν,&#160;καὶ&#160;γίνεται&#160;δένδρον,&#160;ὥστε&#160;ἐλθεῖν&#160;τὰ&#160;πετεινὰ&#160;τοῦ&#160;οὐρανοῦ<br/>
καὶ&#160;κατασκηνοῦν&#160;ἐν&#160;τοῖς&#160;κλάδοις&#160;αὐτοῦ.<br/>
Ειρενε&#160;υμιν&#160;!<br/>
125<br/>
<hr/>
<a name=126></a>126<br/>
<hr/>
<a name=127></a><b>Bibliographie</b><br/>
[1]&#160;<i>Livre&#160;de&#160;la&#160;Genèse,&#160;Gn&#160;11,&#160;1-9</i>.<br/>
[2]&#160;Badiou&#160;Alain.&#160;<i>Eloge&#160;des&#160;mathématiques</i>.&#160;Flammarion,&#160;2015.<br/>
[3]&#160;Henk&#160;Barendregt.&#160;<i>Lambda&#160;calculi&#160;with&#160;types</i>.<br/>
[4]&#160;Jacques&#160;Chazarain.&#160;<i>Programmer&#160;avec&#160;Scheme&#160;:&#160;De&#160;la&#160;pratique&#160;à&#160;la&#160;théorie</i>.&#160;International<br/>
Thomson&#160;Publ.&#160;France,&#160;1996.<br/>
[5]&#160;Francois&#160;Chollet&#160;and&#160;JJ&#160;Allaire.&#160;Deep&#160;learning&#160;with&#160;r,&#160;2018.<br/>
[6]&#160;Baader&#160;Franz.&#160;<i>Term&#160;Rewriting&#160;and&#160;All&#160;That</i>.&#160;Cambridge&#160;University&#160;Press,&#160;1998.<br/>
[7]&#160;André&#160;Gide.&#160;<i>Les&#160;faux&#160;monnayeurs</i>.<br/>
[8]&#160;Jean-Yves&#160;Girard.&#160;<i>Le&#160;Point&#160;Aveugle,&#160;vers&#160;la&#160;perfection</i>.&#160;2006.<br/>
[9]&#160;Douglas&#160;R&#160;Hofstadter&#160;et&#160;al.&#160;<i>Gödel,&#160;Escher,&#160;Bach&#160;:&#160;an&#160;eternal&#160;golden&#160;braid</i>,&#160;volume&#160;13.&#160;Basic<br/>
books&#160;New&#160;York,&#160;1979.<br/>
[10]&#160;Victor&#160;Hugo.&#160;<i>Les&#160;travailleurs&#160;de&#160;la&#160;mer</i>.<br/>
[11]&#160;Donald&#160;Knuth.&#160;<i>The&#160;</i>METAFONT&#160;<i>Book</i>.&#160;Addison&#160;Wesley,&#160;1992.<br/>
[12]&#160;René&#160;Lalement.&#160;<i>Logique,&#160;réduction,&#160;résolution</i>.&#160;1990.<br/>
[13]&#160;Leslie&#160;Lamport.&#160;<i>LATEX&#160;a&#160;document&#160;preparation&#160;system</i>.&#160;Addison-wesley,&#160;1994.<br/>[14]&#160;C.&#160;Lebossé.&#160;<i>Géométrie&#160;plane</i>.&#160;Fernand&#160;Nathan,&#160;1947.<br/>
[15]&#160;Henri&#160;Poincaré.&#160;<i>La&#160;science&#160;et&#160;l’hypothèse</i>.&#160;1902.<br/>
[16]&#160;Christian&#160;Queinnec.&#160;<i>Lisp&#160;in&#160;small&#160;pieces</i>.&#160;Cambridge&#160;University&#160;Press,&#160;2003.<br/>
[17]&#160;Courant&#160;Richard.&#160;<i>What&#160;is&#160;Mathematics&#160;?&#160;</i>Oxford&#160;University&#160;Press,&#160;1941.<br/>
[18]&#160;William&#160;Shakespeare.&#160;<i>Romeo&#160;and&#160;Juliet</i>.<br/>
[19]&#160;Daniel&#160;P.&#160;Friedman&#160;Stanley&#160;Jefferson.&#160;<i>A&#160;Simple&#160;Reflective&#160;Interpreter</i>.&#160;1992.<br/>
[20]&#160;Pierre&#160;Weis&#160;and&#160;Xavier&#160;Leroy.&#160;<i>Le&#160;langage&#160;Caml</i>.&#160;Dunod,&#160;1999.<br/>
127<br/>
<hr/>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="documents.html#9">Le -calcul et la réduction</a>
<ul>
<li><a href="documents.html#9">Définition, champ lexical et syntaxique</a>
<ul>
<li><a href="documents.html#9">Analyse lexicale avec ocamllex</a></li>
<li><a href="documents.html#10">Analyse syntaxique avec menhir</a></li>
<li><a href="documents.html#11">Implémentation du parsing en mode récursif descendant</a></li>
</ul>
</li>
<li><a href="documents.html#13">Représentation en ML</a></li>
<li><a href="documents.html#17">La -réduction faible avec appel par valeur</a></li>
<li><a href="documents.html#18">La récursivité, le point fixe et la diagonale de Cantor</a></li>
<li><a href="documents.html#24">Church encoding. Les entiers et les booléens en -calcul</a>
<ul>
<li><a href="documents.html#24">Les entiers Church&#160;</a></li>
<li><a href="documents.html#26">Les booléens&#160;</a></li>
<li><a href="documents.html#26">La fonction factorielle</a></li>
</ul>
</li>
<li><a href="documents.html#26">La notation de de Bruijn</a></li>
</ul>
</li>
<li><a href="documents.html#29">Le -calcul simplement typé et les Pure Type Systems</a>
<ul>
<li><a href="documents.html#29">Le -calcul simplement typé</a>
<ul>
<li><a href="documents.html#29">Présentation</a></li>
<li><a href="documents.html#29">Implémentation en COQ</a></li>
<li><a href="documents.html#33">Inférence de type</a></li>
</ul>
</li>
<li><a href="documents.html#35">Les Pure Type Systems</a>
<ul>
<li><a href="documents.html#35">Introduction</a></li>
<li><a href="documents.html#38">MiniCOQ</a></li>
<li><a href="documents.html#40">Le &#160;logique</a></li>
<li><a href="documents.html#41">L'égalité</a></li>
<li><a href="documents.html#42">Le faux</a></li>
<li><a href="documents.html#43">Le point fixe</a></li>
<li><a href="documents.html#43">La logique classique</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="documents.html#47">L'interprétation</a>
<ul>
<li><a href="documents.html#47">Introduction</a></li>
<li><a href="documents.html#47">Un interprète MiniScheme avec OCAML</a>
<ul>
<li><a href="documents.html#47">L'évaluation</a></li>
<li><a href="documents.html#49">Les étapes Read, Eval, Print</a></li>
<li><a href="documents.html#50">Liaison lexicale vs liaison dynamique</a></li>
<li><a href="documents.html#51">Gestion de l'environnement</a></li>
</ul>
</li>
<li><a href="documents.html#53">Un interprète LISP avec le nouvel interprète MiniScheme …</a></li>
<li><a href="documents.html#54">L'auto-interprétation de l'interprète</a>
<ul>
<li><a href="documents.html#54">La tour de Babel</a></li>
<li><a href="documents.html#55">Réification et réflexion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="documents.html#63">La compilation</a>
<ul>
<li><a href="documents.html#63">Compilation des -termes en termes applicatifs</a></li>
<li><a href="documents.html#67">Compilation basique vers une machine à pile</a>
<ul>
<li><a href="documents.html#68">Certification de la compilation avec le langage COQ</a></li>
</ul>
</li>
<li><a href="documents.html#71">Compilation du LISP vers une machine abstraite</a></li>
</ul>
</li>
<li><a href="documents.html#75">La résolution</a>
<ul>
<li><a href="documents.html#75">Représentation des termes finis</a></li>
<li><a href="documents.html#77">La substitution</a></li>
<li><a href="documents.html#78">Filtrage et réécriture</a>
<ul>
<li><a href="documents.html#78">Le filtrage</a></li>
<li><a href="documents.html#79">La réécriture et l'arithmétique de Peano</a></li>
</ul>
</li>
<li><a href="documents.html#81">L'unification des termes</a></li>
<li><a href="documents.html#83">Un mini PROLOG</a></li>
<li><a href="documents.html#84">Quelques exemples de programmation en PROLOG</a>
<ul>
<li><a href="documents.html#84">Les entiers naturels</a></li>
<li><a href="documents.html#84">Les additions de Peano</a></li>
<li><a href="documents.html#85">Programmation &#34;logique&#34; en COQ</a></li>
<li><a href="documents.html#86">La base généalogique</a></li>
</ul>
</li>
<li><a href="documents.html#86">L'algorithme de complétion de Knuth-Bendix</a>
<ul>
<li><a href="documents.html#86">Confluence et paires critiques</a></li>
<li><a href="documents.html#88">Terminaison</a></li>
<li><a href="documents.html#88">Complétion de Knuth-Bendix</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="documents.html#91">Calculabilité et complexité</a>
<ul>
<li><a href="documents.html#91">Les fonctions récursives</a></li>
<li><a href="documents.html#93">La machine de Turing</a></li>
<li><a href="documents.html#95">La thèse de Church</a></li>
<li><a href="documents.html#96">Complexité</a>
<ul>
<li><a href="documents.html#96">Théorème de Cook</a></li>
<li><a href="documents.html#96">Implémentation de l'algorithme SAT</a></li>
<li><a href="documents.html#97">Sudoku - SAT encoding</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="documents.html#99">Annexes / Divers</a>
<ul>
<li><a href="documents.html#99">Quelques fonctions sur les listes</a></li>
<li><a href="documents.html#99">Les listes mutables</a></li>
<li><a href="documents.html#100">Les listes infinies ou streams</a></li>
<li><a href="documents.html#102">Le module Graphics d'OCAML, les fractales</a></li>
<li><a href="documents.html#105">Utilisation de Metafont</a></li>
<li><a href="documents.html#107">The boxes</a></li>
<li><a href="documents.html#108">Les modules OCAML. Modélisation d'un monoïde</a></li>
<li><a href="documents.html#109">Machine Learning and Neural Networks</a>
<ul>
<li><a href="documents.html#109">Introduction</a></li>
<li><a href="documents.html#109">Un peu de théorie</a></li>
<li><a href="documents.html#110">Calcul matriciel</a></li>
<li><a href="documents.html#111">Fonctions d'activation</a></li>
</ul>
</li>
<li><a href="documents.html#112">Les nombres premiers. L'algorithme RSA</a></li>
<li><a href="documents.html#116">Approximation du nombre &#160;</a>
<ul>
<li><a href="documents.html#117">La méthode des polygones</a></li>
<li><a href="documents.html#119">La série alternée de Leibniz</a></li>
<li><a href="documents.html#120">La loi des grands nombres</a></li>
<li><a href="documents.html#120">Le produit de Wallis</a></li>
<li><a href="documents.html#121">L'intégrale 01 11+x2 dx</a></li>
</ul>
</li>
<li><a href="documents.html#121">Poésies</a></li>
<li><a href="documents.html#122">Les fractions continues</a></li>
<li><a href="documents.html#123">L'irrationalité de 2</a></li>
<li><a href="documents.html#123">Démonstration non constructive</a></li>
<li><a href="documents.html#123">L'hyperbole xy=1</a></li>
<li><a href="documents.html#124">L'exponentielle</a></li>
<li><a href="documents.html#124">Les fonctions sin1x et x . sin1x&#160;</a></li>
<li><a href="documents.html#124">Srivanasa Ramanujan</a></li>
<li><a href="documents.html#125">Le grec ancien</a>
<ul>
<li><a href="documents.html#125">L'alphabet grec</a></li>
<li><a href="documents.html#125">Les mathématiques grecques</a></li>
<li><a href="documents.html#125">Extraits du nouveau testament</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr/>
</body>
</html>
