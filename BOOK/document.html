<!DOCTYPE html>
<html lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.35">
<style type="text/css">
.equationcontainer{position:relative;}
.equationnumber{float:right;left:auto;position:absolute;right:0}
.equationnumber-valign{float:right;left:auto;position:absolute;right:0;margin-top:-0.5em;}
.floatrule{background-color: black; border: none; height: 1px; width: 80%}
.phantom{display: inline-block; visibility: hidden}
.hphantom{display: inline-block; height: 0; visibility: hidden}
.vphantom{display: inline-block; visibility: hidden; width: 0}
.smash{display: inline-block; height: 0; line-height: 0}
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{background-color: black; border: none; height: 1px; margin: 1em auto 1em 0px; width: 40%}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.quote{margin-left:3em;margin-right:3em;text-align:inherit;text-indent:0pt}
.quotation{margin-left:3em;margin-right:3em;text-align:inherit;text-indent:1.5em}
.verse{margin-left:3em;margin-right:3em;text-indent:1.5em hanging each-line}
.parbox{box-sizing: border-box;
display: inline-block;
text-indent: 0;
}
.rule-rect{fill: black;}
.lrbox{box-sizing:border-box;display:inline-block;overflow:visible;white-space:nowrap;}
.center-lrbox{display:inline-block;margin-left:50%;transform:translateX(-50%);}
.makebox{}
.framebox{border:1px solid black;padding:0.25em;}
.vertical-rule{border:none;width:2px;background-color:black;}
.horizontal-rule{border:none;background-color:black;}
.hrule{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;line-height:1.1;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;line-height:1.1;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; margin-bottom:1ex; width:20%; text-align:left;}
.marginparleft{float:left; clear:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; clear:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</style>
<title>Le calcul  
 Réduction et résolution  
	 Exemples en Scheme, ML et COQ  
 
 

Ἀγεωμέτρητος μη εἰσίτω   
 
</title>
</head>
<body >
<!--HEVEA command line is: hevea document.tex -->
<!--CUT STYLE book--><!--CUT DEF chapter 1 --><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">Le calcul <br>
 Réduction et résolution <br>
	 Exemples en Scheme, ML et COQ <br>
<br>
<br>

Ἀγεωμέτρητος μη εἰσίτω  <br>
 </h1><h3 class="titlerest">Vincent Cognet</h3><h3 class="titlerest">Sainte-Marguerite, le 27 avril 2020 <br>
 <span style="font-family:monospace">https://github.com/cogtoto</span></h3></td></tr>
</table><!--TOC chapter id="sec1" Table des matières-->
<h1 id="sec1" class="chapter">Table des matières</h1><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#sec3">Chapitre ‍1 Le λ-calcul et la réduction</a>
<ul class="toc"><li class="li-toc">
<a href="#sec4">1.1 Définition, champ lexical et syntaxique</a>
<ul class="toc"><li class="li-toc">
<a href="#sec5">1.1.1 Analyse lexicale avec ocamllex</a>
</li><li class="li-toc"><a href="#sec6">1.1.2 Analyse syntaxique avec menhir</a>
</li><li class="li-toc"><a href="#sec7">1.1.3 Implémentation du parsing en mode <span style="font-style:italic">récursif descendant</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec8">1.2 Représentation en ML</a>
</li><li class="li-toc"><a href="#sec9">1.3 La β-réduction faible avec appel par valeur</a>
</li><li class="li-toc"><a href="#sec10">1.4 La récursivité et le point fixe</a>
</li><li class="li-toc"><a href="#sec11">1.5 <span style="font-style:italic">Church</span> encoding. Les entiers et les booléens en λ-calcul</a>
<ul class="toc"><li class="li-toc">
<a href="#sec12">1.5.1 Les entiers <span style="font-style:italic">Church</span> </a>
</li><li class="li-toc"><a href="#sec13">1.5.2 Les booléens </a>
</li><li class="li-toc"><a href="#sec14">1.5.3 La fonction factorielle</a>
</li></ul>
</li><li class="li-toc"><a href="#sec15">1.6 La notation de <span style="font-style:italic">de Bruijn</span></a>
</li><li class="li-toc"><a href="#sec16">1.7 Le λ-calcul simplement typé</a>
</li><li class="li-toc"><a href="#sec19">1.8 Les <span style="font-style:italic">Pure Type Systems</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec27">Chapitre ‍2 L’interprétation</a>
<ul class="toc"><li class="li-toc">
<a href="#sec28">2.1 Introduction</a>
</li><li class="li-toc"><a href="#sec29">2.2 Un interprète MiniScheme avec OCAML</a>
<ul class="toc"><li class="li-toc">
<a href="#sec30">2.2.1 L’évaluation</a>
</li><li class="li-toc"><a href="#sec31">2.2.2 Les étapes Read, Eval, Print</a>
</li><li class="li-toc"><a href="#sec32">2.2.3 Liaison lexicale vs liaison dynamique</a>
</li><li class="li-toc"><a href="#sec33">2.2.4 Gestion de l’environnement</a>
</li></ul>
</li><li class="li-toc"><a href="#sec34">2.3 Un interprète LISP avec le nouvel interprète MiniScheme …</a>
</li><li class="li-toc"><a href="#sec37">2.4 L’auto-interprétation de l’interprète</a>
<ul class="toc"><li class="li-toc">
<a href="#sec38">2.4.1 La tour de Babel</a>
</li><li class="li-toc"><a href="#sec40">2.4.2 Réification et réflexion</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec42">Chapitre ‍3 La compilation</a>
<ul class="toc"><li class="li-toc">
<a href="#sec43">3.1 Compilation des λ-termes en termes applicatifs</a>
</li><li class="li-toc"><a href="#sec45">3.2 Compilation basique vers une machine à pile</a>
<ul class="toc"><li class="li-toc">
<a href="#sec46">3.2.1 Certification de la compilation avec le langage COQ</a>
</li></ul>
</li><li class="li-toc"><a href="#sec47">3.3 Compilation du LISP vers une machine abstraite</a>
</li></ul>
</li><li class="li-toc"><a href="#sec52">Chapitre ‍4 La résolution</a>
<ul class="toc"><li class="li-toc">
<a href="#sec53">4.1 Représentation des termes finis</a>
</li><li class="li-toc"><a href="#sec54">4.2 La substitution</a>
</li><li class="li-toc"><a href="#sec55">4.3 Filtrage et réécriture</a>
<ul class="toc"><li class="li-toc">
<a href="#sec56">4.3.1 Le filtrage</a>
</li><li class="li-toc"><a href="#sec57">4.3.2 La réécriture et l’arithmétique de Peano</a>
</li></ul>
</li><li class="li-toc"><a href="#sec58">4.4 L’unification des termes</a>
</li><li class="li-toc"><a href="#sec59">4.5 Un mini PROLOG</a>
</li><li class="li-toc"><a href="#sec60">4.6 Quelques exemples de programmation en PROLOG</a>
<ul class="toc"><li class="li-toc">
<a href="#sec61">4.6.1 Les entiers naturels</a>
</li><li class="li-toc"><a href="#sec62">4.6.2 Les additions de Peano</a>
</li><li class="li-toc"><a href="#sec63">4.6.3 La base généalogique</a>
</li></ul>
</li><li class="li-toc"><a href="#sec64">4.7 L’algorithme de complétion de Knuth-Bendix</a>
<ul class="toc"><li class="li-toc">
<a href="#sec65">4.7.1 Confluence et paires critiques</a>
</li><li class="li-toc"><a href="#sec66">4.7.2 Terminaison</a>
</li><li class="li-toc"><a href="#sec69">4.7.3 Complétion de Knuth-Bendix</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec70">Chapitre ‍5 La calculabilité</a>
<ul class="toc"><li class="li-toc">
<a href="#sec71">5.1 Les fonctions récursives</a>
</li><li class="li-toc"><a href="#sec72">5.2 La machine de Turing</a>
</li><li class="li-toc"><a href="#sec73">5.3 La thèse de Church</a>
</li></ul>
</li><li class="li-toc"><a href="#sec74">Chapitre ‍6 Annexes / Divers</a>
<ul class="toc"><li class="li-toc">
<a href="#sec75">6.1 Quelques fonctions sur les listes</a>
</li><li class="li-toc"><a href="#sec76">6.2 Les listes mutables</a>
</li><li class="li-toc"><a href="#sec77">6.3 Les listes infinies ou <span style="font-style:italic">streams</span></a>
</li><li class="li-toc"><a href="#sec78">6.4 Le module Graphics d’OCAML, les fractales</a>
</li><li class="li-toc"><a href="#sec80">6.5 Utilisation de </a>
</li><li class="li-toc"><a href="#sec81">6.6 The boxes</a>
</li><li class="li-toc"><a href="#sec82">6.7 Les modules OCAML. Modélisation d’un monoïde</a>
</li><li class="li-toc"><a href="#sec83">6.8 Machine Learning and Neural Networks</a>
<ul class="toc"><li class="li-toc">
<a href="#sec84">6.8.1 Introduction</a>
</li><li class="li-toc"><a href="#sec85">6.8.2 Un peu de théorie</a>
</li><li class="li-toc"><a href="#sec86">6.8.3 Calcul matriciel</a>
</li><li class="li-toc"><a href="#sec87">6.8.4 Fonctions d’activation</a>
</li></ul>
</li><li class="li-toc"><a href="#sec88">6.9 Les nombres premiers. L’algorithme RSA</a>
</li><li class="li-toc"><a href="#sec98">6.10 Approximation du nombre π </a>
<ul class="toc"><li class="li-toc">
<a href="#sec99">6.10.1 La méthode des polygones</a>
</li><li class="li-toc"><a href="#sec102">6.10.2 La série alternée de Leibniz</a>
</li><li class="li-toc"><a href="#sec103">6.10.3 La loi des grands nombres</a>
</li><li class="li-toc"><a href="#sec104">6.10.4 Le produit de Wallis</a>
</li><li class="li-toc"><a href="#sec105">6.10.5 L’intégrale ∫<sub>0</sub><sup>1</sup> 1/1+<span style="font-style:italic">x</span><sup>2</sup> <span style="font-style:italic">dx</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec106">6.11 Poésies</a>
</li><li class="li-toc"><a href="#sec107">6.12 L’irrationalité de √<span style="text-decoration:overline">2</span></a>
</li><li class="li-toc"><a href="#sec108">6.13 Démonstration non constructive</a>
</li><li class="li-toc"><a href="#sec109">6.14 L’hyperbole <span style="font-style:italic">xy</span>=1</a>
</li><li class="li-toc"><a href="#sec110">6.15 L’exponentielle</a>
</li><li class="li-toc"><a href="#sec111">6.16 Les fonctions sin1/<span style="font-style:italic">x</span> et <span style="font-style:italic">x</span> . sin1/<span style="font-style:italic">x</span> </a>
</li><li class="li-toc"><a href="#sec112">6.17 Srivanasa Ramanujan</a>
</li><li class="li-toc"><a href="#sec113">6.18 L’alphabet grec. Extraits du nouveau testament</a>
</li></ul>
</li></ul><!--TOC chapter id="sec2" Introduction-->
<h1 id="sec2" class="chapter">Introduction</h1><!--SEC END --><p><span style="font-style:italic">Aristote considérait les mathématiques comme une discipline, non pas tant de la vérité, que de la beauté.</span>
[<a href="#ab">2</a>]</p><p><span style="font-style:italic">What is mathematics ? Mathematics as an expression of the human mind reflects
the active will, the contemplative reason, and the desire for aesthetic perfection.</span> [<a href="#wm">16</a>]</p><p>C’est sous cet angle de l’esthétique que j’ai voulu ici modestement décrire quelques concepts 
des fondements mathématiques de l’informatique.</p><p><br>
</p><p>Qu’est-ce que le <span style="font-weight:bold">calcul</span> ? Il est difficile d’en donner une définition abstraite. Essayons cependant de 
décrire l’action de calculer, le processus du calcul. </p><p>Nous identifions deux processus bien distincts appelés la <span style="font-weight:bold">réduction</span> et la <span style="font-weight:bold">résolution</span>.
La réduction est l’action de réduire séquentiellement une expression en une autre expression plus simple
au moyen de règles de réécriture. Lorsque plus aucune règle ne s’applique, l’expression calculée est alors en forme
<span style="font-style:italic">normale</span>. Cette forme normale correspondra à la <span style="font-style:italic">valeur</span> de notre calcul.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(3+8)+(4−9)*2  ↝   11 −5*2   ↝  11 −10  ↝  1 </td></tr>
</table><p>Ce processus de réduction soulève deux difficultés essentielles : 
</p><ul class="itemize"><li class="li-itemize">
	La terminaison. Est-que le processus termine en un nombre fini d’étapes ?
	</li><li class="li-itemize">La confluence. Si le processus termine, est-que l’expression aboutit à une forme normale unique ?
</li></ul><p>

La fonction mathématique usuelle est peu adaptée à une étude du processus du calcul. Car elle
repose en fait sur une définition en <span style="font-style:italic">extension</span> : une fonction mathématique est la 
description d’une relation d’un ensemble de départ face à son ensemble d’arrivée.</p><p>Pour modéliser notre processus de calcul, il nous faut une définition en <span style="font-style:italic">intension</span>, 
c’est-à-dire avec des règles de calcul explicites. Fondé sur
cette idée, le λ-calcul a été créé par Alonzo Church dans les années 1930.
Il est maintenant utilisé comme socle de tout langage fonctionnel. 
Même s’il est rudimentaire et basé sur un mécanisme simple de réécriture,
nous verrons qu’il permet d’exprimer toutes les fonctions calculables. Sa <span style="font-style:italic">puissance</span>
de calcul est similaire aux machines de Turing ou aux fonctions µ-récursives de Gödel.
Nous l’étudierons en détails.</p><p>
L’autre processus de calcul est la résolution. Nous l’utilisons chaque fois que nous devons résoudre
une équation. En résolvant <span style="font-style:italic">x</span><sup>2</sup>+2<span style="font-style:italic">x</span>−15=0, nous souhaitons que notre processus 
soit <span style="font-style:italic">complet</span>, c’est-à-dire que nous calculions 
l’ensemble des valeurs possibles {−5; 3}.
Nous étudierons également ce mécanisme, et en particulier l’algorithme d’unification.</p>
<!--TOC chapter id="sec3" Le λ-calcul et la réduction-->
<h1 id="sec3" class="chapter">Chapitre ‍1 Le λ-calcul et la réduction</h1><!--SEC END -->
<!--TOC section id="sec4" Définition, champ lexical et syntaxique-->
<h2 id="sec4" class="section">1.1 Définition, champ lexical et syntaxique</h2><!--SEC END --><p>
Le λ-calcul est un système formel très rudimentaire. Il n’utilise que 
peu de moyens : le symbole λ, des variables et des parenthèses. Il n’a
qu’une seule règle de calcul, la β-réduction, qui modélise le passage d’un
argument à une fonction.</p><div class="theorem"><span style="font-weight:bold">Définition ‍1</span> <em>
Un </em>λ <em>-terme est défini par induction de la manière suivante:
</em><ul class="itemize"><li class="li-itemize"><em>
</em><em>Une variable </em><span style="font-style:italic">x</span><em> est un </em>λ<em>-terme.
</em></li><li class="li-itemize"><em>Une abstraction </em>λ <span style="font-style:italic">x</span>.<span style="font-style:italic">terme</span><em> est un </em>λ<em>-terme.
</em></li><li class="li-itemize"><em>Une application </em>(<span style="font-style:italic">terme</span>1  <span style="font-style:italic">terme</span>2)<em> est un </em>λ<em>-terme.
</em></li></ul><em>
</em></div><p>Exemple de lambda terme:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">( λ <span style="font-style:italic">x</span>. <span style="font-style:italic">xy</span> ) (<span style="font-style:italic">x</span> <span style="font-style:italic">z</span> <span style="font-style:italic">u</span>)  </td></tr>
</table><p>Voici le champ lexical des λ -termes:</p><p>
token = </p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >λ</td><td style="text-align:left;white-space:nowrap" >	 <code class="verb">LAMBDA</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >’.’</td><td style="text-align:left;white-space:nowrap" > <code class="verb">POINT</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >[ <span style="font-style:italic">a</span>−<span style="font-style:italic">z</span> ] [ <span style="font-style:italic">a</span>−<span style="font-style:italic">z</span>  0−9 ] *</td><td style="text-align:left;white-space:nowrap" > <code class="verb">VARIABLE</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >’(’	</td><td style="text-align:left;white-space:nowrap" >	 <code class="verb">PARLEFT</code>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >’)’	</td><td style="text-align:left;white-space:nowrap" >	 <code class="verb">PARRIGHT</code> 
</td></tr>
</table><p>Voici la grammaire des λ -termes, en utilisant les terminaux définis
avant :</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">terme</span> ::=</td><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><code class="verb">VARIABLE</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><code class="verb">PARLEFT</code>  <span style="font-style:italic">terme</span>  <span style="font-style:italic">terme</span>  <code class="verb">PARRIGHT</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" ><code class="verb">LAMBDA</code>  <code class="verb">VARIABLE</code>   .  <span style="font-style:italic">terme</span>
</td></tr>
</table><p>Nous utiliserons ocamllex et menhir, qui est la version moderne de ocamlyacc, pour l’analyse lexical et syntaxique des termes
du λ -calcul.</p>
<!--TOC subsection id="sec5" Analyse lexicale avec ocamllex-->
<h3 id="sec5" class="subsection">1.1.1 Analyse lexicale avec ocamllex</h3><!--SEC END --><p>
Nous définissons ici le champ lexical des différents <span style="font-style:italic">tokens</span> (<span style="font-style:italic">léxèmes</span>) du
λ-calcul.</p><pre class="verbatim">(* file: lambdalexical.mll *)
{
open Lambdagrammar (* Assumes the parser file is "lambdagrammar.mly" *)
}
let texte = ['a'-'z'] ['a'-'z' '0'-'9']*
rule token = parse
| "lambda" { LAMBDA }
| '.' { POINT }
| texte as varia { VARIABLE (varia) }
| '('  { PARLEFT }
| ')'  { PARRIGHT }
| _   { token lexbuf }
| eof  { raise End_of_file }
</pre><p>La compilation de ce fichier <code class="verb">.mll</code> va générer une fonction dont le nom
est celui de la règle (ici <code class="verb">token</code>).
Cette fonction prend comme argument le type <code class="verb">lexbuf</code> et rend le type <code class="verb">token</code>. </p><p><code class="verb">lexbuf</code> est un type de données abstrait défini dans le module Lexing 
qui permet de mémoriser la chaîne ou le fichier en cours d’analyse.
</p><pre class="verbatim">val token :  Lexing.lexbuf  -&gt; token 
</pre>
<!--TOC subsection id="sec6" Analyse syntaxique avec menhir-->
<h3 id="sec6" class="subsection">1.1.2 Analyse syntaxique avec menhir</h3><!--SEC END --><p>
Nous définissons ici la grammaire du λ-calcul.
Nous retrouvons les constructeurs du type ML associés à chacune des règles de la grammaire.
Ces constructeurs seront préenté dans la section qui suit.</p><pre class="verbatim">/* file: lambdagrammar.mly */
%{
open Terme
%}

%token &lt;string&gt; VARIABLE
%token LAMBDA PARLEFT PARRIGHT POINT
%token NEWLINE

%start exp
%type &lt;Terme.terme&gt; exp

%% /* Grammar rules and actions follow */
exp:      VARIABLE { Var($1) }
| PARLEFT exp exp PARRIGHT  { App($2, $3)}
| LAMBDA VARIABLE POINT exp  { Lam($2, $4) }
;
%%
</pre><p>Plus exactement, nous avons modifié cette grammaire <span style="font-style:italic">naïve</span> pour la
rendre non ambiguë et assurer l’associativité à gauche des
λ-applications.
En effet: 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">M</span> <span style="font-style:italic">N</span> <span style="font-style:italic">O</span> <span style="font-style:italic">P</span> = (((<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) <span style="font-style:italic">O</span>) <span style="font-style:italic">P</span>) </td></tr>
</table><pre class="verbatim">%% 
line:  exp NEWLINE { $1 }
;

exp: LAMBDA VARIABLE POINT exp  { Lam($2, $4) }
   | app {$1}
;

app:  atome {$1}
   | app atome { App($1, $2) }
;

atome: PARLEFT exp PARRIGHT {$2}
       | VARIABLE {Var($1)}
;  
%%
</pre><p>
Nous obtenons ainsi:
</p><pre class="verbatim">$ ./lambda.out
&gt;&gt; m n o p
App(App(App(Var "m" ,Var "n" ),Var "o" ),Var "p" )

&gt;&gt; lambda f . (lambda x . f(x x)) (lambda x. f(x x))
Lam("f",App(Lam("x",App(Var "f" ,App(Var "x" ,Var "x" ))),
    Lam("x",App(Var "f" ,App(Var "x" ,Var "x" )))))
</pre><p>La compilation de ce fichier <code class="verb">.mly</code> va générer une fonction dont le nom
est celui de l’axiome de notre grammaire (ici <code class="verb">exp</code>). Cette fonction prend deux arguments: la fonction de l’analyseur lexical qui génère les tokens et l’input. Elle rend le type
des expressions utilisées commes actions dans la grammaire.
</p><pre class="verbatim">val exp :   (Lexing.lexbuf  -&gt; token) -&gt; Lexing.lexbuf -&gt; Terme.terme
</pre><p>Si le langage analysé n’est pas reconnu par la grammaire, l’exception <code class="verb">Parse_error</code> est levée.
</p>
<!--TOC subsection id="sec7" Implémentation du parsing en mode <span style="font-style:italic">récursif descendant</span>-->
<h3 id="sec7" class="subsection">1.1.3 Implémentation du parsing en mode <span style="font-style:italic">récursif descendant</span></h3><!--SEC END --><p>Si nous voulons nous passer d’un outil tel que ocamlyacc ou menhir, nous pouvons très facilement implémenter un parser
de manière récursive en partant depuis la racine (l’axiome des règles de notre grammaire) et en appelant de manière récursive les
régles suivantes en fonction du caractère lu.</p><p>On modifiera légèrement la grammaire comme ci-dessous pour faciliter le travail.</p><p><br>

</p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">exprule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >| <code class="verb">VARIABLE</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >					</td><td style="text-align:left;white-space:nowrap" >	</td><td style="text-align:left;white-space:nowrap" >| <code class="verb">PARLEFT</code>   <span style="font-style:italic">parrule</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >					</td><td style="text-align:left;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >| <code class="verb">NEWLINE</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">parrule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >| <code class="verb">LAMBDA</code>  <span style="font-style:italic">lambdarule</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >					</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >| <span style="font-style:italic">apprule</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">lambdarule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><code class="verb">VARIABLE</code> <code class="verb">POINT</code> <span style="font-style:italic">exprule</span> <code class="verb">PARRIGHT</code> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">apprule</span></td><td style="text-align:left;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">exprule</span> <span style="font-style:italic">exprule</span> <code class="verb">PARRIGHT</code> </td></tr>
</table><p>
<br>
</p><p>Cela imposera cependant la saisie systématique des λ-termes avec des parenthèses autour des abstractions et des applications.
De même, nous n’aurons plus la facilité syntaxique de l’associativité à gauche des applications et de l’associativité à droite
du corps des abstractions.
Je ne sais pas si une telle grammaire peut être conçue pour une analyse en mode
récursif descendant.
Je pense que non (après m’être un peu cassé les cheveux là-dessus…)</p><p>Voici le code associé.
</p><pre class="verbatim">exception Fin
exception Erreur of string
 
let _ =
 let lexbuf = Lexing.from_channel stdin in
    
 let rec exprule courant =
  match courant with
  | VARIABLE(x) -&gt; Var(x)
  | PARLEFT -&gt; parrule (lexana lexbuf)
  | NEWLINE -&gt; raise Fin
  | _ -&gt;  raise (Erreur "exprule")
  
  and parrule courant =
     match courant with
    | LAMBDA -&gt; lambdarule courant
    | _ -&gt; apprule courant
   
  and apprule courant =
    let op1 = exprule courant in
      let op2 = exprule (lexana lexbuf) in
    let suivant = lexana lexbuf in (* consume PARRIGHT*)
    match suivant with 
     | PARRIGHT -&gt;  App(op1, op2) 
     | _ -&gt; raise (Erreur "apprule")
   
  and lambdarule courant =
     let var = lexana lexbuf in 
    let _ = lexana lexbuf in  (* consume POINT *)
    let corps = exprule(lexana lexbuf) in
    let _ =  lexana lexbuf (* consume PARRIGHT *) in
    match var with 
     | VARIABLE(x) -&gt; Lam(x, corps)
     | _ -&gt; raise (Erreur "lambdarule")
   
  in (betaNormalPrint (exprule (lexana lexbuf)); flush stdout)
</pre>
<!--TOC section id="sec8" Représentation en ML-->
<h2 id="sec8" class="section">1.2 Représentation en ML</h2><!--SEC END --><pre class="verbatim">type terme =
| Var of string
| App of terme * terme
| Lam of variable * terme
</pre><p>Un terme du λ -calcul est donc un type ML composé, avec les constructeurs <span style="font-style:italic">Var</span>, <span style="font-style:italic">App</span> et <span style="font-style:italic">Lam</span>.</p><p>Par exemple, le terme  λ <span style="font-style:italic">x</span>.(<span style="font-style:italic">x</span> <span style="font-style:italic">y</span>) <span style="font-style:italic">z</span>  est representé par la structure:</p><p><code class="verb">App ((Lam ("x", (App ((Var "x"), (Var "y"))))), (Var "z"))</code></p><p>C’est un peu verbeux.
Voici cependant sa représentation sous la forme d’un arbre syntaxique. Le symbole @ représente ici l’application.
</p><div class="center">
[level distance=1.5cm,
level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm, scale=0.7]
@
child  node λ 
		child  node x 
		child  node @
				child  node x 
				child  node y 
			 
	 
child  node z ;

</div><p>Pour dessiner cet arbre, nous utilisons le très bon package TIKZ qui permet facilement de représenter
les arbres avec une syntaxe très simple.
</p><pre class="verbatim">\node{@}
child { node {$\lambda $}
  child { node {x} }
  child { node {@}
    child { node {x} }
    child { node {y} }
     }
   }
child { node {z} };
</pre><p>On implémente deux fonctions CAML
qui permettent d’afficher une expression de type λ -terme en code L<sup>A</sup>T<sub>E</sub>X ou en code TIKZ.</p><p>La fonction <code class="verb">varLibres</code> retourne les variables libres (ie. non liées) d’un λ -terme.
</p><pre class="verbatim">let rec varLibres lambdaTerm =
 match lambdaTerm with
 | Var x -&gt; [ x ]
 | App (n, m) -&gt; union (varLibres n) (varLibres m)
 | Lam (x, m) -&gt; remove x (varLibres m)
</pre><p>Par exemple: (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">yxw</span>)(λ <span style="font-style:italic">u</span>.<span style="font-style:italic">uv</span>) ⊢→ <span style="font-style:italic">y</span>,<span style="font-style:italic">w</span>,<span style="font-style:italic">v</span> </p><pre class="verbatim">let exemple = App (Lam ("x", App (Var("y"), App (Var("x"),Var("w")))),
Lam ("u", App (Var ("u"), Var ("v")))) ;;
varLibres exemple ;;
- : variable list = ["y"; "w"; "v"]
</pre><div class="theorem"><span style="font-weight:bold">Définition ‍2</span> <em>
Un redex ou radical est un terme de la forme </em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span><em>
</em></div><p>
On a déjà distingué deux formes possible sur les λ-termes : les <span style="font-style:italic">abstractions</span> λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span> et les
<span style="font-style:italic">applications</span> (<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>). Un <span style="font-style:italic">redex</span> qui est de la forme (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span> est la
rencontre d’une abstraction et d’une application. Voici son implémentation.</p><p><br>

</p><div class="center">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >ML</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >SCHEME </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">(function x -&gt; M) N</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">((lambda (x) M) N)</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">let x = N in M</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">(let ((x N)) M)</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-family:monospace">M where x = N</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
</table>
</div><p>
La dernière syntaxe <span style="font-family:monospace">M where x = N</span> a disparu en OCAML. C’est dommage car elle est très élégante.
Nous essayerons de la reprendre pour notre interprète maison MiniML.</p><div class="theorem"><span style="font-weight:bold">Définition ‍3</span> <em>
La </em>β <em>-réduction est une opération de substitution. Elle consiste à substituer dans le redex
</em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>) <span style="font-style:italic">N</span><em> les occurrences libres de x dans M par l’argument N.
On la formalise par la notation suivante:
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>) <span style="font-style:italic">N</span>) → <sub>β</sub><span style="font-style:italic">M</span>[<span style="font-style:italic">x</span> ← <span style="font-style:italic">N</span>]
</td></tr>
</table><em>
</em></div><p>Nous pouvons la décrire par les quatre règles d’inférence ci-dessous:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold">(</span><span style="font-weight:bold"><span style="font-style:italic">redex</span></span><span style="font-weight:bold">)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span>) → <span style="font-style:italic">M</span>[<span style="font-style:italic">x</span> ← <span style="font-style:italic">N</span>]</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold">(</span><span style="font-weight:bold"><span style="font-style:italic">abstraction</span></span><span style="font-weight:bold">)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"> λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span> → (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span><sub>1</sub>)</td></tr>
</table></td><td class="dcell">
  <span style="font-weight:bold">(1)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span><sub>1</sub> <span style="font-style:italic">N</span>)</td></tr>
</table></td><td class="dcell">
  <span style="font-weight:bold">(2)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span> → <span style="font-style:italic">N</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span> <span style="font-style:italic">N</span><sub>1</sub>)</td></tr>
</table></td></tr>
</table><p><br>

Pour l’implémentation, nous nous sommes appuyés sur le code de l’excellent livre <span style="font-style:italic">Programmer avec Scheme</span> 
de Jacques Chazarain [<a href="#plisp">4</a>]. 
Nous avons adapté son code SCHEME en OCAML. En comparant les deux versions, on s’aperçoit finalement
que la version OCAML, même si un peu plus concise que la version SCHEME grâce l’utilisation du <span style="font-style:italic">pattern matching</span>,
reste très proche de l’original SCHEME.</p><p><br>

La fonction <span style="font-family:monospace">substituer</span> permet de substituer la variable <span style="font-family:monospace">var</span> par le terme <span style="font-family:monospace">terme</span> dans l’expression <span style="font-family:monospace">exp</span>.</p><pre class="verbatim">let rec substituer exp var terme =
 match exp with
 | Var x -&gt; if x = var then terme else exp
 | App (n, m) -&gt; App ((substituer n var terme), (substituer m var terme))
 | Lam (x, m) -&gt; (* pas d'occurence libre on en fait rien *)
   if not (mem var (varLibres exp))
   then exp
   else (* si capture on renome *)
   if mem x (varLibres terme)
   then
    (let newV = renomme x (varLibres terme) in
     let newCorps = substituer m x (Var newV)
     in Lam (newV, (substituer newCorps var terme)))
   else  Lam (x, (substituer m var terme))
</pre><p>Avant de substituer une variable par une autre, nous devons nous assurer qu’il n’y aura pas de phénomène de capture, ie.
nous assurer qu’une variable libre ne deviendra pas liée, après substitution.
Dans l’exemple suivant, la variable x qui était libre dans  (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)  se retrouve capturée par λ
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">λ <span style="font-style:italic">x</span>. (<span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)[<span style="font-style:italic">y</span> ← (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)] = λ <span style="font-style:italic">x</span>.(<span style="font-style:italic">x</span> (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)) </td></tr>
</table><p>
Pour éviter cela, il faut avant substitution opérer un renommage de la variable liée:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">λ <span style="font-style:italic">x</span><sub>1</sub>. (<span style="font-style:italic">x</span><sub>1</sub> <span style="font-style:italic">y</span>)[<span style="font-style:italic">y</span> ← (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)] = λ <span style="font-style:italic">x</span><sub>1</sub>.(<span style="font-style:italic">x</span><sub>1</sub> (<span style="font-style:italic">z</span> <span style="font-style:italic">x</span>)) </td></tr>
</table><p>
Ce renommage est appelé α-conversion. On dit que deux termes <span style="font-style:italic">M</span> et <span style="font-style:italic">N</span> sont équivalents modulo α.
On écrira <span style="font-style:italic">M</span>=<sub>α</sub><span style="font-style:italic">N</span></p><pre class="verbatim">(** renommer var *)
let renomme var listeVar =
 let rec renommeAux j =
  let varj = var ^ (string_of_int j)
  in if mem varj listeVar then renommeAux (j + 1) else varj
 in renommeAux 0
</pre><p>La fonction <span style="font-family:monospace">reduc1Normale</span> réduit le terme en appliquant la stratégie de réduction normale, c’est-à-dire
en commencant la réduction par le redex extèrieur, plus précisément le plus à gauche des extèrieurs.</p><pre class="verbatim">let rec reduc1Normale terme =
   match terme with
   | Var x -&gt; raise IRREDUCTIBLE 
   | Lam (x, m) -&gt; Lam (x, (reduc1Normale m))
   | App (n, m) -&gt;
  if estRedex terme
  then betaReducRedex terme
  else
   try App ((reduc1Normale n), m)
   with IRREDUCTIBLE   -&gt; App (n, (reduc1Normale m)) 
</pre><p>Enfin, nous avons une fonction <code class="verb">fullReduc</code> qui permet d’itérer l’opération de
β-réduction jusqu’à trouver la forme normale, ou boucler s’il n’y a pas de forme formale.
On lui impose donc maximum 1000 réductions <sup><a id="text1" href="#note1">1</a></sup>
Elle prend en argument la méthode (ie. la stratégie de réduction) à  utiliser. </p><pre class="verbatim">let rec fullReduc terme methode  =
  let rec loop terme  iter =
 try
  let newterme = methode terme in
  if (newterme = terme || iter = 0) then newterme
  else loop newterme (iter - 1)
 with IRREDUCTIBLE -&gt; terme 
  in loop terme 1000
 
let betaNormal t = fullReduc t reduc1Normale
</pre><div class="theorem"><span style="font-weight:bold">Théorème ‍1</span> <em>
La réduction normale appliquée à un terme normalisable aboutit toujours à la forme irréductible du terme.
</em></div><p>Nous avons en plus le théorème suivant (plus précisément son corollaire) qui nous assure que toutes les réductions d’un λ-terme (qui terminent) aboutissent au même
terme irréductible.</p><div class="theorem"><span style="font-weight:bold">Théorème ‍2</span> <em>
Théorème de Church-Rosser : la </em>β <em>-réduction est confluente.
</em></div><p>

	[-latex] (1,1) node[above]<span style="font-style:italic">M</span> –node* (0,0) node[left]<span style="font-style:italic">M</span><sub>1</sub> ;
	[-latex] (1,1) –node* (2,0) node[right]<span style="font-style:italic">M</span><sub>2</sub>;
	[-latex, dotted] (0,0) –node* (1,-1) node[below] <span style="font-style:italic">M</span>′;
	[-latex, dotted] (2,0) –node* (1,-1) ; 
	[text width = 9cm] at(8,0) si <span style="font-style:italic">M</span> *—→<sub>β</sub> <span style="font-style:italic">M</span><sub>1</sub> et <span style="font-style:italic">M</span> *—→<sub>β</sub> <span style="font-style:italic">M</span><sub>2</sub> alors 
	∃  <span style="font-style:italic">M</span>′ tel que <span style="font-style:italic">M</span><sub>1</sub> *—→<sub>β</sub> <span style="font-style:italic">M</span>′ et <span style="font-style:italic">M</span><sub>2</sub> *—→<sub>β</sub> <span style="font-style:italic">M</span>′ ;
</p><div class="theorem"><span style="font-weight:bold">Théorème ‍3</span> <em>
	Corollaire du théorème de Church-Rosser <br>
	Si </em><span style="font-style:italic">M</span><em> est normalisable, il existe un unique terme normal, noté </em><span style="text-decoration:overline"><span style="font-style:italic">M</span></span><em> tel 
	que </em><span style="font-style:italic">M</span> *—→<sub>β</sub> <span style="text-decoration:overline"><span style="font-style:italic">M</span></span><em>
</em></div><p>
Un corollaire ne devrait pas nécessiter de preuve car supposée évidente. La voici cependant:</p><p>
	[-latex] (1,1) node[above]<span style="font-style:italic">M</span> –node* (0,0) node[left]<span style="font-style:italic">M</span><sub>1</sub> ;
	[-latex] (1,1) –node* (2,0) node[right]<span style="font-style:italic">M</span><sub>2</sub>;
	[-latex, dotted] (0,0) –node* node[below left, sloped, midway]= (1,-1) node[below] <span style="font-style:italic">M</span>3;
	at(1,0) = ; 
	[-latex, dotted] (2,0) –node* node[below right, sloped, midway]= (1,-1) ; 
	[text width = 12cm] at(10,0)	 Si <span style="font-style:italic">M</span> est normalisable, alors il existe <span style="font-style:italic">M</span><sub>1</sub> normal
	tel que <span style="font-style:italic">M</span> *—→<sub>β</sub> <span style="font-style:italic">M</span><sub>1</sub> ; si <span style="font-style:italic">M</span> *—→<sub>β</sub> <span style="font-style:italic">M</span><sub>2</sub> avec
	<span style="font-style:italic">M</span><sub>2</sub> normal, alors par confluence il existe <span style="font-style:italic">M</span><sub>3</sub> tel que <span style="font-style:italic">M</span>1 *—→<sub>β</sub> <span style="font-style:italic">M</span><sub>3</sub> et <span style="font-style:italic">M</span>2 *—→<sub>β</sub> <span style="font-style:italic">M</span><sub>3</sub>.
	Or <span style="font-style:italic">M</span><sub>1</sub> et <span style="font-style:italic">M</span><sub>2</sub> sont normaux donc <span style="font-style:italic">M</span><sub>1</sub>=<span style="font-style:italic">M</span><sub>3</sub> et <span style="font-style:italic">M</span><sub>2</sub>=<span style="font-style:italic">M</span><sub>3</sub> donc <span style="font-style:italic">M</span><sub>1</sub> = <span style="font-style:italic">M</span><sub>2</sub> .	
	 	 ;
</p><p>		 </p><pre class="verbatim">let t1 = App (Lam ("x",App (Lam ("y", App (Var ("x"), Var ("y"))),Var ("u"))), Var ("z")) ;;
# fullReduc t1 ;;
--&gt; ((lambda x . ((lambda y . (xy))u))z)
--&gt; ((lambda y . (zy))u)
--&gt; (zu)
- : unit -&gt; unit = &lt;fun&gt;
</pre><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">y</span> . <span style="font-style:italic">xy</span>)<span style="font-style:italic">u</span>)<span style="font-style:italic">z</span>   → <sub>β</sub>(λ <span style="font-style:italic">y</span> . <span style="font-style:italic">zy</span>) <span style="font-style:italic">u</span>  → <sub>β</sub>(<span style="font-style:italic">zu</span>)
</td></tr>
</table><div class="center">
<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">y</span> . <span style="font-style:italic">xy</span>)<span style="font-style:italic">u</span>)<span style="font-style:italic">z</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(λ <span style="font-style:italic">y</span> . <span style="font-style:italic">zy</span>)<span style="font-style:italic">u</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<span style="font-style:italic">zu</span>) </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >
[level distance=1.5cm,
level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm, scale=0.6]
@ child  node λ child  nodex  child node @ child  node λ child  nodey 
child node @ child  node x  child node y    child node u    child node z  ;

</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >
[level distance=1.5cm,
level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm, scale=0.6]
@ child  node λ child  nodey 
child node @ child  node z  child node y   
child node u  ;

</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >
[level distance=1.5cm,
level 1/.style=sibling distance=3cm, scale=0.6 ]
@ child  node z 
child  nodeu  ;


</td></tr>
</table>
</div><p><br>
<br>

Voici un exemple de terme qui ne termine pas et qui enfle.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>) → <sub>β</sub>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)
→ <sub>β</sub>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>)(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xxx</span>) → <sub>β</sub>…
</td></tr>
</table>
<!--TOC section id="sec9" La β-réduction faible avec appel par valeur-->
<h2 id="sec9" class="section">1.3 La β-réduction faible avec appel par valeur</h2><!--SEC END --><p>
Dans un langage fonctionnel comme SCHEME ou ML, il est important de noter que contrairement au λ-calcul, le corps de la lambda n’est pas évalué. 
On parle de β-réduction faible. 
Autrement dit, la règle suivante n’est pas utilisée:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-weight:bold">(</span><span style="font-weight:bold"><span style="font-style:italic">abstraction</span></span><span style="font-weight:bold">)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"> λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span> → (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span><sub>1</sub>)</td></tr>
</table></td></tr>
</table><p>
Nous pourrons utiliser cette absence d’évaluation du corps 
des lambda expressions pour geler l’évaluation de nos expressions : <code class="verb">(delay exp) = (lambda () exp)</code> </p><p>L’appel par valeur signifie que les arguments sont évalué en premier. Les règles d’inférence appliquées sont donc dans cet ordre:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">  <span style="font-weight:bold">(1)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">N</span> → <span style="font-style:italic">N</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span> <span style="font-style:italic">N</span><sub>1</sub>)</td></tr>
</table></td><td class="dcell">
  <span style="font-weight:bold">(2)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">M</span> → <span style="font-style:italic">M</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">(<span style="font-style:italic">M</span> <span style="font-style:italic">N</span>) → (<span style="font-style:italic">M</span><sub>1</sub> <span style="font-style:italic">N</span>)</td></tr>
</table></td><td class="dcell">
  <span style="font-weight:bold">(3)</span> : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<span style="font-style:italic">N</span>) → <span style="font-style:italic">M</span>[<span style="font-style:italic">x</span> ← <span style="font-style:italic">N</span>]</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>Voici la fonction ML qui implémente cet ordre:
</p><pre class="verbatim">let rec reduc1Valeur terme =
  match terme with
  | Var x -&gt; raise IRREDUCTIBLE
  | Lam (x, m) -&gt; raise IRREDUCTIBLE
  | App (n, m) -&gt;
      (try App (n, (reduc1Valeur m))
       with
       | IRREDUCTIBLE -&gt;
           (try App ((reduc1Valeur n), m)
            with
            | IRREDUCTIBLE -&gt;
                (try betaReducRedex terme
                 with | NOTREDEX -&gt; raise IRREDUCTIBLE)))
</pre><p>Par exemple, nous aurons les réductions successives suivantes: </p><ul class="itemize"><li class="li-itemize">
réduction normale, qui aboutit toujours à la forme irréductibre
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>) ((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>)) →<sub>β</sub><span style="font-style:italic">y</span> </td></tr>
</table> </li><li class="li-itemize">réduction par valeur 
<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>))</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>))</td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>)) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">y</span>)((λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>) (λ <span style="font-style:italic">x</span>.<span style="font-style:italic">xx</span>))) </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >→<sub>β</sub></td><td style="text-align:center;white-space:nowrap" >… </td></tr>
</table></td></tr>
</table>
</li></ul>
<!--TOC section id="sec10" La récursivité et le point fixe-->
<h2 id="sec10" class="section">1.4 La récursivité et le point fixe</h2><!--SEC END --><p>What else is a loop but a way of representing an endless process in a finite way?
[<a href="#god">8</a>]</p><div class="center">
<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >	<span class="parbox" style="vertical-align:middle;width:30%"><img src="document001.png"></span></td><td style="text-align:center;white-space:nowrap" >  
√<span style="text-decoration:overline">2</span> = 1 + 1/1+√<span style="text-decoration:overline">2</span>  </td></tr>
</table>
</div><p>En analyse, le point fixe d’une fonction <span style="font-style:italic">f</span> est sa valeur <span style="font-style:italic">x</span> telle que <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)=<span style="font-style:italic">x</span></p><p>Cela permet de définir <span style="font-style:italic">x</span> en fonction de lui-même.</p><p>Cette simple expression <span style="font-style:italic">x</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) est finalement très étrange et déroutante.
C’est la force de la récursivité : <span style="font-style:italic">x</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>… (<span style="font-style:italic">x</span>)…))))))</p><p>Un exemple est la valeur √<span style="text-decoration:overline">2</span> exprimée sous forme d’une fraction continue,
expression trouvée je crois par Euler.
Je la décris ci-dessous pour le plaisir d’écrire (et lire) de belles formules mathématiques en L<sup>A</sup>T<sub>E</sub>X[<a href="#lamport1994latex">12</a>]
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> = 1+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> −1
= 1+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> −1)(</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> +1)</td></tr>
</table></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> +1</td></tr>
</table></td></tr>
</table></td><td class="dcell">
= 1 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
	[-&gt;] (-1, 0) – (3, 0) node[right] <span style="font-style:italic">x</span>;
	[-&gt;] (0, -1) – (0, 3) node[above] <span style="font-style:italic">y</span>;
	[domain=-0.5:3, smooth, variable=, blue] plot (, 1 + 1 / (1+ ) ) node [right] <span style="font-style:italic">y</span>=1 + 1/1+<span style="font-style:italic">x</span> ;
	[domain=-1:3, smooth, variable=, red] plot (, ) node [right] <span style="font-style:italic">y</span>=<span style="font-style:italic">x</span>;
	[dotted] (1.4142,0) node[below]√<span style="text-decoration:overline">2</span> –(1.4142,1.4142) ;
	[dotted] (0,1.4142) node[left] √<span style="text-decoration:overline">2</span> –(1.4142,1.4142) ;
	
	[draw,text width=6cm] at(10,1.5) </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">		</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> = 1 + </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
		+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
		+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
		+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
		+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" > ⋱
		</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>  ;
 </p><p>En posant  <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) = 1 + 1/1+<span style="font-style:italic">x</span> , la résolution de l’équation <span style="font-style:italic">x</span>=<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) nous permet
de calculer la valeur de √<span style="text-decoration:overline">2</span>. Nous utilisons aussi le fait que √<span style="text-decoration:overline">2</span> est 
un point fixe attractif de notre fonction <span style="font-style:italic">f</span>. C’est-à-dire qu’il existe un <span style="font-style:italic">voisinage</span> de 
√<span style="text-decoration:overline">2</span> tel que la suite  <span style="font-style:italic">x</span><sub>0</sub>,<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>),<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>)),<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span><sub>0</sub>))),…  converge vers √<span style="text-decoration:overline">2</span></p><p>En CAML, la fonction qui itère cette fraction continue peut être codée comme suit. 
Nous partons ici de <span style="font-style:italic">x</span><sub>0</sub> =1. La fraction continue converge très rapidement.
</p><pre class="verbatim">let rec square2 iter =
 if (iter = 1) then 1.
 else  1. +. ( 1. /. ( 1. +. square2 (iter - 1)));;
val square2 : int -&gt; float = &lt;fun&gt;

# square2 30 ;;
- : float = 1.4142135623730951

# sqrt 2. ;;
- : float = 1.41421356237309512.

</pre><p>En λ -calcul, nous avons un combinateur<sup><a id="text2" href="#note2">2</a></sup> qui nous permet de calculer le point fixe de n’importe quel λ -terme.
Ce combinateur s’appelle <span style="font-style:italic">Y</span> . Il est défini par </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Y</span>=  λ <span style="font-style:italic">f</span>.(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>))(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>)) </td></tr>
</table><p>Ce n’est pas le seul combinateur de point fixe. Voici un autre dû à Turing :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Θ = (λ <span style="font-style:italic">x</span>. λ <span style="font-style:italic">y</span>. (<span style="font-style:italic">y</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>))) (λ <span style="font-style:italic">x</span>. λ <span style="font-style:italic">y</span>. (<span style="font-style:italic">y</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)))</td></tr>
</table><p>Voici l’arbre syntaxique de <span style="font-style:italic">Y</span>:
</p><div class="center">
[level distance=1.5cm,
level 1/.style=sibling distance=5cm,
level 2/.style=sibling distance=3cm,
level 3/.style=sibling distance=1.5cm,
level 4/.style=sibling distance=1.5cm, scale=0.6]
λ child  nodef  child node @ child  node λ child
 nodex  child node @ child  node f  child node @ child  node x 
child node x     child node λ child  nodex  child
node @ child  node f  child node @ child  node x  child node x      ;

</div><p>
Quel que soit le terme <span style="font-style:italic">M</span>, nous aurons (<span style="font-style:italic">YM</span>) = <sub>β</sub><span style="font-style:italic">M</span>(<span style="font-style:italic">YM</span>)</p><p>Essayons ceci avec notre notre fonction <code class="verb">fullReduc</code> en CAML.
Réduisons <span style="font-style:italic">YM</span> :</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>))) (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span> (<span style="font-style:italic">x</span> <span style="font-style:italic">x</span>))) <span style="font-style:italic">M</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span> (<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">M</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>))))  ▷ [2] </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">MM</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">MMM</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>(<span style="font-style:italic">MMMM</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">M</span>(<span style="font-style:italic">xx</span>)))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub>…
</td></tr>
</table></td></tr>
</table><p>La deuxième β-réduction est bien égale à <span style="font-style:italic">M</span> (<span style="font-style:italic">Y</span> <span style="font-style:italic">M</span>)
Nous voyons ici le mécanisme d’appel récursif à M. </p><p>Détaillons cela avec une fonction exprimée en pseudo-code d’un λ-calcul étendu.
Nous nous inspirons pour cela du très bon article de wikipedia <span style="font-family:monospace">https://en.wikipedia.org/wiki/Lambda_calculus</span>.</p><p>Soit <span style="font-style:italic">M</span> = (λ <span style="font-style:italic">f</span> λ <span style="font-style:italic">n</span> .(<span style="font-style:italic">if</span> <span style="font-style:italic">n</span>=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> <span style="font-style:italic">n</span>*<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>−1)))
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">YM</span>) 4</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">M</span> (<span style="font-style:italic">YM</span>) 4 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">f</span> λ <span style="font-style:italic">n</span> .(<span style="font-style:italic">if</span> <span style="font-style:italic">n</span>=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> <span style="font-style:italic">n</span>*<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>−1))) (<span style="font-style:italic">YM</span>) 4 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ  <span style="font-style:italic">n</span> . (<span style="font-style:italic">if</span> <span style="font-style:italic">n</span>=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> <span style="font-style:italic">n</span>*((<span style="font-style:italic">YM</span>) (<span style="font-style:italic">n</span>−1)))) 4 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">if</span> 4=0 <span style="font-style:italic">then</span> 1 <span style="font-style:italic">else</span> 4*((<span style="font-style:italic">YM</span>) (4−1))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >4 * ((<span style="font-style:italic">YM</span>) 3) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >4 * (<span style="font-style:italic">M</span>(<span style="font-style:italic">YM</span>) 3) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >⋮</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >4 * 3 * 2 * 1 
</td></tr>
</table></td></tr>
</table><p>Ici encore, nous avons utilisé la stratégie de β-réduction normale. 
Mais avec une réduction par valeur, le terme en argument (<span style="font-style:italic">YM</span>) aura été réduit indéfiniment en <span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>(<span style="font-style:italic">M</span>… <span style="font-style:italic">YM</span>)…))),
sans réduire le redex <span style="font-style:italic">Mx</span></p><p>En utilisant notre programme OCAML, voyons cela avec en prenant <span style="font-style:italic">M</span> = λ <span style="font-style:italic">a</span>. (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)  :</p><p><code class="verb"># betaNormal ym ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">f</span> . (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>)))λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" > → <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))</td><td style="text-align:left;white-space:nowrap" >▷ [2]  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > → <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))))</td><td style="text-align:left;white-space:nowrap" >▷ [3]  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > → <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span></td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p><code class="verb"># betaValeur ym ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">f</span> . (λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">xx</span>)))λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))</td><td style="text-align:left;white-space:nowrap" >▷ [2]  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))))</td><td style="text-align:left;white-space:nowrap" >▷ [3] </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))))</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))))))</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>))λ <span style="font-style:italic">x</span> . (λ <span style="font-style:italic">a</span> . λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>(<span style="font-style:italic">xx</span>)))))))</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>
Les étapes ▷ [2] et ▷ [3] sont bien les mêmes sur les deux stratégies. 
Puis la β-réduction par valeur va continuer à réduire l’argument
(<span style="font-style:italic">YM</span>), là où la β-réduction normale va d’abord réduire le redex <span style="font-style:italic">Mx</span></p><p>Avec la réduction par valeur, il nous faut donc utiliser un autre combinateur de point fixe<sup><a id="text3" href="#note3">3</a></sup>
que nous appelerons <span style="font-style:italic">Z</span> 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">Z</span> = λ <span style="font-style:italic">f</span>.(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span>.<span style="font-style:italic">xxv</span>))(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span>.<span style="font-style:italic">xxv</span>)) </td></tr>
</table><p>On constate que Z est η-équivalent à <span style="font-style:italic">Y</span>. Nous rappelons la définition suivante:</p><div class="theorem"><span style="font-weight:bold">Définition ‍4</span> <em>
	
Les termes </em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">Mx</span>)<em> et M sont </em>η<em>-équivalents. On écrira </em>(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">Mx</span>) =<sub>η</sub><span style="font-style:italic">M</span><p><em>En ML, nous pouvons par exemple dire que </em><code class="verb"><em> let g x = f x</em></code><em> est </em>η<em>-équivalent à </em><code class="verb"><em> let g = f</em></code><em>
</em></p></div><p>Appliquons à nouveau notre exemple avec ce combinateur <span style="font-style:italic">Z</span> appliqué à <span style="font-style:italic">M</span>=λ <span style="font-style:italic">a</span>. λ <span style="font-style:italic">b</span>. <span style="font-style:italic">b</span>:</p><p><code class="verb"># betaValeur zm ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >((λ <span style="font-style:italic">f</span> . ((λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))))(λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >((λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))(λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . (((λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>))))(λ <span style="font-style:italic">x</span> . ((λ <span style="font-style:italic">a</span> . (λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>))(λ <span style="font-style:italic">v</span> . ((<span style="font-style:italic">xx</span>)<span style="font-style:italic">v</span>)))))<span style="font-style:italic">v</span>))) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">b</span> . <span style="font-style:italic">b</span>)
</td></tr>
</table></td></tr>
</table><p>Nous avons le même réultat et les même étapes de réduction avec <code class="verb">betaNormal zm ;;</code></p><p>En SCHEME, nous pourrons implémenter ce combinateur <span style="font-style:italic">Z</span> :
</p><pre class="verbatim">(define Z
 (lambda(f)
   (lambda (x) (lambda(v) ((f (x x) v))))
   (lambda (x) (lambda(v) ((f (x x) v))))))
</pre><p>En ML, le typage ne nous permettra pas de coder un combinateur comme <span style="font-style:italic">Y</span> ou <span style="font-style:italic">Z</span>.</p><p>Essayons cependant d’écrire:</p><pre class="verbatim">
# let rec fix f = f (fix f) ;;
val fix : ('a -&gt; 'a) -&gt; 'a = &lt;fun&gt;

let factabs fact = function
  | 0 -&gt; 1
  | n -&gt; n * fact (n - 1) ;;

val factabs : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;
# (fix factabs) 5 ;;
Stack overflow during evaluation (looping recursion?).
</pre><p>
ML est bien un langage <span style="font-style:italic">strict</span>: les arguments d’une fonction sont évalués en premier 
comme on l’a vu dans la β-réduction faible avec appel par valeur.</p><p>Pour éviter la boucle infinie <span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>…(<span style="font-style:italic">f</span> (<span style="font-style:italic">fix</span> <span style="font-style:italic">f</span>))…), 
une astuce que j’ai pu lire est d’introduire une variable supplémentaire:</p><pre class="verbatim"># let rec fix f x = f (fix f) x ;;
val fix : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;
# (fix factabs) 5 ;;
- : int = 120
</pre><p>
Ici aussi, le mécanisme de la “η-expansion” est utilisé.
Je suis surpris cependant de voir que <code class="verb">fix</code> prenant deux arguments est correctement évalué lors de son appel <code class="verb">(fix f)</code>.
Je ne peux reproduire cela en SCHEME:</p><pre class="verbatim">(define factabs
  (lambda (f)
    (lambda (n)
      (if (eq? n 0)
          1
          (* n (f (- n 1)))))))

(define y
  (lambda (f x)
    (f (y f) x)))

(y factabs 5)
=&gt; y: arity mismatch; the expected number of arguments does not match 
  expected: 2
  given: 1
</pre>
<!--TOC section id="sec11" <span style="font-style:italic">Church</span> encoding. Les entiers et les booléens en λ-calcul-->
<h2 id="sec11" class="section">1.5 <span style="font-style:italic">Church</span> encoding. Les entiers et les booléens en λ-calcul</h2><!--SEC END -->
<!--TOC subsection id="sec12" Les entiers <span style="font-style:italic">Church</span> -->
<h3 id="sec12" class="subsection">1.5.1 Les entiers <span style="font-style:italic">Church</span> </h3><!--SEC END --><p>
Les entiers peuvent être représenté de la manière suivante:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >0 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >1 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> <span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >2 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> (<span style="font-style:italic">f</span> <span style="font-style:italic">x</span>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >3 ≡ λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> (<span style="font-style:italic">f</span> (<span style="font-style:italic">f</span> <span style="font-style:italic">x</span>)) 
</td></tr>
</table></td></tr>
</table><p>La fonction successeur se définira <span style="font-style:italic">SUCC</span> ≡ λ <span style="font-style:italic">n</span>.λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">f</span> (<span style="font-style:italic">n</span> <span style="font-style:italic">f</span> <span style="font-style:italic">x</span>)
Avec notre représentation ML: </p><p><code class="verb">Lam("n", Lam("f", Lam("x",App(Var "f", App(App(Var "n", Var "f"), Var "x")))))</code></p><p>Exécutons avec la stratégie normale, puis avec la stratégie de réduction faible par valeur:</p><p><code class="verb"># betaNormalPrint (App(succ, un)) ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">fx</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Exception</span>: <span style="font-style:italic">IRREDUCTIBLE</span>.
</td></tr>
</table></td></tr>
</table><p><code class="verb"># betaValeurPrint (App(succ, un)) ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">fx</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Exception</span>: <span style="font-style:italic">IRREDUCTIBLE</span>.
</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table><p>
Nous n’aboutissons pas au terme λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">fx</span>))  avec la stratégie par valeur. Nous voyons que le corps de la lambda
n’est pas évalué. Je suis cependant surpris car je pensais cette stratégie (même si appelée <span style="font-style:italic">faible</span>) parvenait à calculer la
forme normale.</p><p>Nous pouvons écrire en OCAML la fonction qui convertit des entiers vers les terms <span style="font-style:italic">Church</span>:
</p><pre class="verbatim">
let rec int2Church = function
 | 0 -&gt; Lam("f", Lam("x", Var "x"))
 | n -&gt; App(succ, int2Church (n-1))
</pre><p><code class="verb"># betaNormal (int2Church 3) ;;</code>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))(λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>))<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">x</span>))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(((λ <span style="font-style:italic">n</span> . λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((<span style="font-style:italic">nf</span>)<span style="font-style:italic">x</span>))λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span>)<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xf</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">f</span>)<span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xf</span>)<span style="font-style:italic">x</span>))<span style="font-style:italic">x</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>((λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xf</span>)<span style="font-style:italic">x</span>))))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(λ <span style="font-style:italic">x</span> . <span style="font-style:italic">xx</span>))))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >→ <sub>β</sub></td><td style="text-align:left;white-space:nowrap" >λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> . (<span style="font-style:italic">f</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">fx</span>)))   </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">Exception</span>: <span style="font-style:italic">IRREDUCTIBLE</span>. 
</td></tr>
</table></td></tr>
</table><p>L’addition peut être exprimée par le combinateur λ <span style="font-style:italic">m</span> .λ <span style="font-style:italic">n</span> .λ <span style="font-style:italic">f</span>. λ <span style="font-style:italic">x</span>. <span style="font-style:italic">m</span> <span style="font-style:italic">f</span> (<span style="font-style:italic">n</span> <span style="font-style:italic">f</span> <span style="font-style:italic">x</span>) <span style="font-style:italic">x</span> </p><p>La multiplication peut être exprimée par le combinateur λ <span style="font-style:italic">m</span> .λ <span style="font-style:italic">n</span> .λ <span style="font-style:italic">f</span>. λ <span style="font-style:italic">x</span>. <span style="font-style:italic">m</span> (<span style="font-style:italic">n</span> <span style="font-style:italic">f</span>) <span style="font-style:italic">x</span>  </p><p>Le prédecesseur peut être exprimé par le combinateur λ <span style="font-style:italic">n</span>.λ <span style="font-style:italic">f</span>.λ <span style="font-style:italic">x</span>.<span style="font-style:italic">n</span> (λ <span style="font-style:italic">g</span>.λ <span style="font-style:italic">h</span>.<span style="font-style:italic">h</span> (<span style="font-style:italic">g</span> <span style="font-style:italic">f</span>)) (λ <span style="font-style:italic">u</span>.<span style="font-style:italic">x</span>) (λ <span style="font-style:italic">u</span>.<span style="font-style:italic">u</span>)  </p><p>Après avoir défini les termes <code class="verb">succ</code> et <code class="verb">pred</code>, nous pouvons écrire les deux fonctions suivantes qui “jonglent”
entre les entiers ML et les entiers Church.
</p><pre class="verbatim">let int2Church n = 
 let rec aux = function
 | 0 -&gt; Lam("f", Lam("x", Var "x"))
 | n -&gt; App(succ, aux (n-1))
 in betaNormal (aux n)

let rec church2Int  terme = 
 match terme with
 | Lam("f", Lam("x", Var "x")) -&gt; 0
 | _ -&gt; 1 + church2Int (betaNormal(App(pred, terme)))

# church2Int (int2Church 10);;
- : int = 10
</pre><p>Egalement, nous pouvons représenter directement en ML les entiers <span style="font-style:italic">Church</span> sous forme de fonctionnelles:
</p><pre class="verbatim">let zero f x = x
let un f x = f x
let deux f x = f (f x)

let succ n f x = f (n f x)
let add n m f x = n f (m f x)

let to_int n = n (function k -&gt; k + 1) 0
let rec to_church = function | 0 -&gt; zero  | n -&gt; succ (to_church (n-1))
 
#to_int (add deux (succ (to_church 5))) ;;
- : int = 8 
</pre>
<!--TOC subsection id="sec13" Les booléens -->
<h3 id="sec13" class="subsection">1.5.2 Les booléens </h3><!--SEC END --><p>
Nous pourrons les représenter de la façon suivante. On y ajoute le prédicat IsZero.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >true</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">a</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >false</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">b</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >and</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.λ <span style="font-style:italic">q</span>.<span style="font-style:italic">p</span> <span style="font-style:italic">q</span> <span style="font-style:italic">p</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >or</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.λ <span style="font-style:italic">q</span>.<span style="font-style:italic">p</span> <span style="font-style:italic">p</span> <span style="font-style:italic">q</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >not</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.<span style="font-style:italic">p</span> (λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">b</span>) (λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">a</span>)=λ <span style="font-style:italic">p</span>.<span style="font-style:italic">p</span>false true </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >if</td><td style="text-align:left;white-space:nowrap" >≡ λ <span style="font-style:italic">p</span>.λ <span style="font-style:italic">a</span>.λ <span style="font-style:italic">b</span>.<span style="font-style:italic">p</span> <span style="font-style:italic">a</span> <span style="font-style:italic">b</span>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >IsZero</td><td style="text-align:left;white-space:nowrap" >≡  λ <span style="font-style:italic">n</span>.<span style="font-style:italic">n</span> (λ <span style="font-style:italic">x</span>.false) true
</td></tr>
</table></td></tr>
</table>
<!--TOC subsection id="sec14" La fonction factorielle-->
<h3 id="sec14" class="subsection">1.5.3 La fonction factorielle</h3><!--SEC END --><p>
Nous pouvons l’exprimer de manière assez simple. La difficulté est de manipuler toujours les applications avec un seul argument, en version
<span style="font-style:italic">curryfiées</span>.
Nous appliquons le combinateur <span style="font-style:italic">Y</span> associé à la stratégie de réduction normale.
Attention à ne pas réduire telle quelle la fonction <code class="verb">fact</code>. La réduction serait infinie comme on l’a vu précedemment. Seul la présence
d’un argument permet d’aboutir à la forme normale.</p><p>Cette forme normale constitue notre <span style="font-style:italic">valeur</span> (au sens d’un langage interprété).
</p><pre class="verbatim">let fact =
  App (y,
    (Lam ("f",
       (Lam ("n",
          (App ((App ((App (si, (App (isZero, (Var "n"))))), un)),
             (App ((App (mult, (Var "n"))),
                (App ((Var "f"), (App (pred, (Var "n"))))))))))))))

# church2Int (betaNormal (App(fact, int2Church 4)));;
- : int = 24                                        
</pre><p>
Nous n’afficherons pas les réductions ici. Le calcul de la factorielle de 3 nécessite 705 β-réductions. 
La factorielle de 5 en nécessite plus de 28000…</p>
<!--TOC section id="sec15" La notation de <span style="font-style:italic">de Bruijn</span>-->
<h2 id="sec15" class="section">1.6 La notation de <span style="font-style:italic">de Bruijn</span></h2><!--SEC END --><p>
<span style="font-style:italic">What’s in a name ? That which we call a rose <br>
	 By any other name would smell as sweet.</span>[<a href="#WS">17</a>] <br>
	 Citation reprise par Xavier Leroy dans
	 son excellent cours au collège de France <br>
</p><p>
Le mécanisme de capture d’une variable libre par une lambda, qui nous oblige à faire de manière fastidieuse
du renommage ponctuel de variables, est dû au fait qu’il y a un partage possible entre les noms des variables
libres et des variables liées. </p><p>Pour éviter cela, nous pouvons utiliser une autre représentation du λ-terme. Le principe est
de nommer les variables liées par un indice indiquant la profondeur de leurs liens (ou autrement dit la
hauteur de leurs liaisons).</p><p>L’arbre syntaxique sera alors défini par :
</p><ol class="enumerate" type=1><li class="li-enumerate">
	les feuilles qui correspondent à des variables libres ou liées, représentées par un indice
	</li><li class="li-enumerate">le noeud unaire λ
	</li><li class="li-enumerate">le noeud binaire @
</li></ol><pre class="verbatim">type tbruijn =
 | Va of int
 | La of tbruijn 
 | Ap of tbruijn * tbruijn
</pre><p>
	
Soit le terme <span style="font-style:italic">M</span>=λ <span style="font-style:italic">x</span>.<span style="font-style:italic">x</span>(λ <span style="font-style:italic">y</span>. <span style="font-style:italic">yx</span>), indiquons en exposant la hauteur de la liaison
de chaque variable liée : <span style="font-style:italic">M</span>=λ <span style="font-style:italic">x</span>.<span style="font-style:italic">x</span><sup>0</sup>(λ <span style="font-style:italic">y</span>. <span style="font-style:italic">y</span><sup>0</sup><span style="font-style:italic">x</span><sup>1</sup>)
</p><blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 1.1: Représentation du terme λ <span style="font-style:italic">x</span>.<span style="font-style:italic">x</span>(λ <span style="font-style:italic">y</span>. <span style="font-style:italic">yx</span>)</td></tr>
</table></div>
[scale=0.5]
	λ
	child  node @
			child  node 0 
			child  node λ
					child  node @ 
						 child node 0
						 child node 1 ;

<div class="center"><hr class="floatrule"></div></div></blockquote><p>Pour les variables libres, nous pouvons aussi utiliser un indice pour les nommer.
Soit un ensemble de variables libres <span style="font-style:italic">x</span><sub>1</sub>, <span style="font-style:italic">x</span><sub>2</sub>, <span style="font-style:italic">x</span><sub>3</sub>,…, <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub> nous les nommerons en ajoutant 
à leur indice <span style="font-style:italic">i</span> la profondeur jusqu’à la racine. Les indices des variables libres seront
donc toujours supérieur à ceux des variables liées sur leurs branches. Cependant, avec cette notation une
même variable libre avec plusieurs occurences dans un terme pourra avoir des indices différents.</p><p>Nous avons maintenant une représentation <span style="font-style:italic">canonique</span> : deux termes sont α-équivalents
si et seulement si leurs représentations en de de Bruijn sont égales.</p><p>Voici une fonction d’implémentation <code class="verb">t2b</code> transformant des termes en termes de de Bruijn.
</p><pre class="verbatim">let reste s = int_of_string(sub s 1 ((String.length s)-1)) ;;

let add_env var env =
 (var,0)::map (fun pp -&gt; (fst(pp),(1 + snd(pp)))) env ;;

let t2b terme =
 let l = varLibres terme in
 let rec terme_to_bruijn t env hauteur =
 match t with
 | Var x -&gt; if (mem x l) then Va((reste x) + hauteur) else Va(assoc x env)
 | App (n1, n2) -&gt; Ap (terme_to_bruijn n1 env hauteur, terme_to_bruijn n2 env hauteur) 
 | Lam (x, c) -&gt; La (terme_to_bruijn c (add_env x env) (hauteur+1) )
 in terme_to_bruijn terme [] 0

let decalage d t =
 let rec aux p = function
 | Ap (t1,t2) -&gt; Ap (aux p t1, aux p t2) 
 | La (t) -&gt; La (aux (p+1) t)
 | Va (i) when i&lt;p -&gt; Va(i)
 | Va(i) -&gt; Va (i+d)
 in aux 0 t

let beta_b (La u) t =
 let rec aux p = function
 | Ap (u1,u2) -&gt; Ap (aux p u1, aux p u2)
 | La (v) -&gt; La (aux (p+1) v)
 | Va (i)  when i=p -&gt; decalage p t (*on rend t décalé de la profondeur d'abstr p*)
 | Va (i)  when i&lt;p -&gt; Va (i) (*i est lié, on la rend tel quel *)
 | Va (i) -&gt; Va (i-1) (* on décrèmente la variable libre car la betareduc supprime une lamdda*)
 in aux 0 u ;;

let rec normale_bruijn  = function
 | Va x -&gt; raise IRREDUCTIBLE
 | La n -&gt; La (normale_bruijn n)
 | Ap (La n, m) -&gt; beta_b (La n) m
 | Ap (n,m) -&gt; try Ap (normale_bruijn  n, m)
 with IRREDUCTIBLE -&gt; Ap (n, normale_bruijn  m)

let rec reduc_bruijn t =
 try reduc_bruijn (normale_bruijn t)
 with IRREDUCTIBLE -&gt; t 
</pre>
<!--TOC section id="sec16" Le λ-calcul simplement typé-->
<h2 id="sec16" class="section">1.7 Le λ-calcul simplement typé</h2><!--SEC END -->
<!--TOC subsubsection id="sec17" Implémentation-->
<h4 id="sec17" class="subsubsection">Implémentation</h4><!--SEC END --><p>
Un contexte, ou environnement de typage Γ, est un ensemble de paires de la forme 
( <span style="font-style:italic">x</span> , τ ) où <span style="font-style:italic">x</span> est une variable et τ un type.
Un jugement de typage est un triplet Γ ⊢ <span style="font-style:italic">t</span>:τ <br>

Le terme <span style="font-style:italic">t</span> sera bien typé dans Γ par les règles de jugement suivantes :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ></td><td style="text-align:center;white-space:nowrap" >  <span style="font-style:italic">si</span> (<span style="font-style:italic">x</span>,τ ) ∈ Γ  ,  <span style="font-style:italic">alors</span> Γ ⊢ <span style="font-style:italic">x</span>:τ  </td><td style="text-align:center;white-space:nowrap" ></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ></td><td style="text-align:center;white-space:nowrap" >  <span style="font-style:italic">si</span>  Γ ⋃ (<span style="font-style:italic">x</span>,τ <sub>1</sub>)⊢ <span style="font-style:italic">u</span>:τ <sub>2</sub>,  <span style="font-style:italic">alors</span> Γ ⊢ λ <span style="font-style:italic">x</span>:τ <sub>1</sub>.<span style="font-style:italic">u</span> : τ <sub>1</sub>→ τ <sub>2</sub> </td><td style="text-align:center;white-space:nowrap" ></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ></td><td style="text-align:center;white-space:nowrap" >  <span style="font-style:italic">si</span> Γ ⊢ <span style="font-style:italic">u</span>:τ <sub>1</sub>→ τ <sub>2</sub> <span style="font-style:italic">et</span> Γ ⊢ <span style="font-style:italic">v</span>:τ <sub>1</sub>,  
<span style="font-style:italic">alors</span>  Γ ⊢ <span style="font-style:italic">uv</span>:τ <sub>2</sub> </td><td style="text-align:center;white-space:nowrap" ></td></tr>
</table></td></tr>
</table><p>Afin de jouer avec ce λ-calcul typé, nous introduisons la constante de type <code class="verb">Int</code>.</p><pre class="verbatim">type ltype = 
| Int 
| Vart of string
| Fleche of ltype*ltype
</pre><p>De même, nous enrichissons notre définition de terme avec le constructeur <code class="verb">Const of int</code> et la fonction binaire <code class="verb">Plus</code> 
</p><pre class="verbatim">type terme = 
  | Var of string 
  | App of terme * terme 
  | Lam of string * terme
  | Const of int
  | Plus of terme * terme
</pre>
<!--TOC subsubsection id="sec18" Inférence de type d’un terme <span style="font-style:italic">t</span>-->
<h4 id="sec18" class="subsubsection">Inférence de type d’un terme <span style="font-style:italic">t</span></h4><!--SEC END --><p>
Prenons l’exemple du terme 
<span style="font-family:monospace"><span style="font-style:italic">apply</span></span> ≡ λ <span style="font-style:italic">f</span> . λ <span style="font-style:italic">x</span> .<span style="font-style:italic">fx</span></p><p>L’algorithme d’inférence se déroule en quatre temps.</p><ol class="enumerate" type=1><li class="li-enumerate">
Assignation préliminaire de types ou variables de types à chaque sous-terme de l’expression.
Pour cela, nous parcourons l’arbre du terme en y affectant à chaque variable liée une variable de type, ainsi qu’à
chaque sous-terme. Ce parcours nous rend en sortie une aliste comprenant l’occurence et la variable de type associée α<sub><span style="font-style:italic">i</span></sub>
<div class="center"> 
[level distance=1.5cm,
level 1/.style=sibling distance=2cm,
level 2/.style=sibling distance=1.5cm, scale=0.7]
λ
child  node <span style="font-style:italic">f</span>
child  node λ 
child  node <span style="font-style:italic">x</span>
child  node @ 
child  node <span style="font-style:italic">f</span> 
child  node <span style="font-style:italic">x</span> 


;
 
[level distance=1.5cm,
level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=3cm, scale=0.7]
(0,α<sub>1</sub>)
child  node (1, α<sub><span style="font-style:italic">f</span></sub>)
child  node (2, α<sub>2</sub>) 
child  node (21, α<sub><span style="font-style:italic">x</span></sub>)
child  node (22, α<sub>3</sub>) 
child  node (221,α<sub><span style="font-style:italic">f</span></sub>)  
child  node (222, α<sub><span style="font-style:italic">x</span></sub>) 


;
 
</div></li><li class="li-enumerate">Collecte des contraintes avec la fonction <span style="font-style:italic">T</span>: <span style="font-style:italic">terme</span> ↦ <span style="font-style:italic">type</span> 
<ul class="itemize"><li class="li-itemize">
Pour une abstraction : <span style="font-style:italic">e</span> = λ <span style="font-style:italic">x</span>.<span style="font-style:italic">e</span><sub>1</sub>  D  <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span>) = <span style="font-style:italic">T</span>(<span style="font-style:italic">x</span>) → <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span><sub>1</sub>) 
</li><li class="li-itemize">Pour une application : <span style="font-style:italic">e</span> = <span style="font-style:italic">e</span><sub>1</sub> <span style="font-style:italic">e</span><sub>2</sub> D  <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span><sub>1</sub>) = <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span><sub>2</sub>) → <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span>) 
</li><li class="li-itemize">Pour l’application de l’addition : <span style="font-style:italic">e</span>=<span style="font-style:italic">e</span><sub>1</sub>+<span style="font-style:italic">e</span><sub>2</sub> D  <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span>)= <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span><sub>1</sub>) = <span style="font-style:italic">T</span>(<span style="font-style:italic">e</span><sub>2</sub>) = <span style="font-family:monospace"><span style="font-style:italic">int</span></span> 
</li></ul> <pre class="verbatim">utop#  t ;;
- : terme = Lam ("f", Lam ("x", App (Var "f", Var "x")))

utop# hm t ;;
- : (ltype * ltype) list =
[(Vart "alpha_1", Fleche (Vart "alpha_f", Vart "alpha_2"));
 (Vart "alpha_f", Vart "alpha_f");
 (Vart "alpha_2", Fleche (Vart "alpha_x", Vart "alpha_3"));
 (Vart "alpha_x", Vart "alpha_x");
 (Vart "alpha_f", Fleche (Vart "alpha_x", Vart "alpha_3"));
 (Vart "alpha_f", Vart "alpha_f"); (Vart "alpha_x", Vart "alpha_x")]
</pre></li><li class="li-enumerate">Unification de ces constraintes afin de trouver la substitution la plus générale si l’expression est typable. 
Dans le cas contraire, échec. Nous utilisons l’algorithme d’unification que nous détaillerons dans un chapitre suivant.</li><li class="li-enumerate">Nous appliquons cette substitution à la variable de type initialement affectée au terme <span style="font-style:italic">t</span>, à l’étape 1.
<pre class="verbatim">  - : ltype = Fleche (Fleche (Vart "alpha_x", Vart "alpha_3"),
                      Fleche (Vart "alpha_x", Vart "alpha_3"))
</pre>
</li></ol>
<!--TOC section id="sec19" Les <span style="font-style:italic">Pure Type Systems</span>-->
<h2 id="sec19" class="section">1.8 Les <span style="font-style:italic">Pure Type Systems</span></h2><!--SEC END -->
<!--TOC subsubsection id="sec20" Introduction-->
<h4 id="sec20" class="subsubsection">Introduction</h4><!--SEC END --><p>
Le λ-calcul simplement typé que nous nommons λ <sub>→</sub> ne permet
de représenter des fonctions que des termes vers les termes. De manière générale, nous souhaiterions
pouvoir modéliser :
</p><ul class="itemize"><li class="li-itemize">
Fonction des termes vers les termes 
</li><li class="li-itemize">Fonction des types vers les termes pour permettre le polymorphisme
</li><li class="li-itemize">Fonction des types vers les types pour avoir des constructeurs de type 
</li><li class="li-itemize">Fonction des termes vers les types pour avoir des types dépendants
</li></ul><p>
Nous reprenons ici le très bon formalisme de Barendregt [<a href="#baren">3</a>]
</p><div class="theorem"><span style="font-weight:bold">Définition ‍5</span> <em>
La syntaxe est la suivante :
</em><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="color:red"><span style="font-style:italic">T</span></span> ::= <span style="font-style:italic">V</span>  |  <span style="font-style:italic">C</span>  | <span style="color:red"><span style="font-style:italic">T</span></span>  |  <span style="color:red"><span style="font-style:italic">T</span></span> 
 |  λ <span style="font-style:italic">V</span>:<span style="color:red"><span style="font-style:italic">T</span></span>.<span style="color:red"><span style="font-style:italic">T</span></span>  |  Π <span style="font-style:italic">V</span> : <span style="color:red"><span style="font-style:italic">T</span></span>.<span style="color:red"><span style="font-style:italic">T</span></span>
</td></tr>
</table><em>
</em><span style="font-style:italic">C</span><em> est l’ensemble des deux constantes : </em>*<em> et </em>▫<em> <br>
 </em><span style="font-style:italic">V</span><em> est un ensemble fini de variables <br>
 </em>λ<em> est l’opération d’abstraction <br>
 </em>Π<em> est l’opérateur produit permettant de matérialiser le type dépendant 
</em></div><p>
Il n’y a donc pas de distinction entre les termes et les types. Chaque terme est typé, chaque type est typé, avec un système pyramidal
infini.</p><p>Nous utiliserons le formalisme <span style="font-style:italic">à la Church</span>.
Chaque terme est annoté de son type, contrairement au λ-calcul simplement typé 
<span style="font-style:italic">à la Curry</span> que nous
avons présenté précedemment où les termes étaient libres de type et un mécanisme d’inférence de 
type permettait ensuite d’associer à chaque terme un type.</p><p>L’environnement de type Γ est défini par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Γ ::= ∅ |  Γ, <span style="font-style:italic">x</span>:<span style="color:red"><span style="font-style:italic">T</span></span> </td></tr>
</table><p>
Nous avons les règles de réduction suivantes:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">(λ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>) ‍<span style="font-style:italic">C</span>→ <sub>β </sub><span style="font-style:italic">B</span>[<span style="font-style:italic">C</span>/<span style="font-style:italic">x</span>]</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span>→ <sub>β </sub><span style="font-style:italic">B</span>′</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">λ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>→ <sub>β </sub>λ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>′</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span>→ <sub>β </sub><span style="font-style:italic">A</span>′</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">λ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>→ <sub>β </sub>λ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>′.<span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">B</span>→ <sub>β </sub><span style="font-style:italic">B</span>′</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>→ <sub>β </sub>Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>′</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">A</span>→ <sub>β </sub><span style="font-style:italic">A</span>′</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>→ <sub>β </sub>Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>′.<span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" >  
</td></tr>
</table></td></tr>
</table><p>
Nous avons les règles de typage suivantes.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">⊢ *:▫ </td></tr>
</table></td><td class="dcell">  (Axiom)</td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">s</span>  <span style="font-style:italic">x</span> does not occur in Γ </td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Γ ,<span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>⊢ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span></td></tr>
</table></td><td class="dcell">  (Start)</td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">B</span>  Γ ⊢ <span style="font-style:italic">C</span>:<span style="font-style:italic">s</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Γ ,<span style="font-style:italic">x</span>:<span style="font-style:italic">C</span>⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">  (Weakening)</td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">C</span>:Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>  Γ ⊢ <span style="font-style:italic">a</span>:<span style="font-style:italic">A</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">Ca</span>:<span style="font-style:italic">B</span>[<span style="font-style:italic">a</span>/<span style="font-style:italic">x</span>]</td></tr>
</table></td><td class="dcell">  (Application)</td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">B</span>  <span style="font-style:italic">B</span>=<sub>β </sub><span style="font-style:italic">B</span>′  Γ ⊢ <span style="font-style:italic">B</span>′:<span style="font-style:italic">s</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">B</span>′</td></tr>
</table></td><td class="dcell">  (Conversion)</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>Soit la paire ( <span style="font-style:italic">s</span> 1 , <span style="font-style:italic">s</span> 2 ) , nous avons les deux règles ci-dessous:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">s</span><sub>1</sub>  Γ ,<span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>⊢ <span style="font-style:italic">B</span>:<span style="font-style:italic">s</span><sub>2</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Γ ⊢ Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span>:<span style="font-style:italic">s</span><sub>2</sub></td></tr>
</table></td><td class="dcell">  (Product) </td></tr>
</table></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">s</span><sub>1</sub>  Γ ,<span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>⊢ <span style="font-style:italic">b</span>:<span style="font-style:italic">B</span>  Γ ,<span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>⊢ <span style="font-style:italic">B</span>:<span style="font-style:italic">s</span><sub>2</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Γ ⊢ λ <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">b</span>:Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span></td></tr>
</table></td><td class="dcell">  (Abstraction)
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
<br>
</p><p>Le système <span style="font-style:italic">PTS</span> respecte les propriétés suivantes:
</p><ol class="enumerate" type=1><li class="li-enumerate">
La propriété de Church-Rosser : <span style="font-style:italic">M</span>→ <sub>β </sub><span style="font-style:italic">N</span>  et <span style="font-style:italic">M</span>→ <sub>β </sub><span style="font-style:italic">N</span>′ alors il existe <span style="font-style:italic">N</span>″ 
 tel que<br>
 <span style="font-style:italic">N</span> → <sub>β </sub><sup>*</sup><span style="font-style:italic">N</span>″  et  <span style="font-style:italic">N</span>′→ <sub>β </sub><sup>*</sup><span style="font-style:italic">N</span>″ <br>
 </li><li class="li-enumerate">La propriété de réduction : Γ ⊢ <span style="font-style:italic">M</span>:<span style="font-style:italic">T</span>  et 
<span style="font-style:italic">M</span>→ <sub>β </sub><span style="font-style:italic">M</span>′  alors  Γ ⊢ <span style="font-style:italic">M</span>′:<span style="font-style:italic">T</span>  <br>
 </li><li class="li-enumerate">L’unicité des types : Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">B</span>  et Γ ⊢ <span style="font-style:italic">A</span>:<span style="font-style:italic">B</span>′  alors <span style="font-style:italic">B</span>=<sub>β </sub><span style="font-style:italic">B</span>′ <br>
</li></ol><p>Pour pouvoir éprouver notre système PTS, nous ajoutons les constantes suivantes à notre environnement Γ
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">Γ = { (*:▫) ; (nat:*) ; (<span style="font-style:italic">O</span>:<span style="font-style:italic">nat</span>) ; (succ:Π <span style="font-style:italic">x</span>:nat.nat) } </td></tr>
</table><p>Voici quelques exemples interprétés par OCAML ci-dessous. Nous avons simplifié l’affichage
du type Π <span style="font-style:italic">x</span>:<span style="font-style:italic">A</span>.<span style="font-style:italic">B</span> par <span style="font-style:italic">A</span>→ <span style="font-style:italic">B</span> si <span style="font-style:italic">x</span> n’est pas une variable libre de <span style="font-style:italic">B</span>.</p><p>Nous utilisons pour l’affichage OCAML les caractères UTF-8 : <code class="verb">λ, π, →</code></p><pre class="verbatim">(*  Polymorphisme   *)
let id = Lam("A", C "*", Lam("x", V "A", V "x")) ;;
let id_nat = App(id, C "nat") ;;
let zero = App(id_nat, C "O") ;;

id = λA:*.λx:A.x
id nat = λA:*.λx:A.x nat

print_terme (typage id env0) 
πA:*.A→A

print_terme (reduc id_nat) ;;
λx:nat.x

print_terme zero ;;
λA:*.λx:A.x nat O
print_terme zero ;;
print_terme (typage zero env0) ;;
nat

print_terme (fullReduc zero) ;;
O

(* Les entiers *)
let entiers = Prod ("X", C "*",  Prod ("x", V "X", Prod ("y", Prod ("z", V "X", V "X"), V "X")))
utop # print_terme entiers;;
πX:*.(X→((X→X)→X))

let zero =  Lam("X", C "*", Lam("x", V "X", Lam ("y", Prod("z", V "X", V "X"), V "x")))

let succ = Lam ("n", entiers, Lam ("X", C "*", Lam ("x", V "X", Lam ("y", Prod("z", V "X", V "X"),
               App(V "y", App (App(App(V "n", V "X"), V "x"), V "y") )))))

utop # print_terme (fullReduc trois) ;;
λX:*.λx:X.λy:(X→X).y (y (y x) ) 

(*twice*)
utop # print_terme twice ;;
λA:*.λf:(A→A).λa:A.f (f a) 

utop # print_terme (typage twice env0) ;;
πA:*.((A→A)→(A→A))

let plus2  = App(App(twice, entiers), succ) ;;
print_terme (fullReduc (App(plus2, trois))) ;
λX:*.λx:X.λy:(X→X).y (y (y (y (y x) ) ) )
</pre><p>
Le type produit pourra être défini de la manière suivante :</p><p>Si <span style="font-style:italic">U</span> et <span style="font-style:italic">V</span> sont des types, alors 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">U</span>× <span style="font-style:italic">V</span> = Π <span style="font-style:italic">X</span>.(<span style="font-style:italic">U</span>→ <span style="font-style:italic">V</span> → <span style="font-style:italic">X</span>)→ <span style="font-style:italic">X</span></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">&lt;<span style="font-style:italic">u</span>,<span style="font-style:italic">v</span>&gt; = λ <span style="font-style:italic">X</span>:*.λ <span style="font-style:italic">x</span>:(<span style="font-style:italic">U</span> → <span style="font-style:italic">V</span> → <span style="font-style:italic">X</span>). <span style="font-style:italic">x</span> <span style="font-style:italic">u</span> <span style="font-style:italic">v</span> </td></tr>
</table><p>Prenons par exemple le couple d’entiers &lt;100, 101&gt;, nous le modélisons par 
</p><pre class="verbatim">let prod_100_101 = 
  Lam("X", C "nat", 
    Lam("x", Prod("z", C "nat", 
:w
     (Prod ("w", C "nat", V "X" ))),App (App (V "x", N 100), N 101))) ;;
print (typage prod_100_101 env0) ;;
πX:nat.((nat→(nat→X))→X)  
</pre><p>Les projections sont définies par 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">π<sup>1</sup> <span style="font-style:italic">t</span> = <span style="font-style:italic">t</span> <span style="font-style:italic">U</span> (λ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>.λ <span style="font-style:italic">y</span>:<span style="font-style:italic">V</span>. <span style="font-style:italic">x</span>)  et  π<sup>2</sup> <span style="font-style:italic">t</span> = <span style="font-style:italic">t</span> <span style="font-style:italic">U</span> (λ <span style="font-style:italic">x</span>:<span style="font-style:italic">U</span>.λ <span style="font-style:italic">y</span>:<span style="font-style:italic">V</span>. <span style="font-style:italic">y</span>)</td></tr>
</table><pre class="verbatim">let proj1 = 
  Lam("t", (typage prod_uv env0), 
    App(App(V "t", V "U"), Lam ("x", V "U", Lam ("y", V "V", V "x"))))
 in print (fullReduc (App (proj1, prod_100_101)))

let proj2 = 
  Lam("t", (typage prod_uv env0),
    App(App(V "t", V "U"), Lam ("x", V "U", Lam ("y", V "V", V "y"))))
in print (fullReduc (App (proj2, prod_uv)))
</pre>
<!--TOC subsubsection id="sec21" MiniCOQ-->
<h4 id="sec21" class="subsubsection">MiniCOQ</h4><!--SEC END --><p>
Nous nous éloignons de la simplicité du <span style="font-style:italic">Pure Type System</span> en surchargeant notre
terme algébrique des types suivants :
</p><ul class="itemize"><li class="li-itemize">
Le type <code class="verb">Nat</code> avec ses constructeurs <code class="verb">0</code> et <code class="verb">S</code>
</li><li class="li-itemize">Le type de l’égalité <code class="verb">Eq</code> avec son unique constructeur <code class="verb">Eq_refl</code>
</li><li class="li-itemize">Le type <code class="verb">And</code> avec son unique constructeur <code class="verb">Conj</code> et ses fonctions
<code class="verb">Proj1</code> et <code class="verb">Proj2</code>. L’affichage du type <code class="verb">And</code> se fera avec les caractères <code class="verb">/\</code>
</li><li class="li-itemize">Le type <code class="verb">Or</code> avec ses constructeurs <code class="verb">Or_introl</code> et <code class="verb">Or_intror</code> et sa fonction <code class="verb">Case</code>.
L’affichage de ce type se fera avec les caractères <code class="verb">\/</code>
</li><li class="li-itemize">Le type <code class="verb">False</code> sans constructeur, mais avec la fonction <code class="verb">False_ind(t1,t2)</code> qui se
réduit en <code class="verb">t1</code> si le type de <code class="verb">t2</code> est égal à <code class="verb">False</code> (<span style="font-style:italic">ex falso quodlibet</span>)
</li></ul><p>
Démontrons le théorème simple décrit en COQ comme ci-dessous.</p><p>
Theorem imp : ∀ (a b c : Prop), ((a→b) ∧ (a→c)) → a→ (b∧c).Proof.1.00em
intros a b c H.1.00em
intro Ha.1.00em
split.1.00em
destruct H as (H1 &amp; H2).1.00em
apply H1. assumption.1.00em
destruct H as (H1 &amp; H2).1.00em
apply H2. assumption.Qed.</p><p>Nous pouvons représenter la preuve du théorème avec la dérivation suivante:
<br>
</p><p><span style="font-size:small">
[intros a b c H]</span><span style="font-size:small">((A⇒B)∧(A⇒C))⇒(A⇒(B ∧C))</span><span style="font-size:small">
</span><span style="font-size:small">[intros Ha]</span><span style="font-size:small">A ⇒(B∧C)</span><span style="font-size:small">
</span><span style="font-size:small">[split]</span><span style="font-size:small">B ∧C</span><span style="font-size:small">
</span><span style="font-size:small"> 
[apply H1]</span><span style="font-size:small">B</span><span style="font-size:small"> </span><span style="font-size:small">[destruct H as (H1 , H2)]</span><span style="font-size:small">A ⇒B</span><span style="font-size:small">[(A⇒B) ∧(A⇒C)]</span><span style="font-size:small">[A] </span><span style="font-size:small"> [apply H2]</span><span style="font-size:small">C</span><span style="font-size:small"> </span><span style="font-size:small">[destruct H as (H1 , H2)]</span><span style="font-size:small">A ⇒C</span><span style="font-size:small">[(A⇒B) ∧(A⇒C)]</span><span style="font-size:small">[A] </span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">
</span><span style="font-size:small">
</span>
</p><p>Avec notre système PTS, nous codons cela de la manière suivante:
</p><pre class="verbatim">let imp = Prod("A", C "Type", Prod ("B", C "Type", Prod ("C", C "Type",
               Prod ("z", And(Prod("x", V "A", V "B"), Prod ("y", V "A", V "C")), 
                     Prod ("w", V "A", And (V "B", V "C"))))))
in print imp ;;
&gt; πA:Type.πB:Type.π:Type.((A→B)/\(A→C)→(A→B/\C))

let preuve_imp_pts = 
 Lam("A", Type,
   Lam("B", Type,
     Lam("C", Type, 
      Lam("h", And(Prod("x", V "A", V "B"), Prod("y", V "A", V "C")), 
       Lam ("x", V "A", Conj (App(Proj1 (V "h"), V "x"), App(Proj2 (V "h"), V "x"))))))) 
in (print preuve_imp_pts; print_string "\n"; print (check preuve_imp_pts env0))  ;;

&gt; λA:Type.λB:Type.λC:Type.λh:(A→B)/\(A→C).λx:A.conj((proj1(h) x),(proj2(h) x))
  πA:Type.πB:Type.πC:Type.((A→B)/\(A→C)→(A→B/\C))
</pre><p>
Nous retrouvons en OCAML la dualité entre le type produit <code class="verb">*</code> et le ∧ logique,
ainsi qu’entre la flèche fonctionnelle <code class="verb">-&gt;</code> et l’implication logique ⇒.
OCAML infère correctement le type (théorème) depuis le terme (la preuve).</p><pre class="verbatim">let preuve_imp_ocaml = function h -&gt; (function x -&gt; ((fst h) x, (snd h) x)) ;;
val preuve_imp_ocaml : ('a -&gt; 'b) * ('a -&gt; 'c) -&gt; 'a -&gt; 'b * 'c 
</pre><p>Voici un autre exemple très simple illustrant le type ∧ et les fonctions de construction <code class="verb">And</code> et de projections <code class="verb">Proj1/2</code></p><p>
Theorem et_refl: ∀ (a b:Prop), a∧b → b∧a .Proof.0.50em
intros a b H.0.50em
split.0.50em
destruct H as [Ha Hb].0.50em
assumption.0.50em
destruct H as [Ha Hb].0.50em
assumption.Qed.Print et_refl.</p><pre class="verbatim">let preuve_et_refl = 
  Lam("A", Type,
    Lam("B", Type, 
     Lam("h", And(V "A", V "B"), Conj(Proj2 (V "h"), Proj1 (V "h"))))) 
  in ( print preuve_et_refl ; print_string "\n"; print(check preuve_et_refl env0)) ;;
&gt; λA:Type.λB:Type.λh:A/\B.conj(proj2(h) ,proj1(h))
  πA:Type.πB:Type.(A/\B→B/\A)
</pre>
<!--TOC subsubsection id="sec22" Le ∨ logique-->
<h4 id="sec22" class="subsubsection">Le ∨ logique</h4><!--SEC END --><p>
Theorem or_elim: ∀ (a b c:Prop), (a→c)-&gt;(b→c)-&gt;(a∨b)-&gt;c.Proof.1.00em
intros a b c h1 h2 h3.1.00em
destruct h3 as [ha | hb].1.00em
apply h1. exact ha.1.00em
apply h2. exact hb.Qed.
</p><pre class="verbatim">(* fonction générée en COQ*)
  or_elim = 
 fun (a b c : Prop) (h1 : a -&gt; c) (h2 : b -&gt; c) (h3 : a \/ b) =&gt;
 match h3 with
  | or_introl ha =&gt; h1 ha
  | or_intror hb =&gt; h2 hb
 end
     : forall a b c : Prop, (a -&gt; c) -&gt; (b -&gt; c) -&gt; a \/ b -&gt; c  

(* fonction OCAML *)
let preuve_or_elim =
  Lam("A", Type,
    Lam("B", Type,
      Lam ("C", Type,
        Lam("h1", Prod("x", V "A", V "C"),
          Lam("h2", Prod("y", V "B", V "C"),
            Lam("h3", Or(V "A", V "B"), 
              Case(V "h3", V "h1", V "h2"))))))) 
  in (print preuve_or_elim ; print_newline() ;
      print (check preuve_or_elim env0)) ;;
&gt; λA:Type.λB:Type.λC:Type.λh1:(A→C).λh2:(B→C).λh3:A\/B.case(h3, h1, h2)
  πA:Type.πB:Type.πC:Type.((A→C)→((B→C)→(A\/B→C)))
</pre>
<!--TOC subsubsection id="sec23" L’égalité-->
<h4 id="sec23" class="subsubsection">L’égalité</h4><!--SEC END --><p>
Prouvons que ∀ <span style="font-style:italic">n</span> ∈ <span style="font-family:monospace"><span style="font-style:italic">Nat</span></span>, (λ <span style="font-style:italic">n</span>.2  <span style="font-style:italic">n</span>) = 2
</p><pre class="verbatim">let th = Prod("n", Nat, Eq(Nat, App(cst2, V "n"), S (S O) )) 
  in print th;;
&gt; πn:nat.eq(nat, (λn:nat.2 n), 2)

let proof = Lam("n", Nat, Eq_refl(Nat, App(cst2, V "n"))) in 
  (print proof ; print_newline() ;
   print (check proof env0) ; print_newline() ; 
   print (fullReduc (check proof env0)))  ;;
&gt; λn:nat.eq _refl(nat, (λn:nat.2 n))
  πn:nat.eq(nat, (λn:nat.2 n), (λn:nat.2 n))
  (nat→eq(nat, 2, 2))
</pre><p>
Rappelons la règle de conversion ci-dessous :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">t</span>:<span style="font-style:italic">A</span>        Γ ⊢ <span style="font-style:italic">B</span>:<span style="font-style:italic">s</span>        <span style="font-style:italic">A</span>=<sub>β</sub><span style="font-style:italic">B</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">Γ ⊢ <span style="font-style:italic">t</span>:<span style="font-style:italic">B</span></td></tr>
</table></td></tr>
</table><p>
Ainsi, un terme peut avoir plusieurs types.</p><p>La preuve <code class="verb">λn:nat.eq _refl(nat, (λn:nat.2 n))</code> est preuve de :
</p><ul class="itemize"><li class="li-itemize">
<code class="verb">πn:nat.eq(nat, (λn:nat.2 n), (λn:nat.2 n))</code>
</li><li class="li-itemize"><code class="verb">πn:nat.eq(nat, (λn:nat.2 n), 2)</code>
</li><li class="li-itemize"><code class="verb">(nat→eq(nat, 2, 2))</code>
</li></ul><p>
Nous constatons que la preuve n’exhibe pas le process calculatoire de la β-réduction.
Le théorème est ici prouvé par calcul et non par raisonnement. Ces considérations philosophiques sont bien développées
par Henri Poincaré[<a href="#poincare">14</a>]</p>
<!--TOC subsubsection id="sec24" Le faux-->
<h4 id="sec24" class="subsubsection">Le faux</h4><!--SEC END --><pre class="verbatim">let exf = Lam ("x", False, I) (* ex falso quodlibet *)
  in (print exf ; print_newline() ; print (check exf env0)) ;;
&gt; λx:False.I
  (False→True) 
</pre><p>
Voici un exemple simple manipulant la négation et la fonction d’induction du faux.</p><p>
Theorem implication: ∀ (A B:Prop), ¬A∨B → (A→B) .Proof.1.00em
intros.1.00em
destruct H as [H1|H2].1.00em
contradiction.1.00em
assumption.Qed.Print implication.</p><pre class="verbatim">implication = 
 fun (A B : Prop) (H : ~ A \/ B) (H0 : A) =&gt;
  match H with
  | or_introl H1 =&gt; False_ind B (H1 H0)
  | or_intror H2 =&gt; H2
  end
   : forall A B : Prop, ~ A \/ B -&gt; A -&gt; B
</pre><p>Avec notre implémentation OCAML, cela donne :
</p><pre class="verbatim">let preuve_impl =
  Lam("A", Type,
    Lam("B", Type,
      Lam("H", Or(App(non, V "A"), V "B"),
        Lam("H0", V "A",
          Case (V "H", 
                Lam("x", Prod("w", V "A", False), False_ind(V "B", App(V "x", V "H0"))),
                Lam ("y", V "B", V "y")))))) 
in  (print preuve_impl ; print_newline() ;
     print (fullReduc (check preuve_impl env0))) ;;
&gt; λA:Type.λB:Type.λH:(λP:Type.~P A)\/B.λH0:A.case(H, λx:~A.false_ind(B,(x H0)), λy:B.y)
  πA:Type.πB:Type.(~A\/B→(A→B))
</pre>
<!--TOC subsubsection id="sec25" Le point fixe-->
<h4 id="sec25" class="subsubsection">Le point fixe</h4><!--SEC END --><p>
Nous surchargeons notre terme algébrique de l’opérateur de point fixe <code class="verb">Y of terme</code> qui
se réduit en <code class="verb">Y t</code> D  <code class="verb">t (Y t)</code>
</p><pre class="verbatim">let multF = 
  Lam ("f", Prod("w",Nat, Nat),
   Lam ("n", Nat, Lam ("m", Nat, 
        IfThenElse(Egal(V "n",O), O, Add (V "m", App(App (V "f", Sub1 (V "n")), V "m"))))))

let mult = Y multF ;;

let facF = Lam("f", Prod ("z", Nat, Nat), 
             Lam ("n", Nat,
              IfThenElse(Egal(V "n", O), S O, (App(App(mult, V "n"), App(V "f", Sub1 (V "n")) ) )))) ;;

let fac = Y facF  ;;

print (fullReduc (App(fac, S (S (S (S (S O))))))) ;;
&gt; 120
</pre>
<!--TOC subsubsection id="sec26" La logique classique-->
<h4 id="sec26" class="subsubsection">La logique classique</h4><!--SEC END --><p>
Sous l’angle de la correspondance de Curry-Howard, notre système se base sur la logique intuitionniste.
C’est-à-dire que toute proposition a une preuve constructive.
Autrement dit, le type correspondant à la proposition est habité par un terme de notre système PTS.
Avec cette logique nous ne pouvons prouver certains théorèmes comme la loi de Peirce ((<span style="font-style:italic">A</span>→ <span style="font-style:italic">B</span>)→ <span style="font-style:italic">A</span>)→ <span style="font-style:italic">A</span></p><p>Pour cela nous devons ajouter l’axiome du tiers-exclus <span style="font-style:italic">A</span> ∨ ¬ <span style="font-style:italic">A</span>. 
Voici comment la loi de Pierce se déduit avec l’axiome du tiers-exclus. En COQ, cela donne:</p><p>
Axiom classic: ∀ P: Prop, P\/~P.Theorem Peirce: ∀ A B:Prop, ((A→B)-&gt;A)-&gt;A.Proof.1.00em
intros.1.00em
assert (A\/~A) by (apply classic ).1.00em
destruct H0 as [H1 | H2].1.00em
exact H1.1.00em
apply H .1.00em
intros.1.00em
contradiction.Qed.Print Peirce.</p><pre class="verbatim"> Peirce = 
  fun (A B : Prop) (H : (A -&gt; B) -&gt; A) =&gt;
  let H0 : A \/ ~ A := classic A in
  match H0 with
  | or_introl H1 =&gt; H1
  | or_intror H2 =&gt; H (fun H1 : A =&gt; False_ind B (H2 H1))
  end
    : forall A B : Prop, ((A -&gt; B) -&gt; A) -&gt; A
</pre><p>Voici notre implémentation dans notre miniCOQ. 
Nous créons un environnement <code class="verb">env_classic</code> surchargé par le terme <code class="verb">tiers-exclus</code> de type <span style="font-style:italic">A</span> ∨ ¬ <span style="font-style:italic">A</span>.
Nous trichons un peu car le type devrait être polymorphe et donc de la forme ∀ <span style="font-style:italic">P</span>:<span style="font-family:monospace"><span style="font-style:italic">Type</span></span>, <span style="font-style:italic">P</span> ∨ ¬ <span style="font-style:italic">P</span>, mais 
je ne vois pas comment ensuite appliquer cet axiome à une variable <code class="verb">A</code>. Comment COQ gère <code class="verb">let H0 : A \/ ~ A := classic A</code> ? </p><pre class="verbatim">let env_classic = [("tiers-exclus",  Or(V "A", App(non, V "A")))] ;;

let proof_peirce = 
  Lam("A", Type,
    Lam("B", Type, 
      Lam ("H", Prod("x", Prod("y", V "A", V "B"), V "A"),
        Case(C "tiers-exclus",
             Lam("zz", V "A", V "zz"),
             Lam("yy", V "A", App(V "H", Lam("H1", V "A", False_ind(V "B", App(V "yy", V "H1")))))))))
  in (print proof_peirce; print_newline();
    print (check proof_peirce env_classic)) ;;
&gt; λA:Type.λB:Type.λH:((A→B)→A).case(tiers-exclus,
                                    λzz:A.zz,
                                    λyy:A.(H λH1:A.false_ind(B,(yy H1))))
  πA:Type.πB:Type.(((A→B)→A)→A)
</pre>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">La fonction STOP de mon toplevel sous Eclipse ne marche pas…</div></dd><dt class="dt-thefootnotes"><a id="note2" href="#text2">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Un combinateur est un λ-terme comprenant uniquement 
des variables liées</div></dd><dt class="dt-thefootnotes"><a id="note3" href="#text3">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Nous insistons 
là-dessus car nous rappelons que les interprètes MiniScheme et MiniML que nous implémenterons utiliseront la β-réduction faible par valeur.</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec27" L’interprétation-->
<h1 id="sec27" class="chapter">Chapitre ‍2 L’interprétation</h1><!--SEC END -->
<!--TOC section id="sec28" Introduction-->
<h2 id="sec28" class="section">2.1 Introduction</h2><!--SEC END --><p>
Nous avons vu que le λ-calcul utilise la réduction, basée sur un mécanisme de substitution.
Les langages interprétés que nous allons implémenter n’utilisent pas ce mécanisme de substitution, mais
font appel un environnement qui permet de représenter les paires variable/valeur.
A l’application d’une fonction, cet environnement est <span style="font-style:italic">étendu</span> avec les nouvelles paires variable/valeur
des arguments de la fonction.</p><p>Nous perdons donc le côté pur du λ-calcul qui se suffit à lui-même pour
dérouler ses calculs.
L’interprète ne pourra évaluer son expression qu’en présence d’un environnement.
Un interprète est ainsi une fonction <code class="verb">eval</code> telle que <code class="verb">(eval</code> π <code class="verb">env)</code> D   <code class="verb">valeur</code></p><p>Nous reprenons ici un peu du code de l’excellent blog :
<span style="font-family:monospace">https://bernsteinbear.com/blog/lisp</span>.</p><p>Par rapport au code du blog cité, nous faisons deux changements majeurs. Le premier est d’utiliser à nouveau
les outils d’analyseur lexical et syntaxique <span style="font-weight:bold">ocamllex</span> et <span style="font-weight:bold">ocamlyacc</span>. 
Le second sera d’utilisé des listes mutables, afin de pleinement refléter toutes les capacités de Scheme qui n’est
pas un langage fonctionnel <span style="font-style:italic">pur</span>.</p><p>Une fois cet interprète réalisé, nous l’utiliserons pour implémenter un nouvel interprète avec quelques variantes:
liaison <span style="font-style:italic">dynamique</span> et <span style="font-style:italic">statique</span>, évaluation <span style="font-style:italic">stricte</span> et <span style="font-style:italic">paresseuse</span> 
et enfin un interprète par <span style="font-style:italic">continuation</span>, avant de conclure sur une tour de babel avec capacité de réification
et réflection de notre méta-interpète. C’est comme une quête philosophique…</p><p>Pour ces diffèrentes variantes, nous nous inspirons de notre bible sur le langage LISP : <span style="font-style:italic">LISP In Small Pieces</span> de Christian Queinnec.
[<a href="#lisp">15</a>]</p>
<!--TOC section id="sec29" Un interprète MiniScheme avec OCAML-->
<h2 id="sec29" class="section">2.2 Un interprète MiniScheme avec OCAML</h2><!--SEC END -->
<!--TOC subsection id="sec30" L’évaluation-->
<h3 id="sec30" class="subsection">2.2.1 L’évaluation</h3><!--SEC END --><p>
Le λ-calcul repose sur un mécanisme de substitution permettant de réduire les termes et
aboutir à une forme normale. En programmation fonctionnelle, au lieu de réduire un terme, on
l’évaluera. Un terme non fermé ne pourra être évalué que dans un environnement où ses 
variables libres ont une liaison. Nous avons les définitions suivantes:
</p><ul class="itemize"><li class="li-itemize">
	Une <span style="font-style:italic">liaison</span> est un couple (<span style="font-style:italic">x</span>,<span style="font-style:italic">v</span>) où <span style="font-style:italic">x</span> est une variable et <span style="font-style:italic">v</span> est une valeur.
	</li><li class="li-itemize">Un <span style="font-style:italic">environnement</span> est une liste de liaison
	</li><li class="li-itemize">Une <span style="font-style:italic">fermeture</span> est un couple (<span style="font-style:italic">M</span>,ρ) où <span style="font-style:italic">M</span> est un terme et <span style="font-style:italic">p</span> un environnement 
	comportant une liaison pour chaque variable libre de <span style="font-style:italic">M</span>.
	</li><li class="li-itemize">Une <span style="font-style:italic">valeur</span> est une fermeture (<span style="font-style:italic">M</span>,<span style="font-style:italic">p</span>) avec <span style="font-style:italic">M</span> de forme normale.
</li></ul><p>
On formalise l’évaluation par la règle de jugement ρ ⊢ <span style="font-style:italic">M</span> → <span style="font-style:italic">v</span>. Elle exprime
que dans l’environnement ρ, le terme <span style="font-style:italic">M</span> a pour valeur <span style="font-style:italic">v</span>.</p><p>La règle d’évaluation de l’appel par valeur se formalise ainsi comme suit:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">App</span><sub><span style="font-style:italic">v</span></sub>): </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ρ ⊢ <span style="font-style:italic">M</span> → (λ <span style="font-style:italic">x</span> <span style="font-style:italic">M</span><sup>′</sup> , ρ <sup>′</sup> )  
		     ρ ⊢ <span style="font-style:italic">N</span> → <span style="font-style:italic">v</span>      (<span style="font-style:italic">x</span>,<span style="font-style:italic">v</span>);ρ <sup>′</sup> ⊢ <span style="font-style:italic">M</span><sup>′</sup> → <span style="font-style:italic">v</span><sup>′</sup> </td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"> ρ ⊢ <span style="font-style:italic">M</span> <span style="font-style:italic">N</span> → <span style="font-style:italic">v</span><sup>′</sup> </td></tr>
</table></td></tr>
</table><p>L’évaluation de <span style="font-style:italic">M</span><sup>′</sup> le corps de la lambda se fait dans l’environnement ρ <sup>′</sup> augmenté 
d’une liaison due du passage de paramètre. C’est la caractéristique de la liaison lexicale.
Pour une liaison dynamique, l’évaluation du corps de la lambda se fera dans l’environnement
courant ρ</p><p>Dans le cadre d’une implémentation en ML, l’erreur à ne pas faire (et que j’ai malheureusement faite initialement) et de
représenter la valeur d’une évaluation avec un type différent de l’expression à évaluer.
La puissance de Lisp repose sur cette uniformité entre programmme et valeur. Nous utiliserons cette caractéristique pour
implémenter un interprète Lisp en Lisp.</p><p>Voici la séquence du code, depuis le stream en entrée de l’analyseur lexical jusqu’à la sortie de l’évaluateur <code class="verb">eval</code>.
J’ai fait le choix d’avoir une représentation intermédiaire <code class="verb">ast</code> permettant de modéliser l’arbre syntaxique, et de faciliter
le processus d’évaluation.
</p><div class="center">

	(A) at (-1,0) stream;
	(B) at (2,0) token;
	(C) at (4,0) <code class="verb">exp</code>;
	(O) at (6,0) ;
	(P) at (6.5,1) <code class="verb">(if a b c)</code>;
	(Q) at (6.5,-1) <code class="verb">Paire(a, Nil)</code>;<p>	(D) at (7,3) buildast;
	(M) at (13,0) <code class="verb">If(a,b,c)</code>;
	(E) at (10,0) <code class="verb">ast</code>;
	(F) at (7,-3) eval;</p><p>	estun=[-&gt;,&gt;=latex]
	[estun] (A)–node[above] lex (B);
	[estun] (B)–node[above] yacc (C);
	[estun] (C) to[bend left] (D) ;
	[estun] (D) to[bend left] (E);
	[estun] (E) to[bend left] (F) ;
	[estun] (F) to[bend left] (C);</p><p>	[dotted] (E) – node <span style="font-style:italic">print</span> (M) ;
	[dotted] (C) – node <span style="font-style:italic">print</span> (P) ;
	[dotted] (C) – node <span style="font-style:italic">print</span> (Q) ;

</p></div><p>Voici le code OCAML des type abstrait <code class="verb">exp</code>, <code class="verb">ast</code> et <code class="verb">env</code> :</p><pre class="verbatim">type exp =
| Booleen of bool
| Symbole of string
| Mot of string
| Entier of int
| Nil
| Paire of exp ref * exp ref
| Closure of string list * ast list * (env ref)
and ast =
| Atom of exp
| Var of string
| If of ast * ast * ast
| Cond of (ast * ast) list
| And of ast list
| Or of ast list
| Call of ast * ast list
| Call0 of ast    (* procedure sans argument *)
| Lambda of string list * ast list   
| Let of (string * ast) list * ast list
| Letrec of (string * ast) list * ast list
| Define of string * ast
| Begin of ast list
| Apply of ast * ast list
| Quote of exp
and env = (string * exp) list
  </pre>
<!--TOC subsection id="sec31" Les étapes Read, Eval, Print-->
<h3 id="sec31" class="subsection">2.2.2 Les étapes Read, Eval, Print</h3><!--SEC END --><p>
L’interpréte présente trois étapes que l’on décrit souvent avec l’acronyme <span style="font-style:italic">REPL</span> :
Read, Eval, Print, Loop</p><p>L’étape <span style="font-style:italic">READ</span> sera effectuée avec les moteurs ocamllex et ocmalyacc.
Cette étape va lire la saisie clavier et construire l’arbre syntaxique des expressions SCHEME.</p><p>Voici quelques exemples d’arbres syntaxiques générés avec Yacc.
Ces arbres syntaxiques sont à nouveau dessinés avec le package Tikz et nous avons développé une petite
fonction qui parcourt l’expression et génère le code Tikz.</p><p><code class="verb">(moins 4 3)</code>
</p><div class="center">
[level distance=1.5cm]
call child node var child  nodemoins  
child node exp list child  node 4  child  node 3  
;</div><p><code class="verb">(if #t (plus 4 5) (moins 3 2))</code>
</p><div class="center">
[ level 1/.style=sibling distance=3cm,
level 2/.style=sibling distance=1.5cm, level 3/.style=sibling distance=1.5cm]<p>if child  node true child node call child  node var child  nodeplus 
child node exp list child  node 4  child  node 5    child node call child
 node var child  nodemoins  child node exp list child  node 3  child  node 2   
;</p></div><p>Et enfin une expression let <code class="verb">(let ((a 2) (b 3)) (plus a b))</code>
</p><div class="center">
[ level 1/.style=sibling distance=3.5cm,
level 2/.style=sibling distance=2cm, level 3/.style=sibling distance=1.5cm]
let child  child  node bind child  nodea  child node 2 child  node bind child  nodeb 
child node 3  child node body let childnode call child  node var child  nodeplus 
child node exp list child  node var child  nodea  child  node var child  nodeb     ;

</div><p>L’étape <span style="font-style:italic">EVAL</span> va parcourir l’arbre syntaxique de l’expression, traiter cette expression et
en exprimer une valeur modélisée avex le type <code class="verb">value</code></p><p>La fonction <code class="verb">eval</code> est une fonction prenant comme arguments une expression de type <code class="verb">ast</code> et un environnement.
Elle retourne une valeur de type <code class="verb">exp</code>. Voici sa signature: <br>
<code class="verb">val eval : ast -&gt; env -&gt; exp = &lt;fun&gt;</code></p><p>L’étape <span style="font-style:italic">PRINT</span> n’est autre que la fonction d’affichage finale de l’interprète.
Une fois cette étape finie, l’interprète boucle sur l’étape initiale <span style="font-style:italic">READ</span></p>
<!--TOC subsection id="sec32" Liaison lexicale vs liaison dynamique-->
<h3 id="sec32" class="subsection">2.2.3 Liaison lexicale vs liaison dynamique</h3><!--SEC END --><p>
Nous allons utiliser ici la liaison lexicale (statique), et non dynamique.
Cela nous impose de capturer l’environnement existant au moment de la définition de la fonction. 
Plus précisément, l’environnement est capturé par l’évaluation de la lambda, évaluation dont la valeur est appelée une <span style="font-style:italic">closure</span>
ou <span style="font-style:italic">fermeture</span>. </p><p><code class="verb"> Lambda (parametres, expression) -&gt; Closure (parametres, expression, env) </code> </p><p>Dans le cas de la liaison dynamique, la fonction est appliquée en utilisant l’environnement courant, 
et non pas son environnement de définition. Donc pas besoin de fermeture.</p><p>A ma connaissance, la liaison statique est maintenant utilisée dans la plupart des langages fonctionnels.
En SCHEME et ML,nous pouvons voir dans l’exemple ci-dessous que l’évaluation de la définition de la
lambda <code class="verb">inc_x</code> capture la valeur de <code class="verb">x</code> .</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >SCHEME</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >ML </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">&gt; (define x 1)</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb"># let x = 1</code> ;; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">&gt; (define inc_x (lambda () (+ x 1)))</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb"># let inc_x = function () -&gt; x+1 ;;</code> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">&gt; (inc_x)</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb"># inc_x ()</code> ;; </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">2</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">- : int = 2</code> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">&gt; (let ((x 100)) (inc_x))</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb"># let x = 100 in inc_x () ;;</code> </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">2</code></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><code class="verb">- : int = 2</code> </td></tr>
</table>
<!--TOC subsection id="sec33" Gestion de l’environnement-->
<h3 id="sec33" class="subsection">2.2.4 Gestion de l’environnement</h3><!--SEC END --><p>Comme indiqué en préambule, plusieurs choix sont possibles pour la modélisation de l’environnement.
Le choix le plus simple est une représentation par une liste de paires <span style="font-style:italic">variable</span> ↔ <span style="font-style:italic">value</span>
Ce choix peut être fait en OCAML par le type natif <code class="verb">list</code> ou en utilisant le type concret <code class="verb">Paire of Symbole * lobject</code></p><p>La principale difficulté est la représentation de fonctions récursives, comme en exemple la factorielle ci-dessous:
</p><pre class="verbatim">(define fact 
 (lambda (n) 
  (if (eq? n 0) 
    1
    (* n (fact (- n 1)))))
</pre><p>
Nous devons capturer l’environnement existant au moment de la définition de la fonction.
Cet environnement existant ne contient pas déjà la définition de <code class="verb">fact</code>.</p><p>Il y a trois possibilités pour traiter ce problème de représentation d’un environnement <span style="font-style:italic">récursif</span>.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Utiliser une structure de liste qui permet à l’environnement capturé lors de la cloture de la lambda de boucler sur lui-même
La matérialisation de cette boucle ne peut à ma connaissance qu’être réalisée par un type liste <span style="font-style:italic">mutable</span>.<p>Comment construire un environnement qui contient la fonction que l’on est en train de définir ?
</p><pre class="verbatim">envRec =  (fac, &lt;lambda corps&gt;, envRec) :: env 
</pre><p>
C’est une équation de point fixe…</p><p>On remarquera également que le <code class="verb">letrec</code> de SCHEME peut être sémantiquement remplacé par un <code class="verb">let</code> associé de <code class="verb">set!</code>
Et de la même manière, nous pouvons faire cette opération en ML, avec l’unique nuance est que le <code class="verb">let</code> temporaire représente bien
une fonction pour que la cohérence des types soit assurée.</p><pre class="verbatim">SCHEME
(letrec ((f e))
  corps)
  ==&gt;
 (let ((f 'any))
    (let ((f-aux e))
       (set! f f-aux)
       corps))

(let ((fact 'any))
      (let ((f-aux (lambda (n) (if (eq? n 0) 1 (* n (fact (- n 1)))))))
        (set! fact f-aux))
  (fact 5))

OCAML 
let fact = ref (function x -&gt; x) in
 let aux n = if n=0 then 1 else n * !fact (n - 1) in
  fact:= aux ; !fact 5
</pre></li><li class="li-enumerate">Dans le cas de fonction récursive, ne plus nous reposer sur l’environnement mais, comme en λ-calcul, 
utiliser un combinateur de point fixe qui permet de calculer le point fixe de notre fonction, sans avoir à la nommer.<p>Nous allons utiliser ce procédé dans l’implémentation ML de notre interprète Scheme.</p><p>Nous rappelons ci-dessous un exemple de combinateur implémenté en SCHEME, et comment il peut être utilisé.
</p><pre class="verbatim">(define Y
(lambda(f)
 (let ((g (lambda (h) (lambda(x) ((f (h h) x))))))
  (g g))))

(define F*
  (lambda (f)
    (lambda (n)
      (if (eq? n 0)
          1
          (* n (f (- n 1)))))))
          
 (define fact (Y F*))
</pre></li><li class="li-enumerate">La troisième approche est de modéliser l’environnement par une fonction, et non plus une liste d’association.
La consultation de l’environnement consiste à appliquer la fonction <code class="verb">env</code> qui le représente.<p>Considérons l’expression <code class="verb">(letrec ((x1 e1) ... (xn en)) corps)</code> qui, on le rappelle, est équivalente à 
<code class="verb"> ((lambda (x1 ... xn) corps) e1 ... en)</code></p><p>L’environnement capturé <code class="verb">envRec</code> au moment de la définition de la lambda doit correspondre à 
l’environnement étendu aux <code class="verb">xi</code> dont les valeurs sont données par l’évaluation des <code class="verb">ei</code> de la lambda 
dans cet environnement <code class="verb">envRec</code>
C’est nécessaire afin que les <code class="verb">ei</code> puissent faire appel à des références récursives des <code class="verb">xi</code>.</p><p>Nous avons ainsi (et à nouveau) une équation de point fixe:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">  </td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >    <span style="font-style:italic">envRec</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">eval</span> (<span style="font-style:italic">e</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">envRec</span>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >    <span style="font-style:italic">envRec</span>(<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>) = <span style="font-style:italic">env</span> (<span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub>)  <span style="font-style:italic">si</span>  <span style="font-style:italic">x</span><sub><span style="font-style:italic">i</span></sub> ∉ <span style="font-style:italic">letrec</span>
</td></tr>
</table></td></tr>
</table></li></ol>
<!--TOC section id="sec34" Un interprète LISP avec le nouvel interprète MiniScheme …-->
<h2 id="sec34" class="section">2.3 Un interprète LISP avec le nouvel interprète MiniScheme …</h2><!--SEC END -->
<!--TOC subsubsection id="sec35" La mise en abyme-->
<h4 id="sec35" class="subsubsection">La mise en abyme</h4><!--SEC END --><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" > 
<div class="minipage">
<span style="font-style:italic">
Pour obtenir cet effet, suivez-moi, j’invente un personnage de romancier, que je pose en figure centrale ;
et le sujet du livre, si vous voulez, c’est précisément la lutte entre ce que lui offre la réalité et ce que,
lui, prétend en faire.</span> [<a href="#gide">7</a>]<br>
 Les Faux-monnayeurs. André Gide<br>
 
<br>
<br>

Kαὶ εἶπεν ὁ θεὸς πρὸς Μωυσῆν Ἐγώ εἰμι ὁ ὤν.<br>
 Exode 3, 14. La Septante
</div></td><td style="text-align:left;white-space:nowrap" >   </td><td style="text-align:left;white-space:nowrap" ><div class="minipage">
<blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
<img src="document002.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 2.1: Gumpp</td></tr>
</table></div>
<div class="center"><hr class="floatrule"></div></div></blockquote></div>
</td></tr>
</table>
<!--TOC subsubsection id="sec36" LISP mis en abyme-->
<h4 id="sec36" class="subsubsection">LISP mis en abyme</h4><!--SEC END --><p> 
C’est ici un exercice assez classique.
Nous avons fait le choix d’un interprète avec liaison dynamique.
Nous aurons ainsi l’évaluation suivante retournant 13 et non 10.
</p><pre class="verbatim"> ((evaluate  
 '(let ((a 1))
   (let ((f (lambda (b) (+ b a)))) 
   (let ((a 3)) (f 10)))
 )) env)
</pre><p>
En outre, il n’est pas nécessaire d’avoir un mécanisme de point fixe ou d’environnement récursif pour
l’appel d’une fonction récusrsive. C’est l’un des avantages de la liaison dynamique.
</p><pre class="verbatim">((evaluate
 '(let ((fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1)))))))
   (fact 6)))
 env)
</pre>
<!--TOC section id="sec37" L’auto-interprétation de l’interprète-->
<h2 id="sec37" class="section">2.4 L’auto-interprétation de l’interprète</h2><!--SEC END --><p>
En rendant explicite la procédure <code class="verb">eval</code> et ses acolytes <code class="verb">evlis, invoke, ...</code> dans l’environnement
<code class="verb">env</code> , la procédure <code class="verb">evaluate</code> pourra être évaluée par elle-même. Le premier argument évalué de la fonction
est le symbole <code class="verb">env</code>. Ce symbole devra être contenu dans l’environnement <code class="verb">env</code>, c’est-à-dire dans lui-même…</p><p>Nous avons <code class="verb">(eval '(eval '</code>π <code class="verb"> env) env)</code> ≡ 
<code class="verb">(evaluate '</code>π <code class="verb"> env)</code> </p>
<!--TOC subsection id="sec38" La tour de Babel-->
<h3 id="sec38" class="subsection">2.4.1 La tour de Babel</h3><!--SEC END --><p>estun=[-&gt;,&gt;=latex]
[estun] (-1.5,4.9) to [bend right] (-2, 5.3) to[bend right] (-2.5, 5) ;
(-3, 0) node[above right]<code class="verb">eval.&lt;proc&gt;</code>–(-0.5,0)–(-0.5,5)–(-3,5)
node[below right]<code class="verb">env. #env</code> –(-3,0) ;
at (-3,2) [right]<code class="verb">evlis.&lt;proc&gt;</code> ;</p><p>(-3.5,-1)– node[above]<span style="color:red"><span style="font-style:italic">SCHEME</span></span> (6.5,-1) – (6.5,-0.5) – (-3.5,-0.5) –(-3.5,-1) ;
	(0,0)–node[above]<span style="color:red"><span style="font-style:italic">I</span></span><sub>0</sub> (6,0) – (6,1) node[below right]<code class="verb">(eval </code>′π<code class="verb"> env)</code>– (0,1) – (0,0) ;
	(0.5,1)–node[above]<span style="color:red"><span style="font-style:italic">I</span></span><sub>1</sub>(5.5,1) – (5.5,2) node[below right]<code class="verb">(eval '(eval </code>′π<code class="verb"> env) env)</code> – (0.5,2) –(0.5,1) ;
	(1,2)–node[above]<span style="color:red"><span style="font-style:italic">I</span></span><sub>2</sub>(5,2) – (5,3) node[below right]<code class="verb">(eval '(eval '(eval </code>′π<code class="verb"> env) env) env)</code> – (1,3) –(1,2) ;
	(1.5,3)–node[above]<span style="color:red"><span style="font-style:italic">I</span></span><sub>3</sub>(4.5,3) – (4.5,4) node[below right]<code class="verb">(eval '(eval '(eval '(eval </code>′π<code class="verb"> env) env) env) env)</code>– (1.5,4) –(1.5,3) ;
(2,4)– node[above]<span style="color:red"><span style="font-style:italic">I</span></span><sub>4</sub> (4,4) – (4,5) node[below right]… – (2,5) –(2,4) ;
(2,4)– node[above]<span style="color:red"><span style="font-style:italic">I</span></span><sub>4</sub> (4,4) – (4,5) node[below right]… – (2,5) –(2,4) ;
at (3,5.4) ⋮ ;
at (3,5.8) <span style="color:red"><span style="font-style:italic">I</span></span><sub>∞</sub> ;</p><pre class="verbatim"> ((evaluate (quote ((evaluate (quote ((evaluate (quote ((evaluate (quote (
  (lambda (x y) (+ x y)) (fact 5) (fact 6) )))
       env))) env))) env))) env)
</pre>
<!--TOC subsubsection id="sec39" L’environnement-->
<h4 id="sec39" class="subsubsection">L’environnement</h4><!--SEC END --><p>
L’environnement doit contenir la valeur du symbole <code class="verb">env</code>. Il doit faire référence à lui-même.
Seule une liste mutable peut modéliser cette boucle infinie. 
</p><pre class="verbatim">&gt; env ; affichage de l'environnement récursif avec DrRacket
#0=((env . #0#)
    (not . #&lt;procedure:...interpreter2.scm:15:17&gt;)
    (= . #&lt;procedure:...interpreter2.scm:16:15&gt;)
    (* . #&lt;procedure:...interpreter2.scm:17:17&gt;)
    (- . #&lt;procedure:...interpreter2.scm:18:17&gt;)
    (+ . #&lt;procedure:...interpreter2.scm:19:17&gt;)
    (atom? . #&lt;procedure:...interpreter2.scm:20:19&gt;)
    (boolean? . #&lt;procedure:...interpreter2.scm:21:22&gt;)
    (number? . #&lt;procedure:...interpreter2.scm:22:21&gt;)
    (cons . #&lt;procedure:...interpreter2.scm:23:18&gt;)
    (car . #&lt;procedure:...interpreter2.scm:24:17&gt;)
    (cdr . #&lt;procedure:...interpreter2.scm:25:17&gt;)
    (pair? . #&lt;procedure:...interpreter2.scm:34:19&gt;)
    (apply . #&lt;procedure:...interpreter2.scm:36:22&gt;)
    (fact . #&lt;procedure:...interpreter2.scm:46:20&gt;)
    (lookup . #&lt;procedure:...interpreter2.scm:53:21&gt;)
    (eprogn . #&lt;procedure:...interpreter2.scm:63:21&gt;)
    (evlis . #&lt;procedure:...interpreter2.scm:74:20&gt;)
    (invoke . #&lt;procedure:...interpreter2.scm:85:14&gt;)
    (extend . #&lt;procedure:...interpreter2.scm:94:18&gt;)
    (mapcar . #&lt;procedure:...interpreter2.scm:105:18&gt;)
    (mapcadr . #&lt;procedure:...interpreter2.scm:113:19&gt;)
    (evallet . #&lt;procedure:...interpreter2.scm:121:6&gt;)
    (evaluate . #&lt;procedure:...interpreter2.scm:128:16&gt;))
</pre>
<!--TOC subsection id="sec40" Réification et réflexion-->
<h3 id="sec40" class="subsection">2.4.2 Réification et réflexion</h3><!--SEC END --><p>
La <span style="font-style:italic">réification</span> est le fait de rendre concrète une chose abstraite.
Dans le cas de notre tour de Babel, réifier un objet du langage d’implémentation le rendra accessible au langage implémenté.
On peut citer l’exemple de la fonction <code class="verb">eval</code> rendant accessible dans Scheme le process d’évaluation. 
<code class="verb">(eval '</code>π <code class="verb">) = </code> π</p><p>L’autre exemple que nous implémenterons est la réification de la continuation courante, mis à disposition
par la fonction <code class="verb">call/cc</code>. Cette fonction prend en argument une lambda avec un seul paramètre qui récupère la
continuation courante de l’expression en cours d’évaluation.
</p><pre class="verbatim">E = (e1 e2 ... (call/cc (lambda (k) ei)) ... en) 
</pre><p>
Si <code class="verb">ei</code> ne fait pas appel à <code class="verb">k</code>, alors <code class="verb">ei</code> est évaluée normalement, ainsi que <code class="verb">E</code>. 
Dans le cas contraire, <code class="verb">k</code> est appelée, liée à la continuation courante. Le résultat de <code class="verb">ei</code> est ainsi rendue
à cette continuation capturée <code class="verb">(e1 ... [] ... en)</code>. Autrement écrit <code class="verb">k = (lambda(v) (e1 ... v ... en))</code>
</p><pre class="verbatim">(+ 5 (call/cc (lambda (k) (* 2 (k 8)))))  = 12
</pre><p>L’environnement <code class="verb">global-env</code> partagé avec les différents interprètes <span style="color:red"><span style="font-style:italic">I</span></span><sub><span style="font-style:italic">i</span></sub> de notre tour de babel est aussi considéré
comme un environnement réifié. L’environnement du langage d’implémentation est ici mis à disposition aux langages implémentés.</p><p>La <span style="font-style:italic">réflection</span> peut être vue comme l’opération inverse de la réification.
Elle permet la mise à disposition dans le langage d’implémentation un objet du langage implémenté.
Comme exemple, citons la fonction <code class="verb">quote</code> qui n’évalue pas son argument et le rend tel quel. <code class="verb">quote</code> est
une primitive du langage Scheme dans le 
sens où il n’est pas possible de redéfinir cette fonction avec les autre éléments du langage.
Avec l’implémentation de l’interprète <span style="color:red"><span style="font-style:italic">I</span></span><sub><span style="font-style:italic">R</span></sub> permettant les opérations de réflection et réification,
cela deviendra possible. </p><p>Pour faire court, la réflection est une opération d’abstraction ; la réification est l’application d’une abstraction.
Ce sont ainsi deux opérations réciproques. 
Voici ce que nous donne pour information la définition du terme <span style="font-style:italic">abstraction</span> recherché dans notre dictionnaire.
</p><div class="theorem"><span style="font-weight:bold">Définition ‍6</span> <em>
L’abstraction désigne le produit de l’opération qui consiste à isoler par la pensée une ou plusieurs qualités d’un objet
concret pour en former une représentation intellectuelle</em></div><p><br>
</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >réification</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >program vers data</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><code class="verb">((reifier-to-cloture proc) (cdr e) r k)</code> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >réflection</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >data vers program</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><code class="verb">(cloture-to-reifier (lambda (e r k) exp))</code> </td></tr>
</table>
<!--TOC subsubsection id="sec41" L’interprète par continuation -->
<h4 id="sec41" class="subsubsection">L’interprète par continuation </h4><!--SEC END --><p>
La fonction d’évaluation sera enrichie pour prendre trois arguments, le programme π à évaluer, l’environnement 
ρ et la continuation κ 
</p><div class="center">
<code class="verb">(eval</code> π ρ κ <code class="verb">)</code> D   <code class="verb">valeur</code>
</div><p>Nous reprenons ici le code de l’excellent article <span style="font-style:italic">a Simple Reflective Interpreter</span> [<a href="#reflective">18</a>]
La fonction <code class="verb">evaluate</code> implémente un interprète Lisp en mode CPS de manière très naturelle.
La valeur ajoutée de l’article est la modélisation des fonctions. Trois types sont disponibles et 
distinguées par un tag dans l’environnement.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Les fonctions utilisateurs <code class="verb">(cloture (parl) exp env)</code>
</li><li class="li-enumerate">Les fonctions réifiées <code class="verb">(reifier (e r k ) exp )</code>
</li><li class="li-enumerate">Les fonctions primitives <code class="verb">(primitive nom )</code>
</li></ol><p>
L’application d’une fonction utilisateur se fait de manière classique par une évaluation du corps
de la lambda sur un environnement étendu aux nouvelles liaisons entre paramètres et arguments préalablement évalués.</p><p>Une fonction réifiée prend trois paramètres <code class="verb">e</code>, <code class="verb">r</code> et <code class="verb">k</code>.
</p><ul class="itemize"><li class="li-itemize">
<code class="verb">e</code> est lié à la liste des arguments non évalués de l’application.
</li><li class="li-itemize"><code class="verb">r</code> est lié à l’environnement de l’interprète évaluant l’application.
</li><li class="li-itemize"><code class="verb">k</code> est lié à la continuation de l’interprète évaluant l’application.
</li></ul><p>
Ainsi, nous avons un contrôle <span style="font-style:italic">complet</span> de la fonction réifiée : contrôle du corps de la fonction et des arguments
non encore évalués par l’interprète sous-jacent, mais aussi la possibilité d’accéder à l’environnement et à la continuation
courante. En bref, no limit, on peut tout définir…</p><p>Les fonctions <code class="verb">callcc</code> et <code class="verb">quote</code> seront très simplement codées de la manière suivante:
</p><pre class="verbatim">(define callcc (cloture-to-reifier (lambda (e r k) ((evaluate (car e) r id) k))))
(define quote (cloture-to-reifier (lambda (e r k) (k (car e) ))))
</pre><p>Dès le niveau 1 de notre tour, c’est-à-dire lorsque la fonction <code class="verb">evaluate</code> n’est plus évaluée par Scheme 
mais par elle-même, les formes spéciales <code class="verb">if, quote, begin, define</code> sont représentées par des fonctions réifiées.
La fonction d’évaluation peut ainsi être réduite à son strict minimum :
</p><pre class="verbatim">(define evaluate
  (lambda (e r k)
    ((if (pair? e)
        (if (equal? (car e) 'lambda)
            eval-abstraction
            eval-application)
        (if (or (or (number? e) (string? e)) (boolean? e))
            eval-constante
            eval-variable))  
     e r k )))
</pre><div class="minipage">
La fonction <code class="verb">openloop</code> peut être lancée à volonté et peut créer une succession 
de nouveaux étages dans notre tour de babel.
Comme dans l’épisode biblique du livre de la Genèse[<a href="#genese">1</a>], 
la faculté d’avoir un langage commun permet la construction
d’une tour de hauteur potentiellement infinie.
Nous nous retrouvons nous-même grisés par cette tour <span style="font-style:italic">dont la tête touche les cieux</span>
(ἡ κεφαλὴ ἔσται ἕως τοῦ οὐρανοῦ). Nous citons ici la Septante (LXX).<p>L’enthousiasme de pouvoir
monter dans les étages doit cependant être tempéré. Le fait d’être à l’étage 
<span style="font-style:italic">n</span>+1 n’apporte rien par rapport à l’étage <span style="font-style:italic">n</span>. L’application <code class="verb">eval</code> est idempotente car 
∀ π <code class="verb">(eval '</code>π<code class="verb">)</code> = <code class="verb">(eval (eval '</code> π<code class="verb">))</code>.
Autrement dit, la valeur <code class="verb">(eval'</code>π<code class="verb">)</code> est un point fixe de <code class="verb">eval</code>.</p></div><div class="minipage">
<blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
<img src="document003.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 2.2: Bruegel</td></tr>
</table></div>
<div class="center"><hr class="floatrule"></div></div></blockquote></div><p><br>
</p><p>ΓΕΝΕΣΙΣ 11 <br>
 1. Καὶ ἦν πᾶσα ἡ γῆ χεῖλος ἕν, καὶ φωνὴ μία πᾶσιν. <br>
 (...) <br>
 9. διὰ τοῦτο ἐκλήθη τὸ ὄνομα αὐτῆς Σύγχυσις, ὅτι ἐκεῖ συνέχεεν κύριος τὰ χείλη πάσης τῆς γῆς.

<span style="font-style:italic">Toute la terre avait alors une même parole ; il y avait une seule langue pour tous. <br>
 À cause de cela, ce lieu fut appelé Babel (confusion), parce que là le Seigneur confondit les langues de toute la terre.
</span></p><p>
En pratique, malheureusement dès le niveau 3 de notre tour, les temps d’évaluation deviennent abominablement longs sur 
notre interprète maison implémenté en OCAML.
Plusieurs minutes sont requises pour le calcul de la factorielle de cinq au niveau 3 de la tour.
C’est un peux plus rapide avec DrRacket, mais pas tellement. Le poids des sous-couches d’interprétation est lourd.
Dieu ne nous disperse pas ici par la confusion des langages, mais par la limitation de notre puissance de calcul .</p><p>Voici le code complet de l’interprète au niveau 1. La fonction d’évaluation n’utilise pas ici
les réifications des fonctions <code class="verb">if, quote, begin</code>.</p><pre class="verbatim"><span style="font-size:small">(define evaluate
  (lambda (e r k)
    ((if (not (pair? e))
          (if (or (or (number? e) (string? e)) (boolean? e))
              eval-constante
              eval-variable)
          (if (equal? (car e) 'quote)
              eval-quote
              (if (equal? (car e) 'if)
               eval-if
                (if (equal? (car e) 'begin)
               eval-begin
               (if (equal? (car e) 'define)
                   eval-assign
                   (if (equal? (car e) 'lambda)
                       eval-abstraction
                       eval-application))))))
     e r k )))

(define eval-constante
  (lambda (e r k)
    (k e)))

(define eval-quote
  (lambda (e r k)
    (k (cadr e))))

(define eval-variable
  (lambda (e r k)
   (get-pair e r
   (lambda (success-pair)
    (k (cdr success-pair)))
    (lambda ()
    (wrong "symbol not bound " e)))))

(define eval-if
  (lambda (e r k)
    (evaluate (cadr e) r
              (lambda (v)
                (if v
                    (evaluate (caddr e) r k)
                    (evaluate (cadddr e) r k))))))

(define eval-assign
     (lambda (e r k)
       (evaluate (caddr e) r
                 (lambda (v)
                   (get-pair (cadr e) r
                             (lambda (success-pair)
                               (begin
                               (set-cdr! success-pair v)
                               (k (void)) ))
                             (lambda ()
                               (begin
                              (set-cdr! global-env (cons (car global-env)(cdr global-env)))
                              (set-car! global-env (cons (cadr e) v))
                              (k (void)))))))))

(define eval-define
  (lambda (e r k)
      (evaluate (caddr e) r
   (lambda (v) 
   (update! (cadr e) r v))))) 

(define eval-abstraction
  (lambda (e r k)
  (k (make-function (cadr e) (caddr e) r))))
     
(define get-pair
  (lambda (id r success failure)
    (find-pair id r
               success
               (lambda ()
                 (find-pair
                    id global-env success failure) )) ))

(define find-pair
  (lambda (elt alist success failure)
    ( (lambda (assq-result)
        (if assq-result
            (success assq-result)
            (failure)) )
      (assq elt alist) ) ) )

(define make-function
  (lambda (varl corps r)
     (list 'cloture varl corps r)))

(define eval-application
  (lambda (e r k)
       (evaluate (car e) r
              (lambda (proc)
                (if (equal? (car proc) 'reifier)
                    ((reifier-to-cloture proc) (cdr e) r k)
                    (evlis (cdr e) r
                       (lambda (args)
                         (apply-procedure proc args k))))))))

(define evlis
  (lambda (e r k)
    (if (null? e)
        (k '())
        (evaluate (car e) r
                  (lambda (v)
                    (evlis (cdr e) r
                           (lambda (w)
                            (k (cons v w)))))))))

(define eval-begin
  (lambda (e r k)
    (eprogn (cdr e) r k)))

(define eprogn
  (lambda (e r k)
   (if (null? (cdr e))
       (evaluate (car e) r k)
       (evaluate (car e) r (lambda (v)
                             (eprogn (cdr e) r k))))))

(define extend
  (lambda (env variables values)
        (if (or (null? variables) (null? values))
            env
            (cons (cons (car variables) (car values))
                  (extend env (cdr variables) (cdr values))))))
         
(define apply-procedure
  (lambda (proc args k)
    (if (equal? (car proc) 'cloture)
        (eprogn (list (caddr proc))
                (extend (cadddr proc) (cadr proc) args)
                k)
        (k (apply-primitive (cadr proc) args))))) 

(define apply-primitive
  (lambda (name args)
    (if (equal? name 'car)
        (car (car args))
     (if (equal? name 'or)
        (or (car args) (cadr args))
    (if (equal? name 'cdr)
        (cdr (car args))
    (if (equal? name 'cons)
        (cons (car args) (cadr args))
    (if (equal? name 'set-car!)
        (set-car! (car args) (cadr args))
    (if (equal? name 'set-cdr!)
        (set-cdr! (car args) (cadr args))
    (if (equal? name 'memq)
        (memq (car args) (cadr args))
    (if (equal? name 'assq)
        (assq (car args) (cadr args))    
    (if (equal? name '=)
        (= (car args) (cadr args))
    (if (equal? name '+)
        (+ (car args) (cadr args))
    (if (equal? name '-)
        (- (car args) (cadr args))
    (if (equal? name '*)
        (* (car args) (cadr args))
    (if (equal? name 'null?)
        (null? (car args))
    (if (equal? name 'not)
        (not (car args))    
    (if (equal? name 'symbol?)
        (symbol? (car args))
    (if (equal? name 'list)
        args
    (if (equal? name 'pair?)
        (pair? (car args))
    (if (equal? name 'read)
        (if (null? args) (read) (read (car args)))
    (if (equal? name 'eof-object?)
        (eof-object? (car args))
    (if (equal? name 'close-input-port)
        (close-input-port (car args))
    (if (equal? name 'newline)
        (newline)
    (if (equal? name 'equal?)
        (equal? (car args) (cadr args)) 
    (if (equal? name 'write)
        (write (car args))
    (if (equal? name 'display)
        (display (car args))
    (if (equal? name 'load)
        (load (car args)) 
    (if (equal? name 'number?)
        (number? (car args))   
    (if (equal? name 'string?)
        (string? (car args))   
    (if (equal? name 'boolean?)
        (boolean? (car args))   
     "erreur apply primitive"))))))))))))))))))))))))))))))

(define mapper
  (lambda (f l)
    (if (null? l)
        '()
        (cons (f (car l)) (mapper f (cdr l))))))

(define primitive-identifiers
  (lambda ()
    '(placeholder car cdr cons + - * = set-car! set-cdr! memq assq null? equal? newline  
      display read symbol? list pair? not load or number? string? boolean?)))

(define make-primitive
  (lambda (op)
    (list 'primitive op)))

(define reifier-to-cloture
  (lambda (reifier)
    (cons 'cloture (cdr reifier))))

(define cloture-to-reifier
  (lambda (cloture)
    (cons 'reifier (cdr cloture))))

(define make-reifier
  (lambda (formals body r)
    (list 'reifier formals body r)))

(define global-env '())

(define initialize-global-env
  (lambda ()
     (define global-env
      (extend global-env 
          (primitive-identifiers)
          (mapper make-primitive
                  (primitive-identifiers)))))) 

(define openloop
  (lambda (read-prompt write-prompt)
    (begin 
    (display read-prompt)
    (evaluate (read) '()
              (lambda (v)
                (begin
                (display write-prompt)
                (if (equal? v (void))
                  "rien a afficher"
                  (display v))
                (newline)
                (openloop read-prompt write-prompt)))))))

(define babel
  (lambda ()
       (begin
       (set-car! global-env (cons 'global-env global-env ))
       (openloop "i0 " "i0 "))))
</span></pre>
<!--TOC chapter id="sec42" La compilation-->
<h1 id="sec42" class="chapter">Chapitre ‍3 La compilation</h1><!--SEC END -->
<!--TOC section id="sec43" Compilation des λ-termes en termes applicatifs-->
<h2 id="sec43" class="section">3.1 Compilation des λ-termes en termes applicatifs</h2><!--SEC END --><p>
Il existe un formalisme appelé <span style="font-style:italic">Logique Combinatoire</span> qui permet de construire
un calcul sans variables liées. 
C’est surprenant, mais ces variables liées qui sont introduites par abstraction puis éliminées par application
ne sont finalement pas essentielles pour le calcul.</p><p>Comment traduire une abstraction en termes applicatifs ? 
Nous allons définir une traduction <span style="font-style:italic">M</span>↦ <span style="font-style:italic">M</span><sub>@</sub> , ainsi qu’une traduction en sens inverse
<span style="font-style:italic">A</span>↦ <span style="font-style:italic">A</span><sub>λ</sub>.</p><p>L’idée est de partir sur les règles de traduction suivantes :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >	⌈ λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span> ⌉</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">I</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	⌈ λ <span style="font-style:italic">x</span> . <span style="font-style:italic">M</span> ⌉</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">K</span> <span style="font-style:italic">M</span>   (<span style="font-style:italic">x</span> ∉ <span style="font-style:italic">M</span>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	⌈ λ <span style="font-style:italic">x</span> . <span style="font-style:italic">M</span> <span style="font-style:italic">N</span> ⌉</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">S</span> ⌈ λ <span style="font-style:italic">x</span> . <span style="font-style:italic">M</span> ⌉ ⌈ λ <span style="font-style:italic">x</span> . <span style="font-style:italic">N</span> ⌉   (<span style="font-style:italic">x</span> ∈ <span style="font-style:italic">M</span>,<span style="font-style:italic">N</span>) </td></tr>
</table></td></tr>
</table><p>
où  ⌈ <span style="font-style:italic">T</span> ⌉ représente le λ-terme <span style="font-style:italic">T</span> sans lambda abstraction. </p><p>Nous serions tentés de vouloir faire directement la traduction en utilisant ces règles.
Il nous faut cependant passer par un opérateur d’abstraction <span style="font-style:italic">A</span> ↦ [<span style="font-style:italic">x</span>].<span style="font-style:italic">A</span> qui permettra de "supprimer" toutes 
les lambdas en profondeur dans le λ-terme, puis seulement ensuite, nous pourrons utiliser les trois règles ci-dessous:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >	[<span style="font-style:italic">x</span>]  . <span style="font-style:italic">x</span></td><td style="text-align:center;white-space:nowrap" >≡</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">I</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	[<span style="font-style:italic">x</span>] .  <span style="font-style:italic">A</span></td><td style="text-align:center;white-space:nowrap" >≡</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">K</span> <span style="font-style:italic">A</span>   (<span style="font-style:italic">x</span> ∉ <span style="font-style:italic">A</span>) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	[<span style="font-style:italic">x</span>]  . <span style="font-style:italic">A</span> <span style="font-style:italic">B</span></td><td style="text-align:center;white-space:nowrap" >≡</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">S</span> ([<span style="font-style:italic">x</span>] . <span style="font-style:italic">A</span>)([<span style="font-style:italic">x</span>] . <span style="font-style:italic">B</span>)    (<span style="font-style:italic">x</span> ∈ <span style="font-style:italic">A</span>,<span style="font-style:italic">B</span>) </td></tr>
</table></td></tr>
</table><p>Les combinateurs <span style="font-style:italic">I</span>, <span style="font-style:italic">K</span> et <span style="font-style:italic">S</span> sont définis comme ceci:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >	<span style="font-style:italic">I</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" >λ <span style="font-style:italic">x</span> . <span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >	<span style="font-style:italic">K</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" >λ <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> . <span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >	<span style="font-style:italic">S</span></td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" >λ <span style="font-style:italic">x</span> <span style="font-style:italic">y</span> <span style="font-style:italic">z</span> . <span style="font-style:italic">x</span> <span style="font-style:italic">z</span> (<span style="font-style:italic">y</span> <span style="font-style:italic">z</span>) </td></tr>
</table></td><td class="dcell">	
</td></tr>
</table><p>Et voici la définition de la traduction des λ-termes en termes applicatifs.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >	 (<span style="font-style:italic">x</span>)<sub>@</sub></td><td style="text-align:center;white-space:nowrap" >≡</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	(<span style="font-style:italic">PQ</span>)<sub>@</sub></td><td style="text-align:center;white-space:nowrap" >≡</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">P</span>)<sub>@</sub> (<span style="font-style:italic">Q</span>)<sub>@</sub> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	(λ <span style="font-style:italic">x</span>.<span style="font-style:italic">M</span>)<sub>@</sub></td><td style="text-align:center;white-space:nowrap" >≡</td><td style="text-align:left;white-space:nowrap" >[<span style="font-style:italic">x</span>] .(<span style="font-style:italic">M</span>)<sub>@</sub>   </td></tr>
</table></td></tr>
</table><p>Dans la définition de notre type applicatif <code class="verb">ski</code>, nous incluons aussi notre opérateur [<span style="font-style:italic">x</span>].<span style="font-style:italic">A</span> 
avec le constructeur <code class="verb">Op</code>.</p><pre class="verbatim">type ski = 
| Varia of string
| I
| K
| S
| Appl of ski*ski 
| Op of string * ski ;;

exception SkiExec

let rec lambda_ski = function
| Lam(x, t) -&gt; lambda_ski_op (Op(x, lambda_ski t))
| Var(x) -&gt; Varia(x)
| App(m,n) -&gt; Appl(lambda_ski m, lambda_ski n) 
and lambda_ski_op = function
| Op(x,Varia y) when x=y -&gt; I 
| Op(x, t) when not (mem x (var t)) -&gt; Appl(K, t) 
| Op(x, Appl(m, n))  when (mem x (var m)) || (mem x (var n)) 
   -&gt; Appl(Appl(S, (lambda_ski_op (Op(x,m)))), (lambda_ski_op (Op(x,n)))) 
| _ -&gt; raise SkiErreur
</pre><p>
A titre d’exemple, traduisons notre combinateur <span style="font-style:italic">y</span> en termes applicatifs:
</p><pre class="verbatim">utop # print_ski (lambda_ski y) ;;
((S((S((S(KS))((S(KK))I)))(K((SI)I))))((S((S(KS))((S(KK))I)))(K((SI)I))))
</pre><p>
Une fois le code compilé, son exécution sera réalisée avec les règles de réécriture :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >	<span style="font-style:italic">Ix</span></td><td style="text-align:center;white-space:nowrap" >—→</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >	<span style="font-style:italic">Kxy</span></td><td style="text-align:center;white-space:nowrap" >—→</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >	<span style="font-style:italic">Sxyz</span></td><td style="text-align:center;white-space:nowrap" >—→</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">x</span> <span style="font-style:italic">z</span> (<span style="font-style:italic">y</span> <span style="font-style:italic">z</span>)	</td></tr>
</table></td><td class="dcell">	
</td></tr>
</table><p>
Voici une première version de l’exécution de ces règles de réécriture. Ce code un est peu bourrin car on appelle
la fonction tant que le terme n’est pas réduit.
</p><pre class="verbatim">let rec exec_aux = function
| Appl(I, x) -&gt; exec_aux x
| Appl(Appl(K, x), y) -&gt; exec_aux x
| Appl(Appl(Appl(S,x),y),z) -&gt; Appl(Appl(exec_aux x, exec_aux z), Appl(exec_aux y,exec_aux z))
| Appl(x,y) -&gt; Appl(exec_aux x, exec_aux y)
| Varia x -&gt; Varia x
| I -&gt; I
| K -&gt; K
| S -&gt; S
| _ -&gt; raise SkiErreur 
and  exec t =
let r = exec_aux t in
 if r=t then r else exec_aux r 
</pre><p>Voici une version plus élégante qui retourne la forme réduite.
</p><pre class="verbatim">let rec ski_norm m =
match m with
| S | K | I -&gt; m
| Varia x -&gt; m
| Appl (m0, m1) -&gt;
match ski_norm m0 with
| I -&gt; ski_norm m1
| Appl (K, m') -&gt; m'
| Appl (Appl (S, m3), m2) -&gt; ski_norm (Appl (Appl (m3, m1), Appl (m2, m1)))
| autre -&gt; Appl (autre, ski_norm m1);;
</pre><p>La traduction en sens inverse <span style="font-style:italic">A</span> ↦ <span style="font-style:italic">A</span><sub>λ</sub> se fait naturellement par la fonction ML ci-dessous:
</p><pre class="verbatim">let rec ski_lambda = function
| I -&gt; Lam("x", Var "x")
| K -&gt; Lam("x", Lam("y", Var "x"))
| S -&gt; Lam("x", Lam("y", Lam("z", App(App(Var "x", Var "z"), App(Var "y", Var "z")))))
| Varia(x) -&gt; Var(x)
| Appl(m,n) -&gt; App(ski_lambda m,ski_lambda n)
| _ -&gt; raise SkiErreur
</pre><p>Utilisons l’exemple de la factorielle, exemple complexe car il comporte les représentations en λ-termes
du combinateur <span style="font-style:italic">Y</span>, de la condition <span style="font-style:italic">if-then-else</span>, des entiers <span style="font-style:italic">Church</span> ainsi que les opérations
<span style="font-style:italic">plus, moins, mult</span>.<sup><a id="text4" href="#note4">1</a></sup>
</p><pre class="verbatim">print_terme (betaNormal (ski_lambda (exec (lambda_ski (App(fact, trois)))))) ;;
λz.λz0.z (z (z (z (z (z z0) ) ) ) ) - : unit = () 
</pre><p>Nous avons les deux propriétés suivantes que nous ne démontrerons pas.
</p><ol class="enumerate" type=1><li class="li-enumerate">
	Si <span style="font-style:italic">A</span> *—→<sub>β</sub> <span style="font-style:italic">B</span>, alors <span style="font-style:italic">A</span><sub>λ</sub>*—→<sub>β</sub> <span style="font-style:italic">B</span><sub>λ</sub> <br>
	</li><li class="li-enumerate">(<span style="font-style:italic">M</span><sub>@</sub>)<sub>λ</sub>*—→<sub>β</sub> <span style="font-style:italic">M</span>  <br>
</li></ol><p>Cependant, nous aurons parfois <span style="font-style:italic">M</span> —→<sub>β</sub><span style="font-style:italic">N</span> sans que <span style="font-style:italic">M</span><sub>@</sub> —→<sub>@</sub> <span style="font-style:italic">N</span><sub>@</sub></p><p>Par exemple <span style="font-style:italic">SK</span> *—→<sub>β</sub> 0 mais <span style="font-style:italic">SK</span> est irréductible pour —→<sub>@</sub>
</p><pre class="verbatim">utop # betaNormalPrint sk ;;
[1] -&gt; λx.λy.λz.x z (y z)  λx.λy.x
[2] -&gt; λy.λz.λx.λy.x z (y z) 
[3] -&gt; λy.λz.λy.z (y z) 
[4] -&gt; λy.λz.z
- : unit -&gt; unit = &lt;fun&gt; 

utop # exec (Appl(S,K)) ;;
- : ski = Appl (S, K)
</pre><p>D’autre part, on n’a pas nécessairement (<span style="font-style:italic">A</span><sub>λ</sub>)<sub>@</sub> =<sub>@</sub> <span style="font-style:italic">A</span>.</p><p>Par exemple (<span style="font-style:italic">K</span><sub>λ</sub>)<sub>@</sub> ≡ <span style="font-style:italic">S</span>(<span style="font-style:italic">KK</span>)<span style="font-style:italic">I</span> ne se réduit pas en <span style="font-style:italic">K</span>.
</p><pre class="verbatim">utop # exec (lambda_ski k) ;;
- : ski = Appl (Appl (S, Appl (K, K)), I)

betaNormalPrint (App(App(s, App (k, k)), i)) ;;
[1] -&gt; λx.λy.λz.x z (y z)  (λx.λy.x λx.λy.x)  λx.x
[2] -&gt; λy.λz.λx.λy.x λx.λy.x z (y z)  λx.x
[3] -&gt; λz.λx.λy.x λx.λy.x z (λx.x z) 
[4] -&gt; λz.λy.λx.λy.x z (λx.x z) 
[5] -&gt; λz.λx.λy.x (λx.x z) 
[6] -&gt; λz.λy.λx.x z
[7] -&gt; λz.λy.z
- : unit -&gt; unit = &lt;fun&gt;
</pre><p>
On peut constater que (<span style="font-style:italic">SKK</span>)<span style="font-style:italic">x</span> *—→<sub>β</sub> <span style="font-style:italic">x</span> , donc le terme <span style="font-style:italic">SKK</span> joue le même rôle
que la constante <span style="font-style:italic">I</span>. 
</p><pre class="verbatim">let skk = Appl(Appl(S,K),K) ;;
exec (Appl(skk, Varia "x")) ;;
- : ski = Varia "x"
</pre><p>
ou plus directement en CAML:
</p><pre class="verbatim">utop # 
let k x y = x
and s x y z = (x z (y z)) 
  in (s k k) "toto ";;
- : string = "toto "
</pre><p>
La base combinatoire {<span style="font-style:italic">S</span>,<span style="font-style:italic">K</span>} suffit donc au λ-calcul. 
Une base à un seul élément existerait même…</p>
<!--TOC subsubsection id="sec44" La correspondance de Curry-Howard-->
<h4 id="sec44" class="subsubsection">La correspondance de Curry-Howard</h4><!--SEC END --><p>
Dans un λ-calcul typé, les types des combinateurs <span style="font-style:italic">K</span> et <span style="font-style:italic">S</span> correspondent aux deux axiomes
des systèmes hilbertiens :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">S</span> : (φ ⇒ (χ ⇒ ψ)) ⇒ ((φ ⇒ χ) ⇒(φ ⇒ ψ)) 
</td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">K</span> : φ ⇒ (ψ ⇒ φ)
</td></tr>
</table><p>
L’inférence de type OCAML nous donne en effet 
<code class="verb">k : 'a -&gt; 'b -&gt; 'a</code> et <br>
<code class="verb"> s : ('a -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'c</code>
</p><div class="center">
<blockquote class="figure"><div class="center"><hr class="floatrule"></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >		<span style="font-style:italic">logique combinatoire</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">système hilbertien</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >		type</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >formule </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >		application (<span style="font-weight:bold">App</span>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >modus ponens </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >		combinateurs <span style="font-style:italic">S</span> et <span style="font-style:italic">K</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >noms des axiomes <span style="font-style:italic">S</span> et <span style="font-style:italic">K</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >		type des combinateurs <span style="font-style:italic">S</span> et <span style="font-style:italic">K</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" >axiomes <span style="font-style:italic">S</span> et <span style="font-style:italic">K</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >		variable</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >nom d’une hypothèse </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >		type d’une variable</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >hypothèse </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>	
<div class="center"><hr class="floatrule"></div></blockquote>
</div><p>L’unique règle d’inférence, la règle du modus ponens, est ainsi modélisée par l’application
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(<span style="font-style:italic">App</span>) : </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">φ ⇒ ψ   φ</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">ψ</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>Dans le système hilbertien, il n’y a pas de règle d’introduction 
(<span style="font-style:italic">I</span><sub>⇒</sub>) : [φ]  χ/φ ⇒ χ qui équivalait à une abstraction 
λ <span style="font-style:italic">x</span><sup>φ</sup>.<span style="font-style:italic">y</span><sup>ψ</sup></p><p>Le modus ponens et les axiomes permettent de simuler (<span style="font-style:italic">I</span><sub>⇒</sub>) de la même façon que 
l’abstraction du λ-calcul est simulée à l’aide des constantes <span style="font-style:italic">S</span> et <span style="font-style:italic">K</span> en logique combinatoire.</p>
<!--TOC section id="sec45" Compilation basique vers une machine à pile-->
<h2 id="sec45" class="section">3.2 Compilation basique vers une machine à pile</h2><!--SEC END --><p>
Nous utilisons l’implémentation ci-dessous pour la représentation des piles sous
formes de listes mutables.
</p><pre class="verbatim">type 'a pile = 'a list ref ;;
let empiler x p = p := x :: !p ;;

exception Vide ;;

let depiler p =  
 match !p with
  | [] -&gt; raise Vide
  |x::t -&gt; p:=t ; x ;;

let sommet p =
 match !p with
 | [] -&gt; raise Vide
 | x::t -&gt; x  ;;
</pre><p>La machine à pile exécutera les instructions suivantes:<br>
<code class="verb">["EMPILER"; "nombre"],["ADD"], ["SUB"], ["MUL"], ["STOP"]</code></p><p>La lecture d’une instruction est réalisée par la fonction <span style="font-family:monospace">fetch</span>. Cette
fonction parcourt de manière linéaire le code représenté par un <span style="font-style:italic">array</span>.
Chaque <span style="font-family:monospace">fetch</span> incrémente la variable <code class="verb">pc</code> qui représente le
<span style="font-style:italic">program counter</span>.</p><pre class="verbatim">exception Erreur ;;
 
let executer code =
 let pc = ref 0 in
 let pile = ref [] in
 let fetch code  =
 begin
  pc := !pc + 1 ; 
  Array.get code (!pc - 1) 
 end 
 in
 let rec exec () =
  let instr = fetch code in
  match instr with
  | ["EMPILER"; n] -&gt; ( empiler (int_of_string n) pile ; exec () )
  | ["ADD"] -&gt; let v2 = depiler pile in let v1 = depiler pile in 
              ( empiler (v1 + v2) pile ; exec () )
  | ["SUB"] -&gt; let v2 = depiler pile in let v1 = depiler pile in
              ( empiler (v1 - v2) pile ; exec () )
  | ["MUL"] -&gt; let v2 = depiler pile in let v1 = depiler pile in
              ( empiler (v1 * v2) pile ; exec () )
  | ["STOP"] -&gt; print_int (sommet pile)
  | _ -&gt; raise Erreur
 in exec ()
</pre><p>Voici l’exécution de la machine à pile:
</p><pre class="verbatim">let code = [| ["EMPILER"; "10"] ;["EMPILER"; "15"] ; ["ADD"] ;
        ["EMPILER"; "4"] ; ["MUL"] ; ["STOP"] |] ;;
        
# executer code ;;
# 100- : unit = ()
</pre>
<!--TOC subsection id="sec46" Certification de la compilation avec le langage COQ-->
<h3 id="sec46" class="subsection">3.2.1 Certification de la compilation avec le langage COQ</h3><!--SEC END --><p>
<span style="font-style:italic">Quod erat demonstrandum.</span>
</p><div class="center">

at(0,6) <span style="font-style:italic">e</span> ;
at(6,6) <span style="font-style:italic">c</span> ;
at(6,0) <span style="font-style:italic">v</span><sub>2</sub> ;
at(0,0) <span style="font-style:italic">v</span><sub>1</sub> ;
[dashed] (0.3,0) – node[below]<span style="font-style:italic">v</span><sub>1</sub>=<span style="font-style:italic">v</span><sub>2</sub> node[above]∀ <span style="font-style:italic">e</span>, <span style="font-style:italic">eval</span>(<span style="font-style:italic">e</span>)= <span style="font-style:italic">exe</span>(<span style="font-style:italic">compile</span> <span style="font-style:italic">e</span>)(5.7,0) ;
[-latex] (6,5.7) – node[rotate=-90, below]sémantique de la machine  (6,0.3) ;
[-latex] (0.3,6) – node[below]sémantique du compilateur  (5.7,6) ;
[-latex] (0,5.7) – node[rotate=-90, above]sémantique du langage  (0,0.3);

</div><p><br>

</p><p>
Require Import Arith.Require Import ZArith.Require Import Bool.Require Import List.Inductive exp : Set :=1.00em
| Const : nat → exp1.00em
| Fois : exp → exp → exp1.00em
| Plus : exp → exp → exp.Fixpoint expEval (e:exp) : nat :=1.00em
match e with1.00em
| Const n ⇒ n1.00em
| Fois e1 e2 ⇒ mult (expEval e1) (expEval e2)1.00em
| Plus e1 e2 ⇒ plus (expEval e1) (expEval e2)1.00em
end.Inductive instr : Set :=0.50em
| EMPILER : nat → instr0.50em
| ADD : instr0.50em
| MUL : instr.Definition programme := list instr.Definition pile := list nat.Definition instrExec (i:instr) (s: pile) : option pile:=1.00em
match i with1.00em
| EMPILER n ⇒ Some (n :: s)1.00em
| ADD ⇒ 2.50em
match s with2.50em
| arg1 :: arg2 :: s’ ⇒ Some (expEval (Plus (Const(arg1)) (Const(arg2))) :: s’)2.50em
| _ ⇒ None2.50em
end1.00em
| MUL ⇒2.50em
match s with2.50em
| arg1 :: arg2 :: s’ ⇒ Some (expEval (Fois (Const(arg1)) (Const(arg2))) ::s’)2.50em
| _ ⇒ None2.50em
end1.00em
end.Fixpoint progExec (p:programme) (s:pile) : option pile :=1.00em
match p with 1.00em
| nil ⇒ Some s1.00em
| i :: p’ ⇒ 3.00em
match instrExec i s with3.00em
| None ⇒ None3.00em
| Some s’ ⇒ progExec p’ s’ 3.00em
end1.00em
end.Fixpoint compile (e:exp) : programme :=1.00em
match e with 1.00em
| Const n ⇒ EMPILER n :: nil1.00em
| Plus e1 e2 ⇒ compile e2 ++ compile e1 ++ ADD :: nil1.00em
| Fois e1 e2 ⇒ compile e2 ++ compile e1 ++ MUL :: nil1.00em
end .Eval compute in (compile (Const 1999)) .Eval compute in (compile (Fois (Plus (Const 1999) (Const 1)) (Const 5))) .Eval compute in ( progExec (compile (Fois (Plus (Const 1999) (Const 1)) (Const 5))) nil) .Lemma compile_correct_lemme: ∀ (e:exp) (p: programme) (s: pile),14.00em
progExec (compile e++p) s = progExec p (expEval e::s)0.50em
.0.50em
induction e.0.50em
intros.0.50em
unfold compile.0.50em
unfold expEval.0.50em
unfold progExec at 1.0.50em
simpl.0.50em
fold progExec.0.50em
reflexivity.0.50em
intros.0.50em
unfold compile. fold compile.0.50em
unfold expEval. fold expEval.0.50em
rewrite app_assoc_reverse.0.50em
rewrite IHe2. rewrite app_assoc_reverse.0.50em
rewrite IHe1.0.50em
unfold progExec at 1. simpl. fold progExec. reflexivity.0.50em
intros.0.50em
unfold compile. fold compile.0.50em
rewrite app_assoc_reverse. rewrite IHe2.0.50em
rewrite app_assoc_reverse.0.50em
unfold progExec at 1. simpl. fold progExec.0.50em
rewrite IHe1.0.50em
unfold progExec at 1. simpl. fold progExec. reflexivity.0.50em
Qed.Theorem compile_correct: ∀ e : exp, Some ((expEval e) :: nil) = (progExec (compile e) nil).intros.rewrite (app_nil_end (compile e)).rewrite compile_correct_lemme.reflexivity.Qed.Print compile_correct.</p>
<!--TOC section id="sec47" Compilation du LISP vers une machine abstraite-->
<h2 id="sec47" class="section">3.3 Compilation du LISP vers une machine abstraite</h2><!--SEC END -->
<!--TOC subsubsection id="sec48" La machine SECD-->
<h4 id="sec48" class="subsubsection">La machine SECD</h4><!--SEC END --><p>
La machine SECD inventée par Landin est une machine abstraite utilisant quatre composants:
</p><ul class="itemize"><li class="li-itemize">
S, la pile ou <span style="font-style:italic">stack</span> permettant de stocker les résultats intermédiaires puis le résultat final
</li><li class="li-itemize">E, l’environnement d’éxecution
</li><li class="li-itemize">C, le code
</li><li class="li-itemize">D, le dump permettant de stocker les valeurs courantes S,E,C le temps d’un calcul local d’une fonction
</li></ul><p>
Nous devons implémenter deux fonctions.</p><p>La fonction de compilation <code class="verb">compile</code> qui prend en argument une expression LISP, 
un environnement de compilation et l’accumulateur du code compilé.
Nous ferons travailler la fonction <code class="verb">compile</code> sur la syntaxe abstraite pour plus de facilité.</p><p>La fonction d’éxecution <code class="verb">exe s e c d</code> prend en arguments les 
quatre composantes de la machine abstraite.</p>
<!--TOC subsubsection id="sec49" La compilation <span style="font-style:italic">C</span>: <span style="font-style:italic">exp</span> D  <span style="font-family:monospace">code</span>-->
<h4 id="sec49" class="subsubsection">La compilation <span style="font-style:italic">C</span>: <span style="font-style:italic">exp</span> D  <span style="font-family:monospace">code</span></h4><!--SEC END --><p>
<span style="font-family:monospace">c</span> D  <span style="font-family:monospace">CONST</span>(<span style="font-style:italic">c</span>) <br>
 <span style="font-family:monospace">n</span> D  <span style="font-family:monospace">ACCESS</span>(<span style="font-style:italic">n</span>) <br>
 <span style="font-family:monospace">(+ a1 a2)</span> D  <span style="font-style:italic">C</span>(<span style="font-style:italic">a</span><sub>1</sub>); <span style="font-style:italic">C</span>(<span style="font-style:italic">a</span><sub>2</sub>); <span style="font-family:monospace">ADD</span> <br>
 <span style="font-family:monospace">(- a1 a2)</span> D  <span style="font-style:italic">C</span>(<span style="font-style:italic">a</span><sub>1</sub>); <span style="font-style:italic">C</span>(<span style="font-style:italic">a</span><sub>2</sub>); <span style="font-family:monospace">SUB</span> <br>
 <span style="font-family:monospace">(= a1 a2)</span> D  <span style="font-style:italic">C</span>(<span style="font-style:italic">a</span><sub>1</sub>); <span style="font-style:italic">C</span>(<span style="font-style:italic">a</span><sub>2</sub>); <span style="font-family:monospace">CMP</span> <br>
 <span style="font-family:monospace">((lambda (v1...vn) body) e1...en)</span> 
D  <span style="font-family:monospace">NIL;</span> <span style="font-style:italic">C</span>(<span style="font-style:italic">v</span><sub>1</sub>)<span style="font-family:monospace">;ARG;</span>… <span style="font-style:italic">C</span>(<span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub>)<span style="font-family:monospace">;ARG;CLOSURE</span>(<span style="font-style:italic">C</span>(<span style="font-style:italic">body</span>)<span style="font-family:monospace">;RTS</span>)<span style="font-family:monospace">;JSR</span> <br>
 </p>
<!--TOC subsubsection id="sec50" La table de transition de la machine SECD-->
<h4 id="sec50" class="subsubsection">La table de transition de la machine SECD</h4><!--SEC END --><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap"  colspan=4><span style="font-size:small"><span style="font-weight:bold">état avant</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap"  colspan=4><span style="font-size:small"><span style="font-weight:bold">état après</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">S</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">E</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">C</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">D</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">S</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">E</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">C</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">D</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  
</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace">CONST</span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">cst</span></span><span style="font-size:small">); </span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">cst</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace">ADD</span></span><span style="font-size:small">; </span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small"> + </span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">).</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace">SUB</span></span><span style="font-size:small">; </span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small"> − </span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">).</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace">CMP</span></span><span style="font-size:small">; </span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small"> = </span><span style="font-size:small"><span style="font-style:italic">n</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">).</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">        </span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ACCESS</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">);</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">n</span></span><span style="font-size:small">).</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap"  colspan=8><span style="font-size:small">construction d’une liste d’arguments</span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">NIL</span></span></span><span style="font-size:small">; </span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">[ ]</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">v</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">v</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ARG</span></span></span><span style="font-size:small">; </span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">v</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small"> @ </span><span style="font-size:small"><span style="font-style:italic">v</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small"> . </span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap"  colspan=8><span style="font-size:small">la conditionnelle</span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">v</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">BRANCH</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">, </span><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">);</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">;</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">v</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">BRANCH</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">, </span><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">);</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">;</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap"  colspan=8><span style="font-size:small">le traitement d’une clôture</span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">CLOSURE</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">);</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">CLOS</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">,</span><span style="font-size:small"><span style="font-style:italic">e</span></span><span style="font-size:small">)</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap"  colspan=8><span style="font-size:small">application d’une lambda avec les instructions </span><span style="font-size:small"><span style="font-family:monospace">JSR,RTS</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">CLOS</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">f</span></span><span style="font-size:small">,</span><span style="font-size:small"><span style="font-style:italic">e</span></span><sub><span style="font-size:small">0</span></sub><span style="font-size:small">).</span><span style="font-size:small"><span style="font-style:italic">largs</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">JSR</span></span></span><span style="font-size:small">;</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">[ ]</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">largs</span></span><span style="font-size:small">::</span><span style="font-size:small"><span style="font-style:italic">e</span></span><sub><span style="font-size:small">0</span></sub></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">f</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ENVEXE</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">s</span></span><span style="font-size:small">,</span><span style="font-size:small"><span style="font-style:italic">e</span></span><span style="font-size:small">,</span><span style="font-size:small"><span style="font-style:italic">c</span></span><span style="font-size:small">).</span><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small">  </span><span style="font-size:small"><span style="font-style:italic">v</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">RTS</span></span></span><span style="font-size:small">;</span><span style="font-size:small"><span style="font-style:italic">c</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-family:monospace"><span style="font-style:italic">ENVEXE</span></span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">s</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">, </span><span style="font-size:small"><span style="font-style:italic">e</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">, </span><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">).</span><span style="font-size:small"><span style="font-style:italic">d</span></span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">v</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">s</span></span><sub><span style="font-size:small">1</span></sub></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">e</span></span><sub><span style="font-size:small">1</span></sub></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">c</span></span><sub><span style="font-size:small">1</span></sub></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">d</span></span><span style="font-size:small"> </span></td></tr>
</table></td></tr>
</table>
<!--TOC subsubsection id="sec51" L’implémentation en OCAML-->
<h4 id="sec51" class="subsubsection">L’implémentation en OCAML</h4><!--SEC END --><pre class="verbatim"><span style="font-size:small">let rec compile envc exp codesuivant  =
  match exp with
  | Atom (Entier n) -&gt; CONST n :: codesuivant
  | Var s -&gt; ACCESS (adresse s envc) :: codesuivant
  | Call (f, args) -&gt; compile_call envc f args codesuivant
  | Let (decl,expl) -&gt; compile_let envc decl expl codesuivant 
  | If (cond, exp1, exp2) -&gt; compile_if envc cond exp1 exp2 codesuivant
  | Lambda (parl, bodyl) -&gt; compile_lambda envc parl bodyl codesuivant
  | _ -&gt; raise (Erreur "compile")

and compile_lambda envc parl bodyl codesuivant =
  (CLOSURE ((compile (parl::envc) (hd bodyl)  [RTS])) ) :: codesuivant 

and compile_if envc cond exp1 exp2 codesuivant =
   let code_si = compile envc exp1 codesuivant
   and code_sinon = compile envc exp2 codesuivant
in compile envc cond ( BRANCH(code_si,  code_sinon) :: codesuivant ) 

and compile_call envc f args codesuivant  =
match f with 
 | Var "+" -&gt; compile_app  envc args  (ADD :: codesuivant)
 | Var  "-"  -&gt; compile_app  envc args  (SUB :: codesuivant)
 | Var  "="  -&gt; compile_app  envc args  (CMP :: codesuivant)
 | _ -&gt; compile_larg envc args (compile envc f (JSR :: codesuivant))
 
and
compile_app envc args codesuivant =
  if args = [] then codesuivant
  else  compile envc (hd args) (compile_app envc (tl args) codesuivant) 
and compile_let envc decl expl codesuivant =
  let lvar = map fst decl
  in let lexp = map snd decl
  in compile envc (Call(Lambda(lvar, expl),lexp)) codesuivant 
and compile_larg envc lexp codesuivant =
  let rec aux lexp codesuivant =
    match lexp with
    | [] -&gt; codesuivant
    | a::b -&gt; aux b (compile envc a (ARG::codesuivant))
  in NIL::(aux lexp codesuivant)
    
let rec exe s e c d =
  if (List.length c) = 0 then hd s
  else
    match (hd c) with
  | ADD -&gt;  let Entier(n2) = hd (hd s) and Entier(n1) = hd (hd (tl s)) in
              exe ([Entier(n1+n2)]:: (tl (tl s))) e (tl c) d  
  | SUB -&gt;  let Entier(n2) = hd (hd s) and Entier(n1) = hd (hd (tl s)) in
              exe ([Entier(n1-n2)]:: (tl (tl s))) e (tl c) d  
  | CMP -&gt;  let Entier(n2) = hd (hd s) and Entier(n1) = hd (hd (tl s)) in 
                exe ([Booleen(n1=n2)]:: (tl (tl s))) e (tl c) d   
  | CONST n -&gt;  exe ([Entier n]::s)  e (tl c) d
  | NIL -&gt;  exe ([]::s) e (tl c) d 
  | ARG -&gt;    let v1 = hd s
              in let v2 = hd (tl s)
                in  exe ((v1 @ v2)::(tl (tl s))) e (tl c) d
  | ACCESS sy -&gt;  exe ([lire_env sy e]::s) e (List.tl c) d
  | BRANCH(code_si, code_sinon) -&gt;
          let v = hd (hd s) in 
                if (v = Booleen(true)) then exe (tl s) e (code_si @ (tl c)) d 
                else exe (tl s) e ( code_sinon @ (tl c)) d 
  | CLOSURE(fonc) -&gt;  exe ([CLOS(fonc,e)]::s) e (tl c) d
  | JSR -&gt; let CLOS(corps, e0) = hd (hd s) in
            let larg = hd (tl s) in 
              exe [] (larg::e) corps ((ENVEXE(tl (tl s), e, (tl c)))::d) 
  | RTS -&gt; let ENVEXE(s1, e1, c1) = hd d 
            and v = hd s in
            exe (v::s1) e1 c1 (tl d)
</span></pre>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note4" href="#text4">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Ce résultat est obtenu après quelques minutes...</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec52" La résolution-->
<h1 id="sec52" class="chapter">Chapitre ‍4 La résolution</h1><!--SEC END -->
<!--TOC section id="sec53" Représentation des termes finis-->
<h2 id="sec53" class="section">4.1 Représentation des termes finis</h2><!--SEC END --><p>
Nous reprenons ici le très bon formalisme du livre de <span style="font-style:italic">Lalement</span> [<a href="#lalement">11</a>].</p><p>Les symboles de constante <code class="verb">true</code>, <code class="verb">158</code>, les symboles de fonctions unaires <code class="verb">not</code>, <code class="verb">+</code>,
les symboles de fonctions binaires <code class="verb">or</code>, etc. constituent la signature Σ du langage.
Si <span style="font-style:italic">f</span> est d’arité <span style="font-style:italic">n</span> ≥ 1, alors <span style="font-style:italic">f</span> est un symbole fonctionnel, et si <span style="font-style:italic">f</span> est d’arité 0, <span style="font-style:italic">f</span> est un symbole de constante.
Nous ajoutons à Σ un ensemble <span style="font-style:italic">X</span> de symboles de variables.</p><p>L’ensemble des termes <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub> est défini de la manière suivante:
</p><ul class="itemize"><li class="li-itemize">
	si <span style="font-style:italic">c</span> ∈ Σ et <span style="font-style:italic">c</span> d’arité 0, alors <span style="font-style:italic">c</span> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub> 
	</li><li class="li-itemize">si <span style="font-style:italic">f</span> ∈ Σ et <span style="font-style:italic">f</span> d’arité <span style="font-style:italic">n</span> ≥ 1 avec <span style="font-style:italic">M</span><sub>1</sub>, …, <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub>, alors <span style="font-style:italic">f</span> <span style="font-style:italic">M</span><sub>1</sub> ... <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub>
	</li><li class="li-itemize">si <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">X</span>, alors <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">T</span><sub>Σ ∪ <span style="font-style:italic">X</span></sub>
</li></ul><p>Nous pouvons représenter les termes en OCAML avec le type abstrait suivant:
</p><pre class="verbatim"> type terme = 
 | Var of string
 | Func of string * terme list
</pre><p>En fait, quasiment tous les objets que nous manipulerons pourront être modélisés par des termes.
Prenons l’exemple suivant pour définir le <span style="font-style:italic">type</span> des entiers naturels à partir de la signature Σ = {0, <span style="font-style:italic">S</span>}
Les symboles <span style="font-style:italic">O</span> et <span style="font-style:italic">S</span> sont respectivement d’arité 0 et 1.
Nous avons ainsi : </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">T</span><sub>Σ</sub>= {0, <span style="font-style:italic">S</span>0, <span style="font-style:italic">SS</span>0, <span style="font-style:italic">SSS</span>0, ... } </td></tr>
</table><p>
En OCAML, nous pourrons écrire:
</p><pre class="verbatim">type entiers = Zero | S of entiers 
</pre><p>
En Prolog:
</p><pre class="verbatim">entiers(zero).
entiers(s(X)) :- entiers(X)
</pre><p>
En Coq:

Inductive entiers : Set := Zero : entiers | S : entiers → entiers .
Les termes se représentent naturellement sous forme d’arbres.</p><p>Prenons par exemple le terme <code class="verb">Func("f", [Func("g", [Var "x"; Var "y"]); Var "z"])</code>
Il sera représenté par l’arbre ci-dessous annoté de ses occurences <span style="font-style:italic">u</span> ∈ <span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span>)  :
</p><div class="center">
	[level distance=1.5cm,
	level 1/.style=sibling distance=3cm,
	level 2/.style=sibling distance=2cm]
	f (<span style="font-style:italic">u</span>=є)
		child  node g (<span style="font-style:italic">u</span>=1)
			child  node x (<span style="font-style:italic">u</span>=11) 
			child  node y (<span style="font-style:italic">u</span>=12) 
			
		child  node z (<span style="font-style:italic">u</span>=2) 
;

</div><p>
Pour tout terme <span style="font-style:italic">M</span>, on définit:
</p><ul class="itemize"><li class="li-itemize">
	L’ensemble <span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span>) des occurences de M
	</li><li class="li-itemize">Le symbole <span style="font-style:italic">M</span>(<span style="font-style:italic">u</span>) en <span style="font-style:italic">u</span> pour <span style="font-style:italic">u</span> ∈ <span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span>)
	</li><li class="li-itemize">Le sous-terme <span style="font-style:italic">M</span>|<sub><span style="font-style:italic">u</span></sub> de <span style="font-style:italic">M</span> en <span style="font-style:italic">u</span>, pour <span style="font-style:italic">u</span> ∈ <span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span>)
</li></ul><p>
Dans le cas où <span style="font-style:italic">M</span> = <span style="font-style:italic">c</span> ∈ Σ, alors <span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span>) = {є}, <span style="font-style:italic">M</span>(є)=<span style="font-style:italic">c</span>, <span style="font-style:italic">M</span>|<sub>є</sub>=<span style="font-style:italic">c</span></p><p><br>
</p><p>Dans le cas où <span style="font-style:italic">M</span> = <span style="font-style:italic">f</span> <span style="font-style:italic">M</span><sub>1</sub>… <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub>, alors :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span>) = {є} ⋃ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∪</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">i</span>. <span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span><sub><span style="font-style:italic">i</span></sub>)</td></tr>
</table><p>
Avec les égalités suivantes pour les sous-termes <span style="font-style:italic">M</span>|<sub>є</sub>= <span style="font-style:italic">f</span> et <span style="font-style:italic">M</span>|<sub><span style="font-style:italic">i</span>.<span style="font-style:italic">u</span></sub>=<span style="font-style:italic">M</span><sub><span style="font-style:italic">i</span></sub>|<sub><span style="font-style:italic">u</span></sub>  <br>
et de manière équivalente pour les symboles <span style="font-style:italic">M</span>(є) = <span style="font-style:italic">f</span> et <span style="font-style:italic">M</span>(<span style="font-style:italic">i</span>.<span style="font-style:italic">u</span>)=<span style="font-style:italic">M</span><sub><span style="font-style:italic">i</span></sub>(<span style="font-style:italic">u</span>) </p><p>Nous implémentons cela avec un peu de difficulté pour les conversions 
<code class="verb">string</code> vers <code class="verb">int</code> nécessaire à la manipulation des occurences <span style="font-style:italic">u</span>. 
On considère ici qu’un arbre ne peut avoir plus de 9 fils, donc un seul digit permet de définir le numéro du noeud associé.
</p><pre class="verbatim">open String

let rec occurences i terme  =
match terme with
|Var _ | Func(_, []) -&gt;  [i]
|Func (_, m) -&gt;  [i] @ occur_liste 1 i  m 
and occur_liste  c  i lterme =
match lterme with
| [] -&gt; []
| a::b -&gt; (occurences (int_of_string((string_of_int(i)^(string_of_int c)))) a) 
          @ occur_liste (c+1) i b

let reste s =
  if (length s) &lt;= 1 then "0"
  else sub s 1 ((length s) -1)

let string_of_char = String.make 1 ;;

let rec cut i terme =
  match terme with
  | Var _ | Func(_, []) when i=0 -&gt; terme
  | Func(f, lt) -&gt; if i=0 then terme 
                   else subterme (int_of_string(string_of_char((string_of_int i).[0])))
                                 (int_of_string(reste (string_of_int i)))
                                 lt
  | _ -&gt; raise Impossible
and subterme i u ltermes =
  match ltermes with
  | hd::tl -&gt; if (i=1) then  cut u hd else  subterme (i-1) u tl
  | [] -&gt; raise Impossible

</pre><p>
Nous pouvons aussi définir l’opération de <span style="font-style:italic">greffe</span> à une occurence <span style="font-style:italic">u</span> donnée. Nous utiliserons
l’écriture <span style="font-style:italic">M</span>[<span style="font-style:italic">N</span>]<sub><span style="font-style:italic">u</span></sub> pour signifier que le terme <span style="font-style:italic">M</span> reçoit à l’occurence <span style="font-style:italic">u</span> son greffon <span style="font-style:italic">N</span>.
</p><pre class="verbatim">let rec greffe i terme greffon =
match terme with
| Var _ | Func(_, []) when i=0 -&gt; greffon
| Func(f, lt) -&gt; if i=0 then greffon 
     else Func(f, greffeltermes (int_of_string(string_of_char((string_of_int i).[0]))) 
                         (int_of_string(reste (string_of_int i)))  
                    lt
                    greffon)
| _ -&gt; raise Impossible
and greffeltermes i u ltermes greffon =
match ltermes with
| hd::tl -&gt; if (i=1) then  (greffe u hd greffon)::tl  
            else hd::(greffeltermes (i-1) u tl greffon)
| [] -&gt; raise Impossible
</pre>
<!--TOC section id="sec54" La substitution-->
<h2 id="sec54" class="section">4.2 La substitution</h2><!--SEC END --><p>
Une substitution est une application θ : <span style="font-style:italic">X</span> → <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> </p><p>Le domaine de substitution est l’ensemble des variables de <span style="font-style:italic">X</span> telles que θ (<span style="font-style:italic">x</span>) ≠ <span style="font-style:italic">x</span>
On dit aussi que l’application θ est l’identité <span style="font-style:italic">presque</span> partout, i.e sauf sur une partie finie
de <span style="font-style:italic">X</span>.
Considérons le domaine de θ = {<span style="font-style:italic">x</span><sub>1</sub>, ..., <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>}, alors θ est représenté par l’ensemble
des couples (variable, terme) {(<span style="font-style:italic">x</span><sub>1</sub>, θ (<span style="font-style:italic">x</span><sub>1</sub>)), ...,(<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, θ (<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>) } </p><p>Nous avons par induction:
</p><ul class="itemize"><li class="li-itemize">
	θ <span style="font-style:italic">c</span> = <span style="font-style:italic">c</span>, si <span style="font-style:italic">c</span> ∈ Σ d’arité 1
	</li><li class="li-itemize">θ (<span style="font-style:italic">f</span> <span style="font-style:italic">M</span><sub>1</sub> … <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub>) = <span style="font-style:italic">f</span>(θ <span style="font-style:italic">M</span><sub>1</sub> … θ <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> ), si <span style="font-style:italic">f</span> ∈ Σ d’arité <span style="font-style:italic">n</span> 
	</li><li class="li-itemize">θ <span style="font-style:italic">x</span> = θ (<span style="font-style:italic">x</span>) si <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">X</span>
</li></ul><p>
La fonction θ s’étend ainsi en une fonction θ (mais que nous appelerons aussi θ)
de <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> → <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> .
θ est l’unique fonction telle que ∀ <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">X</span>, θ<span style="font-style:italic">x</span> = θ (<span style="font-style:italic">x</span>)
</p><div class="center">
[scale=2]
[-latex] (0,0) node[above left]<span style="font-style:italic">X</span> – node[above]θ (1,0) node[above]<span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub>  ;
[-latex] (0,0) –node[left]∈ (0,-1) node[left]<span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span> ∪ Σ</sub> ;
[-latex, dotted] (0,-1) –node[right]θ (1,0) ;

</div><p>Voici un exemple d’implémentation de la substitution en OCAML:
</p><pre class="verbatim">let valeur_subst sigma var =
  try assoc var sigma
  with Not_found -&gt; var

let rec substituer terme sigma  =
  match terme with
  | Var(x) -&gt; (valeur_subst sigma terme)
  | Func(f, []) -&gt; Func(f, []) 
  | Func(f, args) -&gt; Func(f, (map (function t -&gt; (substituer t sigma)) args))
</pre>
<!--TOC section id="sec55" Filtrage et réécriture-->
<h2 id="sec55" class="section">4.3 Filtrage et réécriture</h2><!--SEC END -->
<!--TOC subsection id="sec56" Le filtrage-->
<h3 id="sec56" class="subsection">4.3.1 Le filtrage</h3><!--SEC END --><p>
Soient deux termes <span style="font-style:italic">M</span> et <span style="font-style:italic">M</span>′ appartenant à <span style="font-style:italic">T</span><sub><span style="font-style:italic">X</span></sub>, le filtrage consiste à trouver une substitution σ
telle que σ <span style="font-style:italic">M</span> = <span style="font-style:italic">M</span>′. Autrement dit, il faut trouver les valeurs à donner aux variables de <span style="font-style:italic">M</span> pour que celui-ci
soit égal <span style="font-style:italic">M</span>′.</p><p>On appelle <span style="font-style:italic">M</span> le <span style="font-style:italic">pattern</span> et <span style="font-style:italic">M</span>′ l’<span style="font-style:italic">instance</span>.
Nous implémentons cela comme ci-dessous :
</p><pre class="verbatim">type terme = 
  | Var of string
  | Func of string * terme list

exception Impossible

let rec filtre_termes lt1 lt2 sigma =
  match (lt1,lt2) with
    | ([], _)  -&gt; sigma
    | (_, []) -&gt;  sigma
    | _ -&gt; 
     begin
   let sigma1 = filtre (hd(lt1)) (hd(lt2)) sigma in
   filtre_termes (tl(lt1)) (tl(lt2)) sigma1
    end 
and filtre m n sigma =
  match (m,n) with
 | (Func(f,_), Func(g, _)) when f &lt;&gt; g -&gt; raise Impossible
 | (Var(x), n) -&gt; 
  begin
  try let var_val = assoc (Var(x)) sigma in
   if var_val = n then sigma else raise Impossible
  with Not_found -&gt; (Var(x), n)::sigma
  end 
 | (Func(f,f1), Func(g,g1)) -&gt; filtre_termes f1 g1 sigma 
 | _ -&gt; raise Impossible

let f1 = Func("f", [Var "x"; Func("g", [Var "y"; Var "z"]); Func("h", [Var "x"])]) ;;
let f2 = Func("f", [Func("a",[]); Func("g", [Func("h", [Var "x"]); Func("b", [])]); Func("h", [Func ("a", [])])]) ;;
imprime_sigma (filtre f1 f2 []) ;;
=&gt;&gt;&gt;
z &lt;-&gt;  b 
y &lt;-&gt; (h x )
x &lt;-&gt;  a 
- : unit = ()
</pre>
<!--TOC subsection id="sec57" La réécriture et l’arithmétique de Peano-->
<h3 id="sec57" class="subsection">4.3.2 La réécriture et l’arithmétique de Peano</h3><!--SEC END --><p>
Le mécanisme de réécriture, très simple à comprendre conceptuellement, est un peu plus difficile
à formaliser proprement.</p><p>Un système de <span style="font-style:italic">réécriture</span> est composé d’une signature Σ et d’un ensemble de règles
<span style="color:red"><span style="font-style:italic">R</span></span> représenté par des couples (<span style="font-style:italic">P</span>,<span style="font-style:italic">Q</span>) ∈ <span style="font-style:italic">T</span><sub>Σ</sub>[<span style="font-style:italic">X</span>] × <span style="font-style:italic">T</span><sub>Σ</sub>[<span style="font-style:italic">X</span>].</p><p>Les couples (<span style="font-style:italic">P</span>,<span style="font-style:italic">Q</span>) sont notés <span style="font-style:italic">P</span> —→ <span style="font-style:italic">Q</span></p><p>Si nous avons un filtre σ tel que σ <span style="font-style:italic">P</span> = <span style="font-style:italic">M</span>|<sub><span style="font-style:italic">u</span></sub>, alors le terme <span style="font-style:italic">M</span> se 
réécrit en un terme <span style="font-style:italic">M</span>[σ <span style="font-style:italic">Q</span>]<sub><span style="font-style:italic">u</span></sub> par l’application de la règle <span style="font-style:italic">P</span> —→ <span style="font-style:italic">Q</span> 
à l’occurence <span style="font-style:italic">u</span> ∈ <span style="color:red"><span style="font-style:italic">O</span></span>(<span style="font-style:italic">M</span>) 
</p><div class="center">

(0,0) – (2,0) – (1,2) node[above]<span style="font-style:italic">M</span> –cycle ;
(0.5,0) –(1,0)– (0.75,0.75) node[above]σ <span style="font-style:italic">P</span> –cycle ;
[-latex] (3,1) – (4,1) ;
[xshift=5cm]
(0,0) – (2,0) – (1,2) node[above]<span style="font-style:italic">M</span>[σ <span style="font-style:italic">Q</span>]<sub><span style="font-style:italic">u</span></sub> –cycle ;
(0.5,0) –(1,0)– (0.75,0.75) node[above]σ <span style="font-style:italic">Q</span> –cycle ;
[dotted] (0.75,0.75) – (2,0.75) node[right]<span style="font-style:italic">u</span> ; 


</div><p>CAML est &lt;&lt;déjà&gt;&gt; une machine à faire du filtrage et de la réécriture. 
L’application d’une fonction <span style="font-style:italic">P</span> à son argument <span style="font-style:italic">Q</span> est modélisé par le redex
(λ <span style="font-style:italic">m</span> <span style="font-style:italic">P</span>)<span style="font-style:italic">Q</span> —→ θ <span style="font-style:italic">P</span> où <span style="font-style:italic">m</span> est le pattern et θ le filtre de
<span style="font-style:italic">m</span> vers <span style="font-style:italic">Q</span>, c’est-à-dire θ <span style="font-style:italic">m</span> = <span style="font-style:italic">Q</span>.	</p><p>Il est ainsi simple de programmer en OCAML une fonction de réécriture.
Appliquons cela sur l’arithmétique de Peano.</p><p>Peano a reconstruit la théorie des
entiers à partir de la fonction successeur. On se donne uniquement le symbole
<span style="font-style:italic">S</span> d’arité 1 et le symbole de constante 0.
Les entiers sont les termes de la forme 0, <span style="font-style:italic">S</span>0, <span style="font-style:italic">SS</span>0, <span style="font-style:italic">SSS</span>0 …
Nous pouvons implémenter cela en OCAM avec le type abstrait <code class="verb">peano</code>
</p><pre class="verbatim">type peano = 
 | Zero
 | Succ of peano
 | Plus of peano * peano
 | Mult of peano * peano

let un = Succ Zero ;;
let deux = Succ (Succ Zero) ;;
let trois = Succ (Succ (Succ Zero)) ;;
</pre><p>Puis nous avons les quatre règles de réécriture suivante:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>1</sub>)</td><td style="text-align:left;white-space:nowrap" >(+ <span style="font-style:italic">x</span> 0) → <span style="font-style:italic">x</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>2</sub>)</td><td style="text-align:left;white-space:nowrap" >(+  <span style="font-style:italic">x</span> (<span style="font-style:italic">S</span> <span style="font-style:italic">y</span>)) → (<span style="font-style:italic">S</span> (+<span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)) </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>3</sub>)</td><td style="text-align:left;white-space:nowrap" >(* <span style="font-style:italic">x</span> 0) → 0 </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">r</span><sub>4</sub>)</td><td style="text-align:left;white-space:nowrap" >(* <span style="font-style:italic">x</span> (<span style="font-style:italic">S</span> <span style="font-style:italic">y</span>)) → (+ <span style="font-style:italic">y</span> (* <span style="font-style:italic">x</span> <span style="font-style:italic">y</span>)) </td></tr>
</table></td></tr>
</table><p>
Ces quatre règles sont implémentées par la fonction <code class="verb">réduire</code> ci-dessous:
</p><pre class="verbatim">let rec reduire = function
 | Plus (p, Zero) -&gt; reduire p
 | Plus (p1 , (Succ p2)) -&gt; Succ ( reduire ((Plus (reduire p1, reduire p2))) )
 | Mult (p, Zero) -&gt; Zero
 | Mult (p1, (Succ p2)) 
     -&gt; reduire (Plus (reduire p1, reduire ((Mult (reduire p1, reduire p2))) ))
 | _ as p -&gt; p 

let rec peano_entier = function
 | Zero -&gt; 0
 | Succ p -&gt; 1 + (peano_entier p)
 | any -&gt; peano_entier (reduire any)
 
peano_entier (Plus ( Mult(deux, trois), trois));;
</pre><p>Essayons maintenant d’implémenter le mécanisme de réécriture en utilisation le type 
<span style="font-style:italic">terme</span> que nous avons précedemment présenté, ainsi que la fonction de filtrage <code class="verb">filtre</code> et 
la fonction du substitution <code class="verb">substituer</code>.</p><p>Nous avons fait simple avec cette méthode naïve qui utilise les trois fonctions ci-dessous :
</p><ul class="itemize"><li class="li-itemize">
	La première <code class="verb">rewrite</code> utilise la fonction <code class="verb">filtre</code> pour chercher une substitution
	égalisant notre terme avec la partie gauche de la règle de substitution. Si cette substitution est trouveée, la 
	fonction retourne la partie droite de la règle appliquée à la substitution. Dans le cas contraire, la fonction
	est appelée récursivement sur l’ensemble des arguments du terme.
	</li><li class="li-itemize">La seconde <code class="verb">rewriteall</code> déroule l’ensemble des règles représentées par une liste de paires (<span style="font-style:italic">l</span>,<span style="font-style:italic">r</span>) tant
	que la réécriture ne modifie par le terme.
	</li><li class="li-itemize">La troisième <code class="verb">rewrite_bourrin</code> itère la fonction précédente tant que l’on peut réduire le terme.
	Désolé pour cette méthode bourrin, mais ça fonctionne…</li></ul><pre class="verbatim">let rec rewrite t l r =
match t with
| Var(_) | Func(_,[]) -&gt; t
| Func(f, listet)  -&gt; 
 try let subst = filtre l t [] in
  substituer r subst 
 with Impossible -&gt; Func(f, map (function t -&gt; (rewrite t l r)) listet)
and rewriteall lregles t =
 match lregles with
 | [] -&gt; t
 | (l,r) ::reste -&gt; 
  let t1 = (rewrite t l r) in
   if t1=t then rewriteall reste t 
   else t1
and rewrite_bourrin t lregles =
 let t1 = rewriteall lregles t in
 if t1=t then t
 else rewrite_bourrin t1 lregles
</pre><p>Les quatre règles de Peano sont modélisées de la façon suivante :
</p><pre class="verbatim">let peano = [
(Func("+", [Var "x"; Func("0", [])]), Var "x") ;
(Func("+", [Var "x"; Func("S", [Var "y"])])), Func("S", [Func("+", [Var "x"; Var "y"])]) ;
(Func("*", [Var "x"; Func("0", [])]), Func("0", [])) ;
(Func("*", [Var "x"; Func("S", [Var "y"])])), Func("+", [Var "x"; Func("*", [Var "x"; Var "y"])]) ;
] 
</pre><p>Nous pouvons ainsi calculer la valeur 16 :
</p><pre class="verbatim">let un = Func("S", [Func("0", [])]) ;;
let deux = Func("+", [un; un]) ;;
let quatre = Func("*", [deux;deux]) ;;
let seize = Func("*", [quatre;quatre]) ;;

rewrite_bourrin seize peano ;;    
 
</pre>
<!--TOC section id="sec58" L’unification des termes-->
<h2 id="sec58" class="section">4.4 L’unification des termes</h2><!--SEC END --><p>
Un interprète PROLOG peut être considéré comme une machine à unifier.</p><p>Définissons d’abord l’opération d’unification de deux termes.
Un unificateur de deux termes <span style="font-style:italic">t</span><sub>1</sub> et <span style="font-style:italic">t</span><sub>2</sub> est une substitution σ telle que σ <span style="font-style:italic">t</span><sub>1</sub> = σ <span style="font-style:italic">t</span><sub>2</sub></p><p>Soit <span style="font-style:italic">E</span>, un système d’équations, on peut définir des transformations <span style="font-style:italic">E</span><sub>1</sub> → <sub><span style="font-style:italic">t</span></sub> <span style="font-style:italic">E</span><sub>2</sub> 
entre systèmes d’équations. On note le symbole ⊥ qui représente un système sans solution.
Résoudre <span style="font-style:italic">E</span><sub>0</sub> consiste à appliquer une suite de transformations <span style="font-style:italic">E</span><sub>0</sub> → <sub>*</sub> <span style="font-style:italic">E</span><sub><span style="font-style:italic">n</span></sub>  de sorte que
<span style="font-style:italic">E</span><sub><span style="font-style:italic">n</span></sub> soit en forme résolue, ou bien <span style="font-style:italic">E</span><sub><span style="font-style:italic">n</span></sub> = ⊥</p><p>Nous avons six types de transformations possibles: </p><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >décomposition</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">f</span> <span style="font-style:italic">M</span><sub>1</sub> … <span style="font-style:italic">M</span><sub><span style="font-style:italic">r</span></sub> = <span style="font-style:italic">f</span> <span style="font-style:italic">N</span><sub>1</sub> … <span style="font-style:italic">N</span><sub><span style="font-style:italic">r</span></sub> } → <span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">M</span><sub>1</sub> = <span style="font-style:italic">N</span><sub>1</sub> , … ,<span style="font-style:italic">M</span><sub><span style="font-style:italic">r</span></sub> = <span style="font-style:italic">N</span><sub><span style="font-style:italic">r</span></sub> }  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >effacement</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">M</span>=<span style="font-style:italic">M</span> } → <span style="font-style:italic">E</span>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >élimination</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } → <span style="font-style:italic">E</span>[<span style="font-style:italic">x</span>:=<span style="font-style:italic">M</span>] ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } si <span style="font-style:italic">M</span> ∉ <span style="font-style:italic">X</span>, <span style="font-style:italic">x</span> ∉ <span style="font-style:italic">var</span>(<span style="font-style:italic">M</span>)</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >inversion</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">M</span>=<span style="font-style:italic">x</span> } → <span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } si <span style="font-style:italic">M</span> ∉ <span style="font-style:italic">X</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >conflit</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">f</span> <span style="font-style:italic">M</span> = <span style="font-style:italic">g</span> <span style="font-style:italic">M</span>} → ⊥  si  <span style="font-style:italic">f</span> ≠ <span style="font-style:italic">g</span>  </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >cycle</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">E</span> ∪ { <span style="font-style:italic">x</span>=<span style="font-style:italic">M</span> } → ⊥  si <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">var</span>(<span style="font-style:italic">M</span>) </td></tr>
</table><p><br>
</p><p>La difficulté de cet algorithme est sa condition d’arrêt. 
Si aucune règle ne peut plus s’appliquer sur les éléments du système d’équations, alors l’algorithme doit s’arrêter et son résultat est
la substitution unifiant les deux termes initiaux.
Avec une seule fonction parcourant le système d’équations, représentés en OCAML par le type <code class="verb">(term * term) list</code>,
je pense que ce n’est pas possible. Je me suis là aussi un peu cassé les cheveux.
Voici mon code avec deux fonctions:
</p><pre class="verbatim">let rec  unifier equation =
match equation with
| (Var(x),Var(y)) -&gt; if x=y then [] else [(Var(x), Var(y))] 
| (Func(f1,l1),Func(f2, l2)) -&gt; if f1 = f2 &amp;&amp; List.length l1 = List.length l2 
 then unifierliste (List.combine l1 l2)
 else raise Impossible
| (Func(m,n),Var(x)) -&gt; unifier (Var(x), Func(m,n)) 
| (Var(x), Func(m,n)) -&gt; if (mem (Var(x)) (listevar (Func(m,n)))) 
 then raise Impossible
 else [(Var(x), Func(m,n)) ] 
and unifierliste = function
| [] -&gt; []
| (x,y)::t -&gt;
 let t2 = unifierliste t in
 let t1 = unifier ((substituer x t2 ),(substituer y t2)) in
 t1 @ t2
</pre><p>On retrouve dans la fonction <code class="verb">unifier</code>, qui travaille uniquement sur une paire de terme, les différentes règles
de l’algorithme. La fonction <code class="verb">unifierliste</code> va unifier sa première paire en utilisant la substitution trouvée dans le reste
de l’équation. C’est un bel exemple de récursivité qui nous dépasse très souvent... 
Ce bout de code vient du site de l’université de Cornell.</p><p>Voici un autre exemple moins proche de l’algorithme présenté.
</p><pre class="verbatim">let unifier t1 t2 =
  let rec unificateur t1 t2 =
    match (t1,t2) with
    | (Var(x), _)  -&gt; 
      begin
        if t1 = t2 then [] 
        else if (mem t1 (listevar t2)) then raise Impossible
             else [(t1, t2)]
      end    
    | (_, Var(x)) -&gt; unificateur t2 t1
    | (Func(x, l1), Func(y, l2)) -&gt; if x&lt;&gt;y then raise Impossible
      else (unifliste l1 l2 [])
  and unifliste l1 l2 sigma =
    match (l1, l2) with
    | ([], _) -&gt; sigma
    | (h1::t1, h2::t2) -&gt;
      begin
        let sigma1 = (unificateur h1 h2) in
        unifliste (map (function terme -&gt; (substituer terme sigma1)) t1)
          (map (function terme -&gt; (substituer terme sigma1)) t2)
          (compose_subst sigma sigma1)
      end  
    | _ -&gt; raise Impossible
  in unificateur t1 t2 
</pre>
<!--TOC section id="sec59" Un mini PROLOG-->
<h2 id="sec59" class="section">4.5 Un mini PROLOG</h2><!--SEC END --><pre class="verbatim">let question() =
 begin
   print_string "\n autre solution 1/2 (1=oui, 2=non) ? :" ;
   if read_int()= 1  then false else true 
 end
  
let autre_solution lvar lvaleur  =
 if lvaleur &lt;&gt; [] then (affiche_solution lvar lvaleur ; question())
 else false 
  
let prolog but lregles =
 let lvar_but = listevar but in
 let rec prouveli lbuts lvaleur =
   match lbuts with
   | [] -&gt; autre_solution lvar_but lvaleur
   | h::t -&gt; 
  some (fun regle -&gt;  try
     let regle_bis = (renomme regle) in
     let sigma1 = unifier h (hd regle_bis) in   
     prouveli 
       (sublis sigma1 ((lhypotheses regle_bis) @ t))
       (sublis sigma1 lvaleur)  
      with Impossible -&gt; false)
    lregles 
 in
 prouveli [but] lvar_but
  
</pre>
<!--TOC section id="sec60" Quelques exemples de programmation en PROLOG-->
<h2 id="sec60" class="section">4.6 Quelques exemples de programmation en PROLOG</h2><!--SEC END -->
<!--TOC subsection id="sec61" Les entiers naturels-->
<h3 id="sec61" class="subsection">4.6.1 Les entiers naturels</h3><!--SEC END --><p>
Définissons en PROLOG le type des entiers naturels avec la fonction <code class="verb">nat</code> d’arité 1, la fonction <code class="verb">s</code>
d’arité 1 et la constante <code class="verb">0</code>.
Nous avons ainsi les 2 règles:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">nat</span>(0) ⇐ </td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">nat</span>(<span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>)) ⇐ <span style="font-style:italic">nat</span>(<span style="font-style:italic">x</span>)
</td></tr>
</table></td></tr>
</table><pre class="verbatim">---------------------------------------------------
let nat = [ [Func("nat", [Func("0", [])])] ;
            [Func("nat", [Func("s",[Var("X")])]) ; Func("nat", [Var("X")])] ] ;;
let but = Func("nat", [Var("X")]) ;; 

prolog but nat ;;
----------------------------------------------------
vincent@HP-Notebook:~/workspace vscodium$ ./prolog.byte 
 X  &lt;-&gt;  0 
 autre solution 1/2 (1=oui, 2=non) ? :1
 X  &lt;-&gt; (s 0 )
 autre solution 1/2 (1=oui, 2=non) ? :1
 X  &lt;-&gt; (s(s 0 ))
 autre solution 1/2 (1=oui, 2=non) ? :1
 X  &lt;-&gt; (s(s(s 0 )))
 autre solution 1/2 (1=oui, 2=non) ? :2
vincent@HP-Notebook:~/workspace vscodium$ 
</pre>
<!--TOC subsection id="sec62" Les additions de Peano-->
<h3 id="sec62" class="subsection">4.6.2 Les additions de Peano</h3><!--SEC END --><p>
Nous pouvons modéliser les additions avec l’arithmétique de Peano en utilisant les deux propositions suivantes:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >	<span style="font-style:italic">add</span>(<span style="font-style:italic">x</span>, 0, <span style="font-style:italic">x</span>) ⇐ </td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	<span style="font-style:italic">add</span>(<span style="font-style:italic">x</span>, <span style="font-style:italic">s</span>(<span style="font-style:italic">y</span>), <span style="font-style:italic">s</span>(<span style="font-style:italic">z</span>)) ⇐  <span style="font-style:italic">add</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>,<span style="font-style:italic">z</span>)
</td></tr>
</table></td></tr>
</table><p>
Puis demandons à notre mini Prolog de résoudre l’équation <span style="font-style:italic">add</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>, <span style="font-style:italic">s</span>(<span style="font-style:italic">s</span>(<span style="font-style:italic">s</span>(0))))
</p><pre class="verbatim">(* les entiers de peano *)
let peano = [ [Func("add", [Var("x"); Func("0", []); Var("x")]) ] ;
    [Func("add", [Var("x");  Func("S", [Var("y")]) ; Func("S", [Var("z")])]) ;
    Func("add", [Var("x"); Var("y"); Var("z")])]
   ] ;;

let but1 = Func("add", [Var("x") ; Var("y") ; Func("S", [Func("S", [Func("S", [Func("0", [])])])])]) ;; 

vincent@HP-Notebook:~/vsc$ ./prolog.byte 
 x  &lt;-&gt; (S(S(S 0 ))) y  &lt;-&gt;  0 
 autre solution 1/2 (1=oui, 2=non) ? :1
 x  &lt;-&gt; (S(S 0 )) y  &lt;-&gt; (S 0 )
 autre solution 1/2 (1=oui, 2=non) ? :1
 x  &lt;-&gt; (S 0 ) y  &lt;-&gt; (S(S 0 ))
 autre solution 1/2 (1=oui, 2=non) ? :1
 x  &lt;-&gt;  0  y  &lt;-&gt; (S(S(S 0 )))
 autre solution 1/2 (1=oui, 2=non) ? :1
vincent@HP-Notebook:~/vsc$ 
</pre>
<!--TOC subsection id="sec63" La base généalogique-->
<h3 id="sec63" class="subsection">4.6.3 La base généalogique</h3><!--SEC END --><pre class="verbatim">(* généalogie *)
let grecs = [ [Func("mere", [Func("gaia",[]);Func("chronos",[]) ] ) ] ;
    [Func("mere", [Func("rhea",[]);Func("zeus",[]) ] ) ] ;
    [Func("mere", [Func("rhea",[]);Func("hades",[]) ] ) ] ;
    [Func("pere", [Func("zeus",[]);Func("pollux",[]) ] ) ] ;
    [Func("pere", [Func("ourance",[]);Func("chronos",[]) ] ) ] ;
    [Func("pere", [Func("chronos",[]);Func("zeus",[]) ] ) ] ;
    [Func("pere", [Func("zeus",[]);Func("helene",[]) ] ) ] ;
    [Func("pere", [Func("zeux",[]);Func("castor",[]) ] ) ] ;
    [Func("pere", [Func("gaia",[]);Func("chronos",[]) ] ) ] ;
    [Func("parent", [Var("x"); Var("y")]) ; Func("pere", [Var("x"); Var("y")]) ]  ;
    [Func("parent", [Var("x"); Var("y")]) ; Func("mere", [Var("x"); Var("y")]) ]  ;
    [Func("gd-parent", [Var("i"); Var("k")]) ; Func("parent", [Var("i"); Var("j")]) ; 
     Func("parent", [Var("j"); Var("k")])] ;
    [Func("frere", [Var("y"); Var("z")]) ; Func("parent", [Var("x"); Var("y")]) ; 
     Func("parent", [Var("x"); Var("z")])]         
   ] ;;

let but = Func("gd-parent", [Func("chronos", []) ; Var("x")]) ;;
 
vincent@HP-Notebook:~/vsc$ ./prolog.byte 
 x  &lt;-&gt;  pollux 
 autre solution 1/2 (1=oui, 2=non) ? :1
 x  &lt;-&gt;  helene 
 autre solution 1/2 (1=oui, 2=non) ? :1
</pre>
<!--TOC section id="sec64" L’algorithme de complétion de Knuth-Bendix-->
<h2 id="sec64" class="section">4.7 L’algorithme de complétion de Knuth-Bendix</h2><!--SEC END -->
<!--TOC subsection id="sec65" Confluence et paires critiques-->
<h3 id="sec65" class="subsection">4.7.1 Confluence et paires critiques</h3><!--SEC END --><p>
Le lemme de Newman nous dit qu’un système de réécriture noethérien (qui termine) est confluent 
ssi il est localement confluent.</p><p>La situation générale se présente comme cela:
</p><div class="center">

[-latex] (0.7,0.8) node[above right] <span style="font-style:italic">s</span>– node[left]<span style="font-style:italic">l</span><sub>1</sub> → <span style="font-style:italic">r</span><sub>1</sub> (0,0) node[below]<span style="font-style:italic">t</span><sub>1</sub> ;
[-latex] (1.3,0.8) – node[right]<span style="font-style:italic">l</span><sub>2</sub> → <span style="font-style:italic">r</span><sub>2</sub> (2,0) node[below]<span style="font-style:italic">t</span><sub>2</sub> ;

</div><p>
La confluence locale sera assurée si nous trouvons un terme <span style="font-style:italic">t</span> tel que 
<span style="font-style:italic">t</span><sub>1</sub> *→ <span style="font-style:italic">t</span> *← <span style="font-style:italic">t</span><sub>2</sub> </p><p>Nous avons ainsi 2 règles <span style="font-style:italic">l</span><sub>1</sub> → <span style="font-style:italic">r</span><sub>1</sub> et <span style="font-style:italic">l</span><sub>2</sub> → <span style="font-style:italic">r</span><sub>2</sub>. Cela donne par définition de la réécriture :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span>|<sub><span style="font-style:italic">p</span><sub>1</sub></sub> = σ<sub>1</sub> <span style="font-style:italic">l</span><sub>1</sub> <span style="font-style:italic">avec</span> <span style="font-style:italic">t</span><sub>1</sub>=<span style="font-style:italic">s</span>[σ<sub>1</sub> <span style="font-style:italic">r</span><sub>1</sub>]<sub><span style="font-style:italic">p</span><sub>1</sub></sub> </td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span>|<sub><span style="font-style:italic">p</span><sub>2</sub></sub> = σ<sub>2</sub> <span style="font-style:italic">l</span><sub>2</sub> <span style="font-style:italic">avec</span> <span style="font-style:italic">t</span><sub>2</sub>=<span style="font-style:italic">s</span>[σ<sub>2</sub> <span style="font-style:italic">r</span><sub>2</sub>]<sub><span style="font-style:italic">p</span><sub>2</sub></sub> </td></tr>
</table><p>On montre facilement (de manière visuelle) que nous pouvons trouver 
<span style="font-style:italic">t</span><sub>1</sub> *→ <span style="font-style:italic">t</span> *← <span style="font-style:italic">t</span><sub>2</sub> lorsque
<span style="font-style:italic">p</span><sub>1</sub> et <span style="font-style:italic">p</span><sub>2</sub> ne se chevauchent pas. Et lorsqu’il y a chevauchement, on peut également trouver 
<span style="font-style:italic">t</span><sub>1</sub> *→ <span style="font-style:italic">t</span> *← <span style="font-style:italic">t</span><sub>2</sub> si la position de σ<sub>2</sub> <span style="font-style:italic">l</span><sub>2</sub> dans <span style="font-style:italic">l</span><sub>1</sub> 
est une variable.</p><p>
Sinon, il y a un chevauchement <span style="font-style:italic">critique</span> :
</p><div class="center">
	
	(0,0) – (2,0) – (1,2) node[above]σ<sub>1</sub> <span style="font-style:italic">l</span><sub>1</sub> –cycle ;
	(0.5,0) –(1,0)– (0.75,0.75) –cycle ;
	(0.9,0.9) node σ<sub>2</sub> <span style="font-style:italic">l</span><sub>2</sub> ;
	[-latex, blue] (0.5,-0.2) – node[above left] (1) (-1.5,-1) ;
	[-latex, red] (1.5,-0.2) – node[above right] (2) (3.5,-1) ;
	[xshift=-3cm, yshift=-3cm]
		[blue] (0,0) – (2,0) – (1,2) node[above]σ<sub>1</sub> <span style="font-style:italic">r</span><sub>1</sub> –cycle ;
	
	[xshift=+3cm, yshift=-3cm] 
		(0,0) – (2,0) – (1,2) node[above]σ<sub>1</sub> <span style="font-style:italic">l</span><sub>1</sub> –cycle ;
		[red] (0.5,0) –(1,0)– (0.75,0.75) –cycle ;
		[red] (0.9,0.9) node σ<sub>2</sub> <span style="font-style:italic">r</span><sub>2</sub> ;
	
	
	</div><p>	Posons θ = σ<sub>1</sub> ∪ σ<sub>2</sub>, l’unificateur principal de σ<sub>1</sub> et σ<sub>2</sub>.
	Nous appelerons la paire des deux termes en bleu et rouge
	 une <span style="font-style:italic">paire critique</span> &lt;θ <span style="font-style:italic">r</span><sub>1</sub>, (θ <span style="font-style:italic">l</span><sub>1</sub>)[θ <span style="font-style:italic">r</span><sub>2</sub>]<sub><span style="font-style:italic">p</span></sub> &gt; 
	 Si deux règles génèrent une paire critique, on dit qu’elles se superposent.
L’existence de paires critiques est un signe d’ambiguïté du système de réécriture.</p><p>	 Si ces paires critiques sont joignable, le système de réécriture est alors localement confluent.
	 </p><div class="theorem"><span style="font-weight:bold">Théorème ‍4</span> ‍<span style="font-weight:bold">(Knuth-Bendix)</span> <em>
		 Un système de réécriture noethérien est confluent si ses paires critiques sont joignables.
	</em></div><pre class="verbatim">let superpose l1 l2 =
let rec super l1 l2 occ =
 match occ with
 | a::b -&gt; 
 begin
  try 
  let t = cut a l1 in
  match t with 
  | Var _ -&gt; raise Impossible
  | _ -&gt; let sigma = unifier ((cut a l1), l2)
    in (a, sigma)
  with Impossible -&gt; super l1 l2 b 
 end
| [] -&gt; raise Impossible
in super l1 l2 (occurences 0 l1)

let rec cp (l1,r1) (l2,r2) =
  let (oc, sigma) = superpose l1 l2 in
  ((substituer  r1 sigma), (greffe oc (substituer l1 sigma) (substituer r2 sigma))) ;;  
</pre>
<!--TOC subsection id="sec66" Terminaison-->
<h3 id="sec66" class="subsection">4.7.2 Terminaison</h3><!--SEC END -->
<!--TOC subsubsection id="sec67" Indécidabilité de la terminaison dans le cas "général"-->
<h4 id="sec67" class="subsubsection">Indécidabilité de la terminaison dans le cas "général"</h4><!--SEC END --><p>
Soient <span style="font-style:italic">a</span><sub>1</sub>,<span style="font-style:italic">a</span><sub>2</sub> ,<span style="font-style:italic">a</span><sub>3</sub> , … une numérotation de tous les algorithmes.
On définit la fonction suivante : <span style="font-style:italic">diag</span>(<span style="font-style:italic">i</span>) ≡ si <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> termine alors <code class="verb">boucler</code>, sinon <code class="verb">s'arrêter</code> <br>

Pour tout <span style="font-style:italic">i</span>, <span style="font-style:italic">diag</span>(<span style="font-style:italic">i</span>) termine ssi <span style="font-style:italic">a</span><sub><span style="font-style:italic">i</span></sub> ne termine pas.
Mais il y a un <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> tel que <span style="font-style:italic">diag</span> = <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> . Nous avons donc
<span style="font-style:italic">diag</span>(<span style="font-style:italic">j</span>) termine ssi <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> ne termine pas, ce qui donne
<span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> termine ssi <span style="font-style:italic">a</span><sub><span style="font-style:italic">j</span></sub> ne termine pas.</p>
<!--TOC subsubsection id="sec68" Système de réécriture noethérien-->
<h4 id="sec68" class="subsubsection">Système de réécriture noethérien</h4><!--SEC END --><p>
Un système de réécriture est noethérien si et seulement s’il existe un ordre bien fondé
≻ sur l’ensemble des termes tel que
</p><ul class="itemize"><li class="li-itemize">
	i) σ <span style="font-style:italic">P</span> ≻ σ <span style="font-style:italic">Q</span> pour toute règle (<span style="font-style:italic">P</span>,<span style="font-style:italic">Q</span>) ∈ <span style="color:red"><span style="font-style:italic">R</span></span> et toute substitution σ
	</li><li class="li-itemize">ii) <span style="font-style:italic">M</span><sub><span style="font-style:italic">i</span></sub> ≻ <span style="font-style:italic">M</span>′<sub><span style="font-style:italic">i</span></sub> entraîne  <span style="font-style:italic">fM</span><sub>1</sub>… <span style="font-style:italic">M</span><sub><span style="font-style:italic">i</span></sub> … <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> ≻ <span style="font-style:italic">fM</span><sub>1</sub>… <span style="font-style:italic">M</span>′<sub><span style="font-style:italic">i</span></sub> … <span style="font-style:italic">M</span><sub><span style="font-style:italic">n</span></sub> 
</li></ul><p>On dit que ≻ est clos par substitution, et qu’il est compatible avec Σ.

En pratique, on utilise une fonction externe <span style="font-style:italic">h</span> : <span style="font-style:italic">T</span><sub>Σ</sub>[<span style="font-style:italic">X</span>] → ℕ  et la relation d’ordre &gt; sur 
ℕ.</p><p>Pour un terme <span style="font-style:italic">t</span> et une variable <span style="font-style:italic">x</span> , on note |<span style="font-style:italic">t</span>| le cardinal de <span style="font-style:italic">t</span> et |<span style="font-style:italic">t</span>|<sub><span style="font-style:italic">x</span></sub> le nombre
d’occurrences de <span style="font-style:italic">x</span> dans <span style="font-style:italic">t</span>. On définit un ordre strict ≻ sur <span style="font-style:italic">T</span>[<span style="font-style:italic">X</span>] par :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">s</span> &gt; <span style="font-style:italic">t</span> ⇔  |<span style="font-style:italic">s</span>| &gt; |<span style="font-style:italic">t</span>| <span style="font-style:italic">et</span>  ∀ <span style="font-style:italic">x</span> ∈ <span style="font-style:italic">X</span>, |<span style="font-style:italic">s</span>|<sub><span style="font-style:italic">x</span></sub> ≥ |<span style="font-style:italic">t</span>|<sub><span style="font-style:italic">x</span></sub> </td></tr>
</table>
<!--TOC subsection id="sec69" Complétion de Knuth-Bendix-->
<h3 id="sec69" class="subsection">4.7.3 Complétion de Knuth-Bendix</h3><!--SEC END --><p>
Nous pourrons ici nous référer au livre très didactique <span style="font-style:italic">Term Rewriting and All That</span>[<a href="#rewriting">6</a>]
</p><pre class="verbatim">let rec super_liste l1 l2 occ =
 match occ with
 | a::b -&gt; 
 begin
  try 
  let t = cut a l1 in
  match t with 
  | Var _ -&gt; raise Impossible
  | _ -&gt; let sigma = unifier ((cut a l1), l2)
     in (a, sigma)
  with Impossible -&gt; super_liste l1 l2 b 
  end
 | [] -&gt; raise Impossible
  
let superpose_liste (l1,r1) (l2,r2) =
let rec superpose_liste_aux l1 l2 occ = (* rend liste des occurences et substitution *)
 if   alpha_equiv (l1,r1) (l2,r2) then 
  try
  let (oc, sigma) = super_liste l1 (rename l2 l1) (remove 0 occ) (* retire 0 car occurence triviale si alpha_equiv *)
  in 
  begin
   print_string "superposition à l'occurence "; print_int oc ;  print_string "\n" ;
   print_string "sur le termes l1 :" ; imprime l1 ; print_string "\n" ;
   print_string "sur le terme l2 :" ; imprime l2 ; print_string "\n" ;
   print_string "avec la substitution :"; imprime_sigma sigma; print_string "\n" ;
  (oc, sigma)::superpose_liste_aux l1 l2 (remove oc occ)
  end
  with Impossible -&gt; []
 else 
 try
 let (oc, sigma) = super_liste l1 (rename l2 l1) occ
  in 
  begin print_string "superposition à l'occurence "; print_int oc ;  print_string "\n" ;
   print_string "sur le terme l1 :" ; imprime l1 ; print_string "\n" ;
   print_string "sur le terme l2 :" ; imprime l2 ; print_string "\n" ;
   print_string "avec la substitution :"; imprime_sigma sigma; print_string "\n" ;
   (oc, sigma)::superpose_liste_aux l1 l2 (remove oc occ)
  end
 with Impossible -&gt; []
in superpose_liste_aux l1 l2 (occurences l1) ;;
</pre>
<!--TOC chapter id="sec70" La calculabilité-->
<h1 id="sec70" class="chapter">Chapitre ‍5 La calculabilité</h1><!--SEC END -->
<!--TOC section id="sec71" Les fonctions récursives-->
<h2 id="sec71" class="section">5.1 Les fonctions récursives</h2><!--SEC END --><p>
Commençons par définir les fonctions récursives <span style="font-style:italic">primitives</span> telles que formalisées par
Gödel.</p><p>Un ensemble <span style="font-style:italic">E</span> de fonctions numériques de ℕ<sup><span style="font-style:italic">p</span></sup> dans ℕ est dit :
</p><ul class="itemize"><li class="li-itemize">
	i) clos par composition si pour tout <span style="font-style:italic">h</span>, <span style="font-style:italic">g</span><sub>1</sub>, …,<span style="font-style:italic">g</span><sub><span style="font-style:italic">p</span></sub> ∈ <span style="font-style:italic">E</span>, si on définit <span style="font-style:italic">f</span> par
	 <table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)=<span style="font-style:italic">h</span>(<span style="font-style:italic">g</span><sub>1</sub>(<span style="font-style:italic">n</span>), …, <span style="font-style:italic">g</span><sub><span style="font-style:italic">p</span></sub>(<span style="font-style:italic">n</span>))</td></tr>
</table>
	alors <span style="font-style:italic">f</span> ∈ <span style="font-style:italic">E</span>
	</li><li class="li-itemize">ii) clos par récursion primitive si pour tout <span style="font-style:italic">h</span>,<span style="font-style:italic">g</span> ∈ <span style="font-style:italic">E</span>, si on définit <span style="font-style:italic">f</span> par
	<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >	<span style="font-style:italic">f</span>(0,<span style="font-style:italic">n</span>)</td><td style="text-align:left;white-space:nowrap" >= <span style="font-style:italic">g</span>(<span style="font-style:italic">n</span>) </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
	<span style="font-style:italic">f</span>(<span style="font-style:italic">m</span>+1, <span style="font-style:italic">n</span>)</td><td style="text-align:left;white-space:nowrap" >= <span style="font-style:italic">h</span>(<span style="font-style:italic">f</span>(<span style="font-style:italic">m</span>,<span style="font-style:italic">n</span>),<span style="font-style:italic">m</span>,<span style="font-style:italic">n</span>)
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
alors <span style="font-style:italic">f</span> ∈ <span style="font-style:italic">E</span>
</li></ul><p>
Les fonctions de base sont la constante 0 : ℕ → ℕ, le successeur 
<span style="font-style:italic">s</span> :ℕ → ℕ, les projections <span style="font-style:italic">pr</span><sub><span style="font-style:italic">k</span></sub><sup><span style="font-style:italic">i</span></sup> : ℕ<sup><span style="font-style:italic">k</span></sup> → ℕ</p><p>Les fonctions récursives primitives sont les éléments du plus petit ensemble <span style="font-style:italic">E</span> contenant les
fonctions de base et clos par composition et récursion primitive.</p><p>La quasi totalité des fonctions est récursive primitive. Considérons par exemple l’addition.
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >	0 + <span style="font-style:italic">y</span></td><td style="text-align:left;white-space:nowrap" >= <span style="font-style:italic">y</span>  </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
	<span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>) + <span style="font-style:italic">y</span></td><td style="text-align:left;white-space:nowrap" >= <span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>+<span style="font-style:italic">y</span>) 
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>
Autrement dit :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >	+ (0, <span style="font-style:italic">y</span>)</td><td style="text-align:left;white-space:nowrap" >=  <span style="font-style:italic">g</span>(<span style="font-style:italic">y</span>) avec <span style="font-style:italic">g</span>=<span style="font-style:italic">pr</span><sub>1</sub><sup>1</sup> (<span style="font-style:italic">y</span>) </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
	+ (<span style="font-style:italic">s</span>(<span style="font-style:italic">x</span>), <span style="font-style:italic">y</span>)</td><td style="text-align:left;white-space:nowrap" >= <span style="font-style:italic">h</span> (+(<span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>), <span style="font-style:italic">x</span>, <span style="font-style:italic">y</span>) avec <span style="font-style:italic">h</span>=<span style="font-style:italic">s</span> ∘  <span style="font-style:italic">pr</span><sub>3</sub><sup>1</sup>
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>
Voici un opérateur de récursion primitive en ML
</p><pre class="verbatim">let rec_prim g h = 
let rec f m n = 
 if m=0 then g n 
 else h (f (m-1) n) (m-1) n
in f 
</pre><p>
Nous pouvons ainsi exprimer la fonction <code class="verb">add</code> :
</p><pre class="verbatim">let s n = n+1 ;;
let pr_11 n = n ;;
let pr_31 x y z =  x ;;
let g y = pr_11 y ;;
let h x y z =  s (pr_31 x y z);;

let add = rec_prim g h ;;

utop # add 5 8 ;;
- : int = 13
</pre><p>
Toute fonction récursive primitive peut s’écrire avec une simple boucle <code class="verb">for</code>.
Le nombre d’itérations est déterminé ; il ne dépend pas d’une condition d’évaluation du programme.
Ainsi, nous pouvons code de la manière suivante :
</p><pre class="verbatim">let add x y =
 let r = ref (g y) in
 (for i=1 to x do r := h !r i y done ; 
  !r
 )
</pre><p>
Existe-t’il des fonctions caculables qui ne sont pas primitives récursives ?
La réponse est oui. Notamment toute fonction qui ne termine pas (boucle <code class="verb">while</code> infinie)
ne pourra s’écrire en fonction récursive primitive.
Il est cependant beaucoup plus complexe d’identifier des fonctions qui terminent et qui soient non récursives primitives.
La fonction d’<span style="font-style:italic">Ackermann</span> est traditionnelement donnée en exemple, bien que cette fonction n’a pas
de réalité pratique…</p><p>La fonction d’Ackermann <span style="font-style:italic">A</span> est définie sur ℕ × ℕ par : <br>
<span style="font-style:italic">A</span>(0, <span style="font-style:italic">p</span>) = <span style="font-style:italic">p</span> + 1 pour <span style="font-style:italic">p</span> ≥ 0 <br>
<span style="font-style:italic">A</span>(<span style="font-style:italic">n</span>, 0) = <span style="font-style:italic">A</span>(<span style="font-style:italic">n</span> − 1, 1) pour <span style="font-style:italic">n</span> ≥ 1 <br>
<span style="font-style:italic">A</span>(<span style="font-style:italic">n</span>, <span style="font-style:italic">p</span>) = <span style="font-style:italic">A</span>(<span style="font-style:italic">n</span> − 1, <span style="font-style:italic">A</span>(<span style="font-style:italic">n</span>, <span style="font-style:italic">p</span> − 1)) si <span style="font-style:italic">n</span> ≥ 1, <span style="font-style:italic">p</span> ≥ 1 <br>

</p><pre class="verbatim">let rec ack = function
 | (0,p) -&gt; p+1
 | (n,0) -&gt; ack (n-1, 1)
 | (n,p) -&gt; ack (n-1, ack (n, p-1))
</pre><p>La fonction d’Ackermann croît très rapidement, en particulier <span style="font-style:italic">n</span> → <span style="font-style:italic">A</span>(<span style="font-style:italic">n</span>, <span style="font-style:italic">n</span>) croît
plus rapidement que n’importe quelle fonction polynôme ou exponentielle.</p><p>Gödel a ainsi introduit un troisième critère permettant d’étendre le scope de définition des
fonctions numériques au-delà des fonctions récursives primitives. C’est le critère
de clôture par minimisation totale.</p><p>Nous dirons qu’un ensemble <span style="font-style:italic">E</span> de fonctions numériques est clos par minimisation si
pour tout <span style="font-style:italic">g</span> ∈ <span style="font-style:italic">E</span>, tel que pour chaque <span style="font-style:italic">n</span>, il existe <span style="font-style:italic">p</span> tel que <span style="font-style:italic">g</span>(<span style="font-style:italic">n</span>,<span style="font-style:italic">p</span>)=0, si on définit
<span style="font-style:italic">f</span> par
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>) = <span style="font-style:italic">min</span>{<span style="font-style:italic">p</span>∈ ℕ ; <span style="font-style:italic">g</span>(<span style="font-style:italic">n</span>,<span style="font-style:italic">p</span>) = 0   } </td></tr>
</table><p>
alors <span style="font-style:italic">f</span>∈ <span style="font-style:italic">E</span>. On notera <span style="font-style:italic">f</span> =µ <span style="font-style:italic">p</span> [<span style="font-style:italic">g</span>(.,<span style="font-style:italic">p</span>)=0].</p><p>Les <span style="font-style:italic">fonctions récursives</span> sont les éléments du plus petit ensemble de fonctions
numériques contenant les fonctions de base et clos par composition, récursion primitive et 
minimisation totale.</p>
<!--TOC section id="sec72" La machine de Turing-->
<h2 id="sec72" class="section">5.2 La machine de Turing</h2><!--SEC END --><p>
Une machine de Turing est un automate à  état (<span style="font-style:italic">state machine</span>) qui a la
capacité de lire puis d’enregistrer un caractère sur une bande de longueur
infinie. </p><p>La machine change d’état sur la base de trois éléments: l’état courant,
le caractère lu de la bande et une table externe de transition. La table de
transition est externe à  la bande et elle est statique.
L’action résultante est un changement potentiel d’état, une écriture de
caractère sur la bande et un déplacement à  droite ou à  gauche de la tête de
lecture.</p><p>Nous implémentons cela avec le concept de <span style="font-style:italic">box</span> présenté dans le chapitre
précédent. La lambda va encapsuler l’état courant, la position de la tête de
lecture, la bande et la table de transition.
La table de transition est modélisée par une a-liste d’a-listes.
La première a-liste permet de faire matcher l’état courant.
La seconde a-liste permet de faire matcher le caractère lu.
Ces deux informations combinées fournissent le triplet de sortie
<code class="verb">(état_suivant, caractère_écrit, direction)</code></p><pre class="verbatim">let matable = [ ("q0" , [ ("&gt;", ("q1", "X", "G")) ;
          ("&lt;", ("q0", "&lt;", "D")) ; 
          (" ", ("q2", " ", "G")) ;
          ("X", ("q0", "X", "D")) ]) ;
          ("q1" , [ ("&gt;", ("q1", "&gt;", "G")) ;
                    ("&lt;", ("q0", "X", "D")) ;
                    (" ", ("qf", "non", "G")) ;
                    ("X", ("q1", "X", "G")) ]) ;
          ("q2" , [ ("&gt;", ("q2", "&gt;", "G")) ;
                    ("&lt;", ("qf", "non", "G")) ;
                    (" ", ("qf", "oui", "G")) ;
                    ("X", ("q2", "X", "G")) ]) ;
      ] ;;
</pre><p>Cette table de transition va nous permettre de vérifier le bon parenthésage
d’une expression en entrée fournie sur la bande représentée par une liste 
<code class="verb">let mabande =   [" "; "&lt;"; "&gt;"; " "]</code></p><p>L’état <code class="verb">q0</code> va rechercher une parenthèse <code class="verb">&gt;</code> en allant vers la droite.</p><p>L’état <code class="verb">q1</code> va rechercher une parenthèse <code class="verb">&lt;</code> en allant vers la gauche.</p><p>L’état <code class="verb">q2</code> va rechercher une parenthèse <code class="verb">&gt;</code> en allant vers la gauche.</p><p>Les parenthèses matchées sont remplacées par le caractère <code class="verb">X</code>.
Le passage à  l’état final <code class="verb">qf</code> est accompagné par l’écriture <code class="verb">oui</code> ou
<code class="verb">non</code> sur la bande suivant si l’expression est ou non correctement parenthésée.</p><pre class="verbatim">
let make_turing table etat0 position0 bande0 =
 let etat = ref etat0 in
 let position = ref position0 in
 let bande = ref bande0 in
 let fct_transition state input = assoc input (assoc state table) in
 let lire () = nth !bande !position in
 let deplacer = function 
  | "G" -&gt; if (!position = 0) then (bande := " " :: !bande) else (position := !position - 1) 
    | "D" -&gt; 
    begin
    position := !position + 1 ;
    if ((lire ()) = " ") then (bande := !bande @ (" ":: []))
     end
  | _ -&gt; raise Erreur
 in
 let rec liste_tail liste pos =
   match pos with
   | 0 -&gt; liste
   | n -&gt; liste_tail (tl liste) (pos - 1)
  in
  let rec liste_tete liste pos =
   match pos with
   | 0 -&gt; []
   | n -&gt; (hd liste) :: liste_tete (tl liste) (pos - 1)
  in
 let ecrire symb =
 bande := (liste_tete !bande !position) @ (symb :: []) @ ( liste_tail (tl !bande) !position)
 in
  fun instruction -&gt;
  match instruction with
  | "executer" -&gt; 
   let (e, s, d) = fct_transition !etat (lire ()) in
      begin
        ecrire s ;
        deplacer d;
        etat := e ;
     if (!etat = "qf") then raise Final 
       end 
  | "reset" -&gt; begin etat := etat0 ; bande := bande0; position := position0 end
  | "affiche"  -&gt; 
      begin print_string "etat:" ; print_string !etat ; 
           print_string "  position:"; print_int !position ; 
        print_string "  lire:"; print_string (lire ()) ;
        print_string "  bande:  "; print_liste !bande
        end 
  | _ -&gt; raise Erreur
  
let executer_turing turing trace =
 let rec iterer () =
  turing "executer" ; if trace then turing "affiche"; iterer () 
 in
 begin
  turing "reset" ;
  try
   iterer () 
  with Final -&gt; turing "affiche"
  end 

</pre><p>Voici le résultat sur l’expression  &lt;&gt; 
</p><pre class="verbatim"># let turing_par = make_turing matable etatinit posinit  [" "; "&lt;"; "&gt;"; " "]  ;;
# executer_turing turing_par true ;;

etat:q0  position:2  lire:&gt;  bande:   &lt;&gt; 
etat:q1  position:1  lire:&lt;  bande:   &lt;X 
etat:q0  position:2  lire:X  bande:   XX 
etat:q0  position:3  lire:   bande:   XX  
etat:q2  position:2  lire:X  bande:   XX  
etat:q2  position:1  lire:X  bande:   XX  
etat:q2  position:0  lire:   bande:   XX  
etat:qf  position:0  lire:   bande:   ouiXX  
</pre><p>Et voici le résultat sur l’expression  &lt;&lt;&gt;&lt;&gt; 
</p><pre class="verbatim"># let turing_par = make_turing matable etatinit posinit  [" "; "&lt;"; "&lt;"; "&gt;"; "&lt;"; "&gt;"; " "] ;;
# executer_turing turing_par true ;;

etat:q0  position:2  lire:&lt;  bande:   &lt;&lt;&gt;&lt;&gt; 
etat:q0  position:3  lire:&gt;  bande:   &lt;&lt;&gt;&lt;&gt; 
etat:q1  position:2  lire:&lt;  bande:   &lt;&lt;X&lt;&gt; 
etat:q0  position:3  lire:X  bande:   &lt;XX&lt;&gt; 
etat:q0  position:4  lire:&lt;  bande:   &lt;XX&lt;&gt; 
etat:q0  position:5  lire:&gt;  bande:   &lt;XX&lt;&gt; 
etat:q1  position:4  lire:&lt;  bande:   &lt;XX&lt;X 
etat:q0  position:5  lire:X  bande:   &lt;XXXX 
etat:q0  position:6  lire:   bande:   &lt;XXXX  
etat:q2  position:5  lire:X  bande:   &lt;XXXX  
etat:q2  position:4  lire:X  bande:   &lt;XXXX  
etat:q2  position:3  lire:X  bande:   &lt;XXXX  
etat:q2  position:2  lire:X  bande:   &lt;XXXX  
etat:q2  position:1  lire:&lt;  bande:   &lt;XXXX  
etat:qf  position:0  lire:   bande:   nonXXXX  
</pre>
<!--TOC section id="sec73" La thèse de Church-->
<h2 id="sec73" class="section">5.3 La thèse de Church</h2><!--SEC END --><div class="theorem"><span style="font-weight:bold">Théorème ‍5</span> <em>
	Thèse de Church: toute fonction effectivement calculable est récursive.
</em></div><div class="theorem"><span style="font-weight:bold">Théorème ‍6</span> <em>
	Thèse forte de Church: si une fonction </em><span style="font-style:italic">f</span><em> est calculable par un algorithme, 
	alors celui-ci est effectivement transformable en une machine de Turing 
	calculant </em><span style="font-style:italic">f</span><em>
</em></div><div class="theorem"><span style="font-weight:bold">Théorème ‍7</span> <em>
Pour </em><span style="font-style:italic">f</span>:ℕ<sup><span style="font-style:italic">p</span></sup> → ℕ<em>, les propriétés </em>(<span style="font-style:italic">i</span>) <span style="font-style:italic">f</span><em> est </em>λ<em>-définissable et 
</em>(<span style="font-style:italic">ii</span>) <span style="font-style:italic">f</span><em> est récursive sont équivalentes.
</em></div>
<!--TOC chapter id="sec74" Annexes / Divers-->
<h1 id="sec74" class="chapter">Chapitre ‍6 Annexes / Divers</h1><!--SEC END -->
<!--TOC section id="sec75" Quelques fonctions sur les listes-->
<h2 id="sec75" class="section">6.1 Quelques fonctions sur les listes</h2><!--SEC END --><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-size:small">SCHEME</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-size:small">OCAML </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
(define (somme l)
 (if (null? l)
   0
   (+ (car l) (somme (cdr l)))))
   
</span></pre><span style="font-size:small">
</span></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
let rec somme l =
  match l with
  | [] -&gt; 0
  | hd::tl -&gt; hd + somme(tl)  
  
</span></pre><span style="font-size:small"> 
</span></div><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><pre class="verbatim"><span style="font-size:small">
f car (f car (... (f car acc)...))

(define (foldright f acc l)
 (if (null? l)
  acc
  (f (car l) (foldright f acc (cdr l)))))
</span></pre></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><pre class="verbatim"><span style="font-size:small">
f hd (f hd (... (f hd acc)...))

let rec foldright f acc l =
  match l with
  | [] -&gt; acc
  | hd::tl -&gt; f hd (foldright f acc tl)
  
</span></pre></div><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
f (... (f (f acc car) car)...) car)

(define (foldleft f acc l)
 (if (null? l)
  acc
  (foldleft f (f (car l) acc) (cdr l))))
  
</span></pre><span style="font-size:small">
</span></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
f (... (f (f acc hd) hd)...) hd)

let rec foldleft f acc l =
  match l with
  | [] -&gt; acc
  | hd::tl -&gt; foldleft f (f acc hd) tl
  
</span></pre><span style="font-size:small">
</span></div><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
(foldleft * 1 '(1 2 3 4))
-&gt; 24

</span></pre><span style="font-size:small">
</span></div></td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><div class="minipage"><span style="font-size:small">
</span><pre class="verbatim"><span style="font-size:small">
# foldleft ( * ) 1 [1;2;3;4] ;;
- : int = 24

</span></pre><span style="font-size:small">
</span></div><span style="font-size:small">  </span></td></tr>
</table>
<!--TOC section id="sec76" Les listes mutables-->
<h2 id="sec76" class="section">6.2 Les listes mutables</h2><!--SEC END --><p>En SCHEME, nous avons les fonctions <code class="verb">set-car!</code> et <code class="verb">set-cdr!</code> qui nous permettent de modifier physiquement
le car et le cdr d’un doublet.
Nous pouvons par exemple définir la liste circulaire <code class="verb">(a b c a b c ...)</code>
</p><pre class="verbatim">(define maliste (list 'a 'b 'c))
(set-cdr! (cddr maliste) maliste)
 maliste
 -&gt; #0= (a b c . #0#)
</pre><p>
L’affichage de la liste infine provient de l’interprète DrRacket.</p><p>Essayons de reproduire cela en OCAML
(de manière intuitive et sûrement très maladroite…)
</p><pre class="verbatim">
exception Listenulle
type liste = Nil | Cons of int ref * liste ref ;;

let set_car d v =
 match d with
 | Nil -&gt; raise Listenulle
 | Cons(car,cdr) -&gt; car:=v  ;;
 
let set_cdr d v =
 match d with
 | Nil -&gt; raise Listenulle
 | Cons(car,cdr) -&gt; cdr:=v ;;
 
let  cdr l =
 match l with
 | Nil -&gt; raise Listenulle
 | Cons(tete, reste) when !reste &lt;&gt; Nil -&gt; reste

let maliste = Cons(ref 1 , ref ( Cons (ref 2, ref ( Cons (ref 3, ref Nil))) ))
set_cdr (!cdr !(cdr maliste)) maliste ;;

# maliste;;
- : liste =
Cons ({contents = 1},
 {contents =
   Cons ({contents = 2},
    {contents =
      Cons ({contents = 3},
       {contents =
         Cons ({contents = 1},
          {contents =
            Cons ({contents = 2},
             {contents =
               Cons ({contents = 3},
                ...
                
</pre>
<!--TOC section id="sec77" Les listes infinies ou <span style="font-style:italic">streams</span>-->
<h2 id="sec77" class="section">6.3 Les listes infinies ou <span style="font-style:italic">streams</span></h2><!--SEC END --><p>	
Les <span style="font-style:italic">streams</span> sont des listes infinies.</p><p>Pour pouvoir les représenter, nous utilisons le fait que le corps d’une lambda n’est pas évalué, 
comme nous l’avons vu en λ-calcul avec la
stratégie de β-réduction faible.
Une lambda <code class="verb">fun()-&gt;2*2</code> D  <code class="verb">- : unit -&gt; int = &lt;fun&gt;</code> est en fait considérée 
comme une <span style="font-style:italic">valeur</span>. Seul son appel provoquera l’évaluation de la lambda
<code class="verb">(fun() -&gt; 2*2) ()</code> D   <code class="verb">- : int = 4</code></p><p>Un <span style="font-style:italic">stream</span> sera ainsi représenté comme une liste, mais dont le <code class="verb">cdr</code> ne pointera plus directement 
sur une liste, mais sera une fonction dont le corps sera la liste. L’évaluation du <code class="verb">cdr</code> est ainsi retardé.</p><pre class="verbatim">type 'a stream = Cons of 'a * (unit -&gt; 'a stream) ;;
let hd (Cons (h, _)) = h ;;
let tl (Cons (_, tf)) = tf () ;;

let rec from n = Cons (n, fun () -&gt; from (n+1));;
let entiers = from 0 ;;
let rec take n s =
  if n=0 then []
  else hd s :: take (n-1) (tl s) ;;

# take 30 entiers
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20;
 21; 22; 23; 24; 25; 26; 27; 28; 29]
</pre><p>Nous pouvons aussi modéliser la fraction continue représentant √<span style="text-decoration:overline">2</span> :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2</td></tr>
</table></td><td class="dcell"> = 1 + </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" ><table class="display"><tr style="vertical-align:top"><td class="dcell">2
+ </td><td class="dcell"><table class="display" style="width:100%;"><tr><td class="dcell" >1</td></tr>
<tr><td class="dcell" ><hr class="horizontal-rule"></td></tr>
<tr><td class="dcell" >...
</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Voici le code OCAML. Je n’ai pas trouvé manière plus élégante pour exprimer le stream.
</p><pre class="verbatim">let rec square2 iter =
  if (iter = 1) then 1.
  else
  1. +. ( 1. /. ( 1. +. square2 (iter - 1)))

let rec racine2cons n = Cons(square2 n, fun () -&gt; racine2cons (n+1))

let rec racine2stream = racine2cons 1
  in take 10 racine2stream ;;

- : float list =
[1.; 1.5; 1.4; 1.41666666666666674; 1.4137931034482758; 1.41428571428571437;
 1.41420118343195256; 1.41421568627450989; 1.41421319796954315;
 1.41421362489486957]
</pre><p>
Nous voyons la convergence très rapide de la fraction continue.</p><p>Cependant, le calcul OCAML est très inefficace, car chaque nouvel élément de la liste recalcule la totalité de la fraction continue
en passant par la fonction <code class="verb">square2 iter</code>. Si nous essayons par exemple de calculer les 10000 premiers éléments du stream, cela prend sur ma machine une
dizaine de seconde. </p><p>En utilisant le module <code class="verb">Lazy</code> d’OCAML, nous pouvons utiliser le mécanisme de <span style="font-style:italic">mémoisation</span>. Les valeurs du stream ne seront pas recalculées au 
2ème appel.
</p><pre class="verbatim">open Lazy ;;
let racine2_10000 = take 10000 racine2stream  (* environ 10 secondes à chaque appel *)

let racine2_10000_lazy = lazy (take 10000 racine2stream) ;;
let racine2_force = force racine2_10000_lazy ;; (* uniquement long au 1er appel *)
</pre>
<!--TOC section id="sec78" Le module Graphics d’OCAML, les fractales-->
<h2 id="sec78" class="section">6.4 Le module Graphics d’OCAML, les fractales</h2><!--SEC END --><p>Nous allons ici présenter tres brievement le module Graphics.
Je reprends le code de Xavier Leroy tiré de son livre <span style="font-style:italic">le langage CAML</span> [<a href="#caml">19</a>].</p><pre class="verbatim">open Graphics ;;

Graphics.open_graph "";;
Graphics.set_window_title "THE WINDOW" ;;

type  etat = { mutable x : float; mutable y : float; 
               mutable visee : float; mutable levee : bool };;
let crayon = { x = 0.0; y = 0.0; visee = 0.0; levee = false };; 
let fixe_crayon b = crayon.levee &lt;- b;;

let pi_sur_180 =let pi = 4.0 *. (atan 1.0) in pi /. 180.0 


let tourne angle = crayon.visee &lt;- (crayon.visee +. angle *. pi_sur_180) ;;

let zero_x = float_of_int ((size_x ()) / 2);;
let zero_y = float_of_int ((size_y ()) / 2);;

let vide_ecran () =
 set_color white;
 fill_rect 0 0 (size_x ()) (size_y ());
 set_color black;
 crayon.x &lt;- zero_x;
 crayon.y &lt;- zero_y;
 crayon.visee &lt;- 0.0;
 crayon.levee &lt;- false;
 moveto (round crayon.x) (round crayon.y);;


let avance d =
 let dx = d *. cos (crayon.visee)
 and dy = d *. sin (crayon.visee) in
 crayon.x &lt;- crayon.x +. dx;
 crayon.y &lt;- crayon.y +. dy;
 if crayon.levee then moveto (round crayon.x) (round crayon.y)
 else lineto (round crayon.x) (round crayon.y);;

let rec motif n c =
 if n = 0 then avance c
 else
  begin
   motif (n -1) (c /. 3.0);
   tourne 60.0;
   motif (n -1) (c /. 3.0);
   tourne (-120.0);
   motif (n -1) (c /. 3.0);
   tourne 60.0;
   motif (n -1) (c /. 3.0)
  end;;

let flocon n c =
  for i = 1 to 3 
   do 
     motif n c; tourne (-120.0)
   done;;

  flocon 1 100.0;  flocon 2 100.0;   flocon 3 100.0;  flocon 4 100.0; 
</pre><p><img src="document004.png">
<img src="document005.png">
<img src="document006.png">
<img src="document007.png"></p><blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
		<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6.1: Les côtes de la Bretagne</td></tr>
</table></div>
	<img src="document008.png">
<div class="center"><hr class="floatrule"></div></div></blockquote><p>Les objets fractales ont une propriété surprenante : ils ont une aire finie, mais un périmètre infini.
A l’itération <span style="font-style:italic">n</span>, le périmètre de notre flocon est de 3.(4/3)<sup><span style="font-style:italic">n</span></sup>. Et nous avons bien entendu 
lim<sub><span style="font-style:italic">n</span> → ∞</sub> 3.(4/3)<sup><span style="font-style:italic">n</span></sup> =∞ </p><p>La longueur des côtes de la Bretagne est-elle aussi infinie ?
<span style="font-style:italic">L’Atlantique ronge nos côtes.</span> [<a href="#vh">9</a>]</p>
<!--TOC subsubsection id="sec79" L’ensemble de Mandelbrot-->
<h4 id="sec79" class="subsubsection">L’ensemble de Mandelbrot</h4><!--SEC END --><p>
l’ensemble de Mandelbrot est une fractale définie comme l’ensemble des points <span style="font-style:italic">c</span> 
du plan complexe pour lesquels la suite des nombres complexes définie comme ci-dessous est 
<span style="font-weight:bold">bornée</span>.</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎧<br>
⎨<br>
⎩</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >	<span style="font-style:italic">z</span><sub>0</sub>=0</td></tr>
<tr><td style="text-align:left;white-space:nowrap" >	<span style="font-style:italic">z</span><sub><span style="font-style:italic">n</span>+1</sub>=<span style="font-style:italic">z</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup>+<span style="font-style:italic">c</span>
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
Voir le bon article <span style="font-family:monospace">https://fr.wikipedia.org/wiki/Ensemble_de_Mandelbrot</span></p><p>On montre que si la suite des modules des <span style="font-style:italic">z</span><sub><span style="font-style:italic">n</span></sub> est strictement supérieure à 2 pour un certain indice alors,
cette suite est croissante à partir de cet indice, et elle tend vers l’infini.
Donc notre test d’appartenance à l’ensemble s’arrêtera au-delà de la valeur 2.</p><p>Pour estimer la convergence, nous nous arrêterons à la valeur <span style="font-style:italic">z</span><sub>300</sub>.
Nous utilisons également l’hypothèse que l’ensemble de Mandelbrot se situe dans le plan complexe
(−2.00:0.50), (−1.25:1.25)
</p><pre class="verbatim">open Complex ;;   (* {re=2.; im=4.} *)

let appartient c =
 let rec loop n z =
  if (n &gt; 300) then true
  else if ((norm2 z) &gt; 4.) then false
     else loop (n+1) (add c (mul z z)) 
 in loop 0 c  

#load "/home/vincent/.opam/ocaml-base-compiler/lib/graphics/graphics.cma" ;;
#require "graphics" ;; 
open Graphics ;;
Graphics.open_graph " 500x200+0-0" ;;
Graphics.set_window_title "Mandelbrot" ;;
Graphics.set_color Graphics.blue;;

let mandelbrot () =
 for i = (-200) to 50
  do
    for j=(-125) to 125
   do
     if (appartient {re=((float_of_int i)/.100.); im=((float_of_int j)/.100.)}) 
     then plot (200+i) (200+j) 
   done
  done 
</pre><blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
		<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6.2: L’ensemble de Mandelbrot</td></tr>
</table></div>
	<img src="document009.png">
<div class="center"><hr class="floatrule"></div></div></blockquote>
<!--TOC section id="sec80" Utilisation de -->
<h2 id="sec80" class="section">6.5 Utilisation de </h2><!--SEC END --><p>
 est un langage créé par D. Knuth [<a href="#mf">10</a>]. Il permet le
design de nouvelles fontes de manière très élégante sous forme d’équations.
La programmation se fait principalement de manière déclarative.</p><p>Je me suis amusé ici à créer le symbole D que j’ai souvent
utilisé dans cet article, principalement dans la section sur le λ-calcul. </p><blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
		<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6.3: D </td></tr>
</table></div>
	<img src="document010.png">
<div class="center"><hr class="floatrule"></div></div></blockquote><p>
Voici le bout de code qui a permis de définir ce symbole:
</p><pre class="verbatim">%file name: beta.mf

beginchar("D",15pt#,10pt#,3pt#);
% proportion ligne vs triangle 3/4 1/4
prop:=3/4;

y1=h-d; y2=1/5h-d; y3=4/5h-d; 
y4=2/5h-d; y5=3/5h-d; y6=1/2h-d;  
y7=3/4h-d; y8=1/4h-d; y9=h/2-d;

x1=0; x2=1/5*prop*w; x3=2/5*prop*w;
x4=3/5*prop*w; x5=4/5*prop*w; x6=prop*w;
x7=x8=x6; x9=w;

pickup pencircle scaled 0.3pt;
draw z1{right}..tension 6..z2{right}..tension 5..z3{right}
     ..tension 4..z4{right}..tension 4..z5{right}..tension 3..z6;
draw z7--z8--z9--cycle; 
labels(range 1 thru 9);
endchar;
end
</pre><p>Nous avons également représenté notre fractale S avec le langage .
Cela s’écrit très facilement, car le langage de Knuth permet l’utilisation
de macros récursives.</p><pre class="verbatim">%file name: snow.mf
%mode_setup;
%shape for the character S

i:=1;

def dessine(expr debut, fin) =
z[i]=debut;
z[i+1]=1/3[debut, fin];
z[i+2]= (z[i+1]-z[i]) rotated 60 shifted z[i+1];
z[i+3] = 2/3[debut, fin] ;
z[i+4] = fin ;  
pickup pencircle scaled 0.1pt;
draw z[i]--z[i+1]--z[i+2]--z[i+3]--z[i+4];
i:=i+5;
enddef;

def motif (expr debut, fin, n) =
if (n=1):dessine(debut,fin) else: 
 motif(debut, 1/3[debut,fin], n-1) ;
 motif(1/3[debut,fin],
  (1/3[debut,fin] - debut) rotated 60 shifted (1/3[debut,fin]), n-1) ;
 motif((1/3[debut,fin] - debut) rotated 60 shifted (1/3[debut,fin]),
  (1/3[debut,fin] -debut) shifted (1/3[debut,fin]), n-1) ;
 motif((1/3[debut,fin] - debut) shifted (1/3[debut,fin]), fin, n-1) ;
fi;
enddef;

beginchar("S",15pt#,15pt#,5pt#); "The snowflake" ;
motif((0,0), (w/2,h),4);
motif((w/2,h), (w,0),4);
motif((w,0), (0,0),4);
endchar;
end
</pre><p>Voici le résultat:
</p><blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
		<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6.4: S </td></tr>
</table></div>
	<img src="document011.png">
<div class="center"><hr class="floatrule"></div></div></blockquote>
<!--TOC section id="sec81" The boxes-->
<h2 id="sec81" class="section">6.6 The boxes</h2><!--SEC END --><p>
Nous avons vu comment représenter un environnement comme une liste
d’associations avec des paires <code class="verb">variable.valeur</code>.
Une autre méthode est d’utiliser le principe de <span style="font-style:italic">box</span> qui encapsule la
valeur dans une lambda. La <span style="font-style:italic">box</span> est une lambda qui prend une valeur à  sa
création. Puis elle réagit à  deux messages qui permettent respectivement
d’afficher la valeur capturée ou de la modifier avec la procédure <code class="verb">set!</code></p><p>Voici l’implémentation en Scheme:
</p><pre class="verbatim">(define (box value)
  (lambda (msg)
    (case msg
      ("get" value)
      ("set" (lambda (new-value) (set! value new-value))))))

(define (make-box value)
  (box value))

(define maboite (make-box 4))
(maboite "get")
((maboite "set") 5)
</pre><p>En CAML, nous pouvons rédiger le code ci-dessous:
</p><pre class="verbatim">exception Erreur

let box value0 =
 let value = ref value0 in
 fun message -&gt;
  match message with
  | "get" -&gt; (fun any -&gt; print_int !value)
  | "set" -&gt; (fun newvalue -&gt; (value := newvalue ; print_int !value ))
  | "reset"-&gt; (fun any -&gt; (value := value0 ; print_int !value))
  | _ -&gt; raise Erreur
  
  
let maboite = box 5 ;;
(maboite "get") 0 ;;
(maboite "set") 1976 ;;
(maboite "get") 0 ;;
(maboite "reset") 0 ;;
</pre>
<!--TOC section id="sec82" Les modules OCAML. Modélisation d’un monoïde-->
<h2 id="sec82" class="section">6.7 Les modules OCAML. Modélisation d’un monoïde</h2><!--SEC END --><p>
Un monoïde est une structure algébrique qui possède une loi de composition
interne associative et un élément neutre.
Représentons cette structure en OCAML, en définissant un module.
Nous reprenons ici l’excellent article 
https://blog.derniercri.io/observons-une-premiere-structure-algebrique-appliquee-a-linformatique-le-monoide/
</p><pre class="verbatim">module type MONOID =
sig
type t
val ( &lt;+&gt; ) : t -&gt; t -&gt; t
val neutral : t 
end

module String_monoid : MONOID with type t = string  =
struct
type t = string
let ( &lt;+&gt; ) = (^)
let neutral = ""
end

String_monoid.("abc" &lt;+&gt; "def" &lt;+&gt; neutral)
-&gt; String_monoid.t = "abcdef" 
</pre><p>En algèbre, un morphisme (ou homomorphisme) est une application entre deux structures algébriques
de même espèce.</p><p>Pour les monoïdes, un morphisme est une application 
<span style="font-style:italic">f</span>:(<span style="font-style:italic">M</span>,*,<span style="font-style:italic">e</span>)—→ (<span style="font-style:italic">M</span>′,⋆ ,<span style="font-style:italic">e</span>′) , entre deux monoïdes  (<span style="font-style:italic">M</span>,*,<span style="font-style:italic">e</span>) et 
(<span style="font-style:italic">M</span>′,⋆ , <span style="font-style:italic">e</span>′) qui vérifie :
</p><ul class="itemize"><li class="li-itemize">
	∀ (<span style="font-style:italic">g</span>,<span style="font-style:italic">h</span>)∈ <span style="font-style:italic">M</span><sup>2</sup>, ‍<span style="font-style:italic">f</span>(<span style="font-style:italic">g</span>*<span style="font-style:italic">h</span>)=<span style="font-style:italic">f</span>(<span style="font-style:italic">g</span>)⋆ <span style="font-style:italic">f</span>(<span style="font-style:italic">h</span>)
	</li><li class="li-itemize"><span style="font-style:italic">f</span>(<span style="font-style:italic">e</span>)=<span style="font-style:italic">e</span>′
</li></ul><pre class="verbatim">#load "Str.cma"

let count  t =  split (regexp " ") t   |&gt; List.length ;;

let pageA = "Hello World "
let pageB = "Foo bar "
let pageC = "O Caml " ;;

count String_monoid.(pageA &lt;+&gt; pageB &lt;+&gt;  pageC) ;;
count(String_monoid.(pageA)) + count(String_monoid.(pageB)) + count(String_monoid.(pageC));;
</pre><p>
Nous avons ici utilisé l’opérateur <code class="verb">|&gt;</code> défini comme suit <code class="verb">let ( |&gt; ) x f = f x</code></p><p>Cette fonction <code class="verb">count</code> est ainsi un morphisme entre le monoïde <code class="verb">String_monoid</code> et 
le monoïde des entiers (avec + comme fonction de composition interne et 0
comme élément neutre)
</p>
<!--TOC section id="sec83" Machine Learning and Neural Networks-->
<h2 id="sec83" class="section">6.8 Machine Learning and Neural Networks</h2><!--SEC END -->
<!--TOC subsection id="sec84" Introduction-->
<h3 id="sec84" class="subsection">6.8.1 Introduction</h3><!--SEC END --><p>Nous implémentons en R un réseau de neurones réduit à sa plus simple expression.
Il n’aura que deux couches de neurones.
Le langage R est ici commode pour ses opérations natives sur les matrices.
Nous pourrons voir ensuite comme transposer ce code en OCAML.</p><p>Nous entraînerons notre NN sur la base du jeu de test MNIST.
Le "training set" contient 60000 exemples, et le "test set" 10000 exemples.
Nous pourrons nous documenter plus précisément avec l’excellent ouvrage de François Chollet [<a href="#deepR">5</a>].</p>
<!--TOC subsection id="sec85" Un peu de théorie-->
<h3 id="sec85" class="subsection">6.8.2 Un peu de théorie</h3><!--SEC END --><p>Soit les 150 observations suivantes représentées par la matrice <span style="font-style:italic">X</span><sub>150,784</sub> (ou tensor 2 dimensions) comprenant 150 lignes pour les 150 observations et 784 colonnes pour les 784 features des observations.</p><p>2 matrices de poids <span style="font-style:italic">W</span><sub>32,150</sub><sup>1</sup> et <span style="font-style:italic">W</span><sub>10,150</sub><sup>2</sup> sont utilisées.</p><ul class="itemize"><li class="li-itemize">
	1er layer de 32 neurones
	</li><li class="li-itemize">2nd layer de 10 neurones
</li></ul><p>La sortie <span style="font-style:italic">OUTPUT</span><sub>150,10</sub> est une matrice de 150 lignes avec les 10 colonnes représentant 
les 10 features que l’on cherche à reconnaître.</p><p>Voici le schéma simplifié du NN à 2 couches:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">X</span> —→ ⊗ <span style="font-style:italic">W</span><sup>1</sup> →  <span style="font-style:italic">Z</span><sup>1</sup> → σ → <span style="font-style:italic">LAYER</span><sup>1</sup> —→
⊗ <span style="font-style:italic">W</span><sup>2</sup> 
→ <span style="font-style:italic">Z</span><sup>2</sup> 
→ 
σ 
→ Ŷ 
&gt;&gt; <span style="font-style:italic">LOSS</span>(Ŷ, <span style="font-style:italic">Y</span>)
</td></tr>
</table>
<!--TOC subsection id="sec86" Calcul matriciel-->
<h3 id="sec86" class="subsection">6.8.3 Calcul matriciel</h3><!--SEC END --><p>Cela donne le calcul matriciel ci-dessous:
<span style="font-size:small">
</span></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">
     

</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">1,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">1,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">1,784</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">2,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">2,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">2,784</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">150,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">150,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">x</span></span><sub><span style="font-size:small">150,784</span></sub><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">
×
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">caml</span></span><span style="font-size:small">
</span><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">1,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">1,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">1,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">2,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">2,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">2,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">784,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">784,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">784,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">= 
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">
σ(
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,1</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,2</span></sub><sup><span style="font-size:small">1</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,32</span></sub><sup><span style="font-size:small">1</span></sup><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">
)
×
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">1,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">1,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">1,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">2,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">2,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">2,</span><span style="font-size:small"><span style="font-style:italic">n</span></span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">32,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">32,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">w</span></span><sub><span style="font-size:small">32,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">= 
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">
σ(
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">1,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">2,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,1</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,2</span></sub><sup><span style="font-size:small">2</span></sup></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">z</span></span><sub><span style="font-size:small">150,10</span></sub><sup><span style="font-size:small">2</span></sup><span style="font-size:small">
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">
)</span></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">=
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">1,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">1,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">1,10</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">2,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">2,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">2,10</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">150,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">150,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">150,10</span></sub><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
</table></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">
     

</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">LOSS</span></span><span style="font-size:small">(</span><span style="font-size:small"><span style="font-style:italic">Y</span></span><span style="font-size:small">, Ŷ)</span></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">= </span><span style="font-size:xx-large">∑</span><span style="font-size:small">(
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">1,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">1,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">1,10</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">2,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">2,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">2,10</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">150,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">150,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">ŷ</span><sub><span style="font-size:small">150,10</span></sub><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">
−
</span></td><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">⎛<br>
⎜<br>
⎜<br>
⎜<br>
⎝</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">1,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">1,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">1,10</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">2,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">2,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">2,10</span></sub><span style="font-size:small"> </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋱</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋮  </span></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">150,1</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">150,2</span></sub></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small">⋯</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">y</span></span><sub><span style="font-size:small">150,10</span></sub><span style="font-size:small"> 
</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">⎞<br>
⎟<br>
⎟<br>
⎟<br>
⎠</span></td></tr>
</table></td><td class="dcell"><span style="font-size:small">
)</span><sup><span style="font-size:small">2</span></sup><span style="font-size:small">
</span></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
</table></td></tr>
</table><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:small">
     

</span></td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-size:small"><span style="font-style:italic">Z</span></span><sub><span style="font-size:small">1</span></sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">= </span><span style="font-size:small"><span style="font-style:italic">X</span></span><span style="font-size:small">.</span><span style="font-size:small"><span style="font-style:italic">W</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small"> </span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">
</span><span style="font-size:small"><span style="font-style:italic">LAYER</span></span><sub><span style="font-size:small">1</span></sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">= σ (</span><span style="font-size:small"><span style="font-style:italic">Z</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small">) </span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">
</span><span style="font-size:small"><span style="font-style:italic">Z</span></span><sub><span style="font-size:small">2</span></sub></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">= </span><span style="font-size:small"><span style="font-style:italic">LAYER</span></span><sub><span style="font-size:small">1</span></sub><span style="font-size:small"> * </span><span style="font-size:small"><span style="font-style:italic">W</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small"> </span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">
Ŷ</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">= σ (</span><span style="font-size:small"><span style="font-style:italic">Z</span></span><sub><span style="font-size:small">2</span></sub><span style="font-size:small">) </span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">
</span><span style="font-size:small"><span style="font-style:italic">LOSS</span></span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">= (Ŷ −</span><span style="font-size:small"><span style="font-style:italic">Y</span></span><span style="font-size:small">)</span><sup><span style="font-size:small">2</span></sup><span style="font-size:small">  
</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:left;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td><td style="text-align:right;white-space:nowrap" ><span style="font-size:small">&nbsp;</span></td></tr>
</table></td></tr>
</table><p>Calculons la dérivée de la fonction <span style="font-style:italic">LOSS</span> en fonction de <span style="font-style:italic">W</span><sup>1</sup></p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">LOSS</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">W</span><sub>1</sub></td></tr>
</table></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">LOSS</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ Ŷ</td></tr>
</table></td><td class="dcell"> . </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ Ŷ</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">Z</span><sub>2</sub></td></tr>
</table></td><td class="dcell">. </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">Z</span><sub>2</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">LAYER</span><sub>1</sub> </td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">LAYER</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">Z</span><sub>1</sub> </td></tr>
</table></td><td class="dcell">. </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">Z</span><sub>1</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">W</span><sub>1</sub> </td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >= 2(Ŷ−<span style="font-style:italic">Y</span>) . σ <sup>′</sup>(<span style="font-style:italic">Z</span><sub>2</sub>) . <span style="font-style:italic">W</span><sub>2</sub> . σ <sup>′</sup>(<span style="font-style:italic">Z</span><sub>1</sub>). <span style="font-style:italic">X</span>
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>2(Ŷ−<span style="font-style:italic">Y</span>) est une matrice de dimension (150, 10)</p><p>σ <sup>′</sup>(<span style="font-style:italic">Z</span><sub>2</sub>) est une matrice de dimension (150,10)</p><p><span style="font-style:italic">W</span><sub>2</sub> est une matrice de dimension (32,10)</p><p>σ <sup>′</sup>(<span style="font-style:italic">Z</span><sub>1</sub>) est une matrice de dimension (150,32)</p><p><span style="font-style:italic">X</span> est une matrice de dimension (150,784)</p><p>Le calcul matriciel qui sera fait est <span style="font-style:italic">t</span>(<span style="font-style:italic">X</span>)* { (2(Ŷ−<span style="font-style:italic">Y</span>) . σ <sup>′</sup>(<span style="font-style:italic">Z</span><sup>2</sup>) * <span style="font-style:italic">t</span>(<span style="font-style:italic">W</span><sup>2</sup>). σ <sup>′</sup>(<span style="font-style:italic">Z</span><sup>1</sup>)}, où * est le produit matriciel et . le produit d’Hadamard.
Le résultat donne une matrice de dimension (784,32) qui est de même dimension que <span style="font-style:italic">W</span><sub>1</sub>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">t</span>(150,784)* {(150,10).(150,10)*<span style="font-style:italic">t</span>(32,10).(150,32))}</td><td style="text-align:left;white-space:nowrap" >= (784,150) * {(150,10)*(10,32).(150,32)}</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >= (784,150)*(150,32) </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >=(784,32)
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
<!--TOC subsection id="sec87" Fonctions d’activation-->
<h3 id="sec87" class="subsection">6.8.4 Fonctions d’activation</h3><!--SEC END --><p>Pour la fonction d’activation, ici appelée σ, nous utiliserons pour la première couche la fonction <span style="font-style:italic">relu</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">max</span>(<span style="font-style:italic">o</span>,<span style="font-style:italic">x</span>)</p><p>Pour la seconde couche, nous utiliserons la fonction sigmoid <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>)= 1/1+<span style="font-style:italic">e</span><sup>−<span style="font-style:italic">x</span></sup></p><blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6.5: La fonction sigmoid</td></tr>
</table></div>
<img src="document012.png">
<div class="center"><hr class="floatrule"></div></div></blockquote><p>Voici le code en R:</p><pre class="verbatim"># the activation function
sigmoid &lt;- function(x) {
 1.0 / (1.0 + exp(-x))
}

x=seq(0,10,0.1)
plot(x, sigmoid(x), type="l") 

# the derivative of the activation function
sigmoid_derivative &lt;- function(x) {
 sigmoid(x) * (1.0 - sigmoid(x))
}
</pre><p>Calculons la dérivée de la fonction <span style="font-style:italic">LOSS</span> en fonction de <span style="font-style:italic">W</span><sup>2</sup> </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">LOSS</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">W</span><sub>2</sub></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"> =</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">LOSS</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ Ŷ</td></tr>
</table></td><td class="dcell"> . </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ Ŷ</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">Z</span><sub>2</sub></td></tr>
</table></td><td class="dcell">. </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">Z</span><sub>2</sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">δ <span style="font-style:italic">W</span><sub>2</sub> </td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" ><span class="equationnumber">(1)</span></td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >= 2(Ŷ−<span style="font-style:italic">Y</span>) . σ <sup>′</sup>(<span style="font-style:italic">Z</span><sub>2</sub>) . <span style="font-style:italic">LAYER</span><sub>1</sub> 
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" ><span class="equationnumber">(2)</span></td></tr>
</table></td></tr>
</table><p>2(Ŷ−<span style="font-style:italic">Y</span>) est une matrice de dimension (150, 10)</p><p>σ <sup>′</sup>(<span style="font-style:italic">Z</span><sub>2</sub>) est une matrice de dimension (150,10)</p><p><span style="font-style:italic">LAYER</span><sub>1</sub> est une matrice de dimension (150,32)</p><p>Le calcul matriciel qui sera fait est <span style="font-style:italic">t</span>(<span style="font-style:italic">LAYER</span><sub>1</sub>)* (2(Ŷ−<span style="font-style:italic">Y</span>) . σ <sup>′</sup>(<span style="font-style:italic">Z</span><sub>2</sub>)), où * est le produit matriciel et . le produit d’Hadamard.
Le résultat donne une matrice de dimension (32,10) qui est de même dimension que <span style="font-style:italic">W</span><sub>2</sub>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">t</span>(150,32) * (150,10).(150.10) = (32,150)*(150,10)=(32,10)
</td></tr>
</table>
<!--TOC section id="sec88" Les nombres premiers. L’algorithme RSA-->
<h2 id="sec88" class="section">6.9 Les nombres premiers. L’algorithme RSA</h2><!--SEC END --><ul class="itemize"><li class="li-itemize">
	Le crible d’Erathostène (’Eratosjénhs) 
	</li><li class="li-itemize">Leur répartition
	</li><li class="li-itemize">Les nombres premiers jumeaux
	</li><li class="li-itemize">La constante de Brun 
	</li><li class="li-itemize">La fonction zêta
	</li><li class="li-itemize">Le produit eulérien et sa convergence avec la suite harmonique
	</li><li class="li-itemize">Le petit théorème de Fermat
	</li><li class="li-itemize">La fonction <span style="font-style:italic">indicatrice</span> d’Euler
	</li><li class="li-itemize">L’algorithme RSA
</li></ul>
<!--TOC subsubsection id="sec89" Le crible-->
<h4 id="sec89" class="subsubsection">Le crible</h4><!--SEC END --><pre class="verbatim">type 'a stream = Cons of 'a * (unit -&gt; 'a stream) ;;
let hd (Cons (h, _)) = h ;;
let tl (Cons (_, tf)) = tf () ;;

let rec take n s =
 if n=0 then []
 else hd s :: take (n-1) (tl s) 

let rec entiers x = Cons(x, fun() -&gt; entiers(x+1)) 

let rec filtre m (Cons(x,l)) =
 if x mod m = 0 then filtre m (l()) 
 else Cons(x, fun() -&gt; (filtre m (l()))) 

let rec crible (Cons(x,l)) = Cons(x, fun()-&gt; crible(filtre x (l())))

let premiers = crible(entiers 2) ;;
</pre><pre class="verbatim">utop # take 100 premiers ;;
- : int list =
[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71;
 73; 79; 83; 89; 97; 101; 103; 107; 109; 113; 127; 131; 137; 139; 149; 151;
 157; 163; 167; 173; 179; 181; 191; 193; 197; 199; 211; 223; 227; 229; 233;
 239; 241; 251; 257; 263; 269; 271; 277; 281; 283; 293; 307; 311; 313; 317;
 331; 337; 347; 349; 353; 359; 367; 373; 379; 383; 389; 397; 401; 409; 419;
 421; 431; 433; 439; 443; 449; 457; 461; 463; 467; 479; 487; 491; 499; 503;
 509; 521; 523; 541]
</pre>
<!--TOC subsubsection id="sec90" Le produit d’Euler aka le produit eulérien-->
<h4 id="sec90" class="subsubsection">Le produit d’Euler aka le produit eulérien</h4><!--SEC END --><p>
La fonction zêta est égale au produit eulérien
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ζ(<span style="font-style:italic">s</span>) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=1</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sup><span style="font-style:italic">s</span></sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1−<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub><sup>−<span style="font-style:italic">s</span></sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=1</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">s</span></sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub><sup><span style="font-style:italic">s</span></sup>−1</td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>Exemple pour <span style="font-style:italic">s</span>=1 avec la suite harmonique
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell"> +...</td></tr>
</table></td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">=  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> .</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">. (...) </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2.3.5.7.11.13.17.19...</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1.2.4.6.10.12.16.18...</td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>Démontrons cela
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ζ(1) = 1+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell"> +  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">8</td></tr>
</table></td><td class="dcell"> +... </td></tr>
</table><p>Divisons par 2
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">ζ(1)</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">8</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">10</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">12</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">14</td></tr>
</table></td><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">16</td></tr>
</table></td><td class="dcell">+... </td></tr>
</table><p>La différence de ces 2 équations donne:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">ζ(1).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) = 1 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">11</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">13</td></tr>
</table></td><td class="dcell">+ ... </td></tr>
</table><p>Divisons par 3
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">.(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">).ζ(1) = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">15</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">21</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">27</td></tr>
</table></td><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">33</td></tr>
</table></td><td class="dcell">+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">39</td></tr>
</table></td><td class="dcell">+... </td></tr>
</table><p>La différence donne:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">).ζ(1) = 1 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">11</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">13</td></tr>
</table></td><td class="dcell">+ ... </td></tr>
</table><p>Divisons par 5
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">.(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">).ζ(1) =    </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">25</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">35</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">55</td></tr>
</table></td><td class="dcell">+ ... </td></tr>
</table><p>La différence donne:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">).ζ(1) = 1 + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">11</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">13</td></tr>
</table></td><td class="dcell">+... </td></tr>
</table><p>Nous pouvons poursuivre sur le principe du crible d’Erathostène
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">…(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">).ζ(1) = 1 </td></tr>
</table><p>D’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >ζ(1)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">).(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">)…</td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ζ(1)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">…</td></tr>
</table></td></tr>
</table></td><td class="dcell"> 		</td></tr>
</table></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >ζ(1)</td><td style="text-align:center;white-space:nowrap" >=</td><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2.3.5.7.11.13.17.19...</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1.2.4.6.10.12.16.18...</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td></tr>
</table></td></tr>
</table><p>Le numérateur est le produit de l’ensemble des nombres premiers.
Le dénominateur est le produit de l’ensemble des nombres premiers moins 1.</p><p>Exemple pour <span style="font-style:italic">s</span>=2 avec la suite carrée
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">1+ </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">16</td></tr>
</table></td><td class="dcell"> + ...  =  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> .</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">25</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">49</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">. (...) </td></tr>
</table>
<!--TOC subsubsection id="sec91" Les nombres premiers jumeaux et la constante de Brun-->
<h4 id="sec91" class="subsubsection">Les nombres premiers jumeaux et la constante de Brun</h4><!--SEC END --><p>
La somme inverse des nombres premiers jumeaux. Il y en aurait une infinité. Cependant, cette somme
converge vers la constante de Brun.</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >   <span style="font-style:italic">Brun</span></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">) + (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">) + (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">11</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">13</td></tr>
</table></td><td class="dcell">) + (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">17</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">19</td></tr>
</table></td><td class="dcell">) + (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">29</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">31</td></tr>
</table></td><td class="dcell">) +  ...  </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">Brun</span></td><td style="text-align:left;white-space:nowrap" >≈ 1,90216
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><pre class="verbatim">let inverse_sum n s = 
  let rec aux n s acc =
  if n=0 then acc
 else aux (n-1) (tl s) (acc +. (1. /. (float_of_int (hd s))))
in aux n s 0. 

let rec jumeaux (Cons(x, l)) =
  let suivant = hd (l()) in
    if suivant - x =2 then  Cons(x, fun()-&gt; (Cons(suivant, fun()-&gt; (jumeaux (tl(l()))))))
    else jumeaux (l()) 

let jum = jumeaux premiers 

utop # take 100 jum ;;
- : int list =
[3; 5; 11; 13; 17; 19; 29; 31; 41; 43; 59; 61; 71; 73; 101; 103; 107; 109; 137;
 139; 149; 151; 179; 181; 191; 193; 197; 199; 227; 229; 239; 241; 269; 271;
 281; 283; 311; 313; 347; 349; 419; 421; 431; 433; 461; 463; 521; 523; 569;
 571; 599; 601; 617; 619; 641; 643; 659; 661; 809; 811; 821; 823; 827; 829;
 857; 859; 881; 883; 1019; 1021; 1031; 1033; 1049; 1051; 1061; 1063; 1091;
 1093; 1151; 1153; 1229; 1231; 1277; 1279; 1289; 1291; 1301; 1303; 1319; 1321;
 1427; 1429; 1451; 1453; 1481; 1483; 1487; 1489; 1607; 1609]
 
 # inverse_sum 20000 jum ;;
 - : float = 1.37118156832708848
 </pre><p>
Avec les 10000 premières paires, nous sommes encore loin de 1,90216…</p>
<!--TOC subsubsection id="sec92" Le petit théorème de Fermat-->
<h4 id="sec92" class="subsubsection">Le petit théorème de Fermat</h4><!--SEC END --><p>
Si <span style="font-style:italic">p</span> est premier et si <span style="font-style:italic">a</span> n’est pas un multiple de <span style="font-style:italic">p</span>, alors <span style="font-style:italic">a</span><sup><span style="font-style:italic">p</span>−1</sup>≡1 mod <span style="font-style:italic">p</span></p>
<!--TOC subsubsection id="sec93" Le théorème d’Euler-->
<h4 id="sec93" class="subsubsection">Le théorème d’Euler</h4><!--SEC END --><p>
L’indicatrice d’Euler est une fonction, qui à tout entier naturel <span style="font-style:italic">n</span> non nul associe
le nombre d’entiers compris entre 1 et <span style="font-style:italic">n</span> et premiers avec <span style="font-style:italic">n</span>. Cette fonction est nommée en anglais
<span style="font-style:italic">Euler’s totient function</span>
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >  ϕ</td><td style="text-align:center;white-space:nowrap" >:</td><td style="text-align:center;white-space:nowrap" >ℕ<sup>*</sup></td><td style="text-align:center;white-space:nowrap" >—→</td><td style="text-align:left;white-space:nowrap" >ℕ<sup>*</sup> </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">n</span></td><td style="text-align:center;white-space:nowrap" >⊢→</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">card</span>{ <span style="font-style:italic">m</span> ∈ ℕ<sup>*</sup>  ‍| ‍<span style="font-style:italic">m</span>≤ <span style="font-style:italic">n</span> ‍  et ‍<span style="font-style:italic">m</span> ‍<span style="font-style:italic">premier</span> ‍<span style="font-style:italic">avec</span> ‍<span style="font-style:italic">n</span> }
</td></tr>
</table></td></tr>
</table><p>Le théorème d’Euler nous dit que  <span style="font-style:italic">a</span><sup>ϕ (<span style="font-style:italic">n</span>)</sup> ≡ 1 mod <span style="font-style:italic">n</span> , si <span style="font-style:italic">a</span> est un entier premier à <span style="font-style:italic">n</span>.
C’est une généralisation du petit théorème de Fermat.</p>
<!--TOC subsubsection id="sec94" Le théorème de Bezout-->
<h4 id="sec94" class="subsubsection">Le théorème de Bezout</h4><!--SEC END --><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">∀ <span style="font-style:italic">x</span>,<span style="font-style:italic">y</span> ∈ ℕ, ∃ <span style="font-style:italic">u</span> , <span style="font-style:italic">v</span> ∈ ℤ <span style="font-style:italic">tel</span> <span style="font-style:italic">que</span> <span style="font-style:italic">ux</span>+<span style="font-style:italic">vy</span>=<span style="font-style:italic">pgcd</span>(<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) </td></tr>
</table>
<!--TOC subsubsection id="sec95" L’inverse modulaire-->
<h4 id="sec95" class="subsubsection">L’inverse modulaire</h4><!--SEC END --><p>
Avec <span style="font-style:italic">x</span> et <span style="font-style:italic">n</span> premiers entre eux, en prenant <span style="font-style:italic">u</span> et <span style="font-style:italic">v</span> dans ℤ tels que
<span style="font-style:italic">ux</span>+<span style="font-style:italic">vn</span>=1, on a : 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >  <span style="font-style:italic">u</span>.<span style="font-style:italic">x</span></td><td style="text-align:left;white-space:nowrap" >≡ 1  mod <span style="font-style:italic">n</span>  </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
<span style="font-style:italic">u</span></td><td style="text-align:left;white-space:nowrap" >≡ <span style="font-style:italic">x</span><sup>−1</sup> mod <span style="font-style:italic">n</span> 
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table>
<!--TOC subsubsection id="sec96" L’algorithme RSA-->
<h4 id="sec96" class="subsubsection">L’algorithme RSA</h4><!--SEC END --><p>Soient <span style="font-style:italic">p</span>&gt;1 et <span style="font-style:italic">q</span>&gt;1 deux nombres premiers distincts, <span style="font-style:italic">n</span>=<span style="font-style:italic">pq</span> leur produit,
<span style="font-style:italic">e</span> un nombre premier avec 
ϕ(<span style="font-style:italic">n</span>) = (<span style="font-style:italic">p</span>−1)(<span style="font-style:italic">q</span>−1) et <span style="font-style:italic">d</span> = <span style="font-style:italic">e</span><sup>−1</sup> mod(<span style="font-style:italic">p</span>−1)(<span style="font-style:italic">q</span>−1).</p><p>Pour tout entier positif <span style="font-style:italic">m</span>&lt;<span style="font-style:italic">n</span>, on a <span style="font-style:italic">m</span><sup><span style="font-style:italic">ed</span></sup> ≡ <span style="font-style:italic">m</span> mod <span style="font-style:italic">n</span></p><p>La clé publique est le couple <span style="font-style:italic">P</span>=(<span style="font-style:italic">n</span>,<span style="font-style:italic">e</span>),
la clé secrète est le couple <span style="font-style:italic">S</span>=(<span style="font-style:italic">n</span>,<span style="font-style:italic">d</span>).</p><p><span style="font-style:italic">Raisonnement:</span></p><p><span style="font-style:italic">ed</span>≡1 mod (<span style="font-style:italic">p</span>−1)(<span style="font-style:italic">q</span>−1), donc il existe <span style="font-style:italic">k</span> tel que <span style="font-style:italic">ed</span>=1+<span style="font-style:italic">k</span>(<span style="font-style:italic">p</span>−1)(<span style="font-style:italic">q</span>−1).</p><p>Si <span style="font-style:italic">m</span> n’est pas multiple de <span style="font-style:italic">p</span> ni de <span style="font-style:italic">q</span>, 
d’après le petit théorème de Fermat,
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr style="vertical-align:middle"><td class="dcell">⎧<br>
⎨<br>
⎩</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" >  <span style="font-style:italic">m</span><sup><span style="font-style:italic">ed</span></sup>= <span style="font-style:italic">m</span><sup>1+<span style="font-style:italic">k</span>(<span style="font-style:italic">p</span>−1)(<span style="font-style:italic">q</span>−1)</sup> = <span style="font-style:italic">m</span> (<span style="font-style:italic">m</span><sup><span style="font-style:italic">p</span>−1</sup>)<sup><span style="font-style:italic">k</span>(<span style="font-style:italic">q</span>−1)</sup> ≡ <span style="font-style:italic">m</span> mod <span style="font-style:italic">p</span> </td></tr>
<tr><td style="text-align:left;white-space:nowrap" > 
<span style="font-style:italic">m</span><sup><span style="font-style:italic">ed</span></sup>= <span style="font-style:italic">m</span><sup>1+<span style="font-style:italic">k</span>(<span style="font-style:italic">p</span>−1)(<span style="font-style:italic">q</span>−1)</sup> = <span style="font-style:italic">m</span> (<span style="font-style:italic">m</span><sup><span style="font-style:italic">q</span>−1</sup>)<sup><span style="font-style:italic">k</span>(<span style="font-style:italic">q</span>−1)</sup> ≡ <span style="font-style:italic">m</span> mod <span style="font-style:italic">q</span>
</td></tr>
</table></td></tr>
</table></td></tr>
</table><p>
et si <span style="font-style:italic">m</span> est un multiple de <span style="font-style:italic">p</span>, <span style="font-style:italic">m</span>≡0 mod <span style="font-style:italic">p</span> et <span style="font-style:italic">m</span><sup><span style="font-style:italic">ed</span></sup>≡0 mod <span style="font-style:italic">p</span> (de même avec <span style="font-style:italic">q</span>).</p><p>L’entier <span style="font-style:italic">u</span><sup><span style="font-style:italic">ed</span></sup>−<span style="font-style:italic">m</span> est donc un multiple de <span style="font-style:italic">p</span> et de <span style="font-style:italic">q</span>, qui sont premiers distincts, 
donc un multiple de leur produit <span style="font-style:italic">pq</span>=<span style="font-style:italic">n</span></p><p>Donc, pour tout entier <span style="font-style:italic">m</span>, <span style="font-style:italic">m</span><sup><span style="font-style:italic">ed</span></sup> ≡ <span style="font-style:italic">m</span> mod <span style="font-style:italic">n</span></p>
<!--TOC subsubsection id="sec97" Le code-->
<h4 id="sec97" class="subsubsection">Le code</h4><!--SEC END --><pre class="verbatim">open List
open Random 

let p = 61 and q = 53 ;;
let n = p*q ;;
let phi = (p-1)*(q-1) ;; (* phi=3233 *)
let m = 65 ;;

let rec pgcd a b =
  if b = 0 then a 
  else pgcd b (a mod b)

let rec calcule_e p q =
  let e = Random.int ((p-1)*(q-1))
    in if pgcd e ((p-1)*(q-1)) = 1 then e
      else calcule_e p q  

let rec euclide a b = 
  if b = 0 then ( a , 1 , 0 ) 
    else 
    begin
        let (d', u', v') = euclide b (a mod b)
        in (d', v', u' - (a / b) * v' )
    end

let calcule_d p q e =
    let(_, u ,_) = euclide e (( p-1)*(q-1)) in
      u mod ((p-1)*(q-1))

let rec pow a m = function
  | 0 -&gt; 1 mod m
  | 1 -&gt; a mod m
  | n -&gt; 
    let b = pow a m (n / 2) in
    b * b * (if n mod 2 = 0 then 1 else a) mod m
  ;;    

let e = calcule_e p q  ;;
let d = calcule_d p q e ;;

crypt (crypt m e n) d n;;

let factor n =
  let rec aux n k l =
    if n &lt; k/2 then l
    else if (n mod k) = 0 then aux (n/k) k (k::l)
    else if (k=2) then aux n 3 l 
    else aux n (k+2) l
in rev (aux n 2 [])
</pre>
<!--TOC section id="sec98" Approximation du nombre π -->
<h2 id="sec98" class="section">6.10 Approximation du nombre π </h2><!--SEC END --><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" >		Que</td><td style="text-align:center;white-space:nowrap" >j’</td><td style="text-align:center;white-space:nowrap" >aime</td><td style="text-align:center;white-space:nowrap" >à</td><td style="text-align:center;white-space:nowrap" >faire</td><td style="text-align:center;white-space:nowrap" >connaître</td><td style="text-align:center;white-space:nowrap" >ce</td><td style="text-align:center;white-space:nowrap" >nombre</td><td style="text-align:center;white-space:nowrap" >utile</td><td style="text-align:center;white-space:nowrap" >aux</td><td style="text-align:center;white-space:nowrap" >sages. </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >		3,</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >4</td><td style="text-align:center;white-space:nowrap" >1</td><td style="text-align:center;white-space:nowrap" >5</td><td style="text-align:center;white-space:nowrap" >9</td><td style="text-align:center;white-space:nowrap" >2</td><td style="text-align:center;white-space:nowrap" >6</td><td style="text-align:center;white-space:nowrap" >5</td><td style="text-align:center;white-space:nowrap" >3</td><td style="text-align:center;white-space:nowrap" >5 </td></tr>
<tr><td style="text-align:center;white-space:nowrap" >	</td></tr>
</table>	
</div><p>Cherchons à approcher π par cinq méthodes :
</p><ul class="itemize"><li class="li-itemize">
	La loi des grands nombres. 
	Nous faisons ici un tirage aléatoire de coordonnées (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) avec <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> compris entre −1 et 1.
	Il y a π chances sur 4 que le tirage tombe dans le cercle de rayon 1. 
		
	</li><li class="li-itemize">La série alternée de Leibniz 
	<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1</td></tr>
</table></td><td class="dcell"> −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td><td class="dcell"> − … = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell">  </td></tr>
</table>
	
	</li><li class="li-itemize">Le calcul numérique de l’intégrale 
	<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">x</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dx</span></td></tr>
</table>
	
	</li><li class="li-itemize">Le produit de Wallis 
	<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">π /2 = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2.2.4.4.6.6.8.8.10.10. ...</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1.3.3.5.5.7.7.9.9.11. ...</td></tr>
</table></td></tr>
</table>
	
	Ce produit s’écrira mieux sous la forme:
	<table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">( </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> ) . (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell"> ).(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">6</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">6</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell"> ).(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">8</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">8</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td><td class="dcell"> ) . ...  =  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=1</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span>.2<span style="font-style:italic">n</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">n</span>−1).(2<span style="font-style:italic">n</span>+1)</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=1</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4<span style="font-style:italic">n</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4<span style="font-style:italic">n</span><sup>2</sup>−1</td></tr>
</table></td></tr>
</table>
	
	</li><li class="li-itemize">Les périmètres des polygones réguliers inscrits et circonscrits au cercle 
	<blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
				shapes.geometric
		
			in 3,...,7
			[blue] (3,0) circle(1cm);
			[regular polygon, regular polygon sides=, minimum size=2cm, draw] at (3,0) ;
			= 28.45*2/cos(deg(3.14/ ); 
			[regular polygon, regular polygon sides=, minimum size=, draw] at (3,0) ;
			
	
		
		<div class="center"><hr class="floatrule"></div></div></blockquote>
	
</li></ul>
<!--TOC subsection id="sec99" La méthode des polygones-->
<h3 id="sec99" class="subsection">6.10.1 La méthode des polygones</h3><!--SEC END --><p>	
Pour calculer la valeur de π, il suffit de calculer pour <span style="font-style:italic">n</span> suffisament grand
les périmètres des polygones réguliers de <span style="font-style:italic">n</span> côtés inscrits et circonscrits à un cercle de diamètre
2<span style="font-style:italic">R</span>=1. 
Nous nous reférerons à l’excellent ouvrage [<a href="#gb">13</a>].
Cette approche est appelée en anglais <span style="font-style:italic">the method of exhaustion</span>.</p><p>Le périmètre du polygone inscrit sera nommé <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>. Le périmètre du polygone circonscrit
sera <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub>. Comme <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> &lt; 2π <span style="font-style:italic">R</span> &lt; <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub>, on aura <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> &lt; π &lt; <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub>.
Nous obtiendrons alors deux valeurs approchées de π, l’une par défaut, l’autre par excès.</p>
<!--TOC subsubsection id="sec100" Calcul de <span style="font-style:italic">p</span><sub>2<span style="font-style:italic">n</span></sub> en fonction de <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>-->
<h4 id="sec100" class="subsubsection">Calcul de <span style="font-style:italic">p</span><sub>2<span style="font-style:italic">n</span></sub> en fonction de <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></h4><!--SEC END --><p>Nous rappelons les deux définitions suivantes :
</p><div class="theorem"><span style="font-weight:bold">Définition ‍7</span> <em>
	Le rayon du polygone est le rayon du cercle circonscrit. 
</em></div><div class="theorem"><span style="font-weight:bold">Définition ‍8</span> <em>
	L’apothème du polygone est le rayon du cercle inscrit. 
</em></div><p>
Nous pouvons ainsi exprimer l’apothème en fonction du rayon par la formule <span style="font-style:italic">a</span> = <span style="font-style:italic">r</span> cos(π/<span style="font-style:italic">n</span>)  où
<span style="font-style:italic">n</span> est le nombre de côté du polygone.</p><p>Soit <span style="font-style:italic">AB</span> = <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> le côté du polygone régulier inscrit et <span style="font-style:italic">OH</span>=<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> son apothème. </p><p><span style="font-style:italic">C</span> est le milieu de l’arc <span style="font-style:italic">AB</span>. On a <span style="font-style:italic">AC</span>=<span style="font-style:italic">c</span><sub>2<span style="font-style:italic">n</span></sub> </p><blockquote class="figure"><div class="center"><div class="center"><hr class="floatrule"></div>
		
		(0,0) – (2,0) ;
		(0,0) – (-2,0) ;
		(0,0) circle (2) ;
	
		(45:2) node[right]<span style="font-style:italic">A</span> ;
		(-45:2) node[right]<span style="font-style:italic">B</span> ;
		(sqrt(2),0) node[below right]<span style="font-style:italic">H</span> ;<p>		(0,0) – (45:2) ;
		(-2,0) – (45:2) ;
		(2,0) – (45:2) ;
		(45:2) – (-45:2) node[near start] <span style="font-style:italic">c</span><sub>2<span style="font-style:italic">n</span></sub> ;
		(0,0) – (sqrt(2),0) node[midway, below] <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> ;
	
		(0,0) node[below]<span style="font-style:italic">O</span> ;
		(2,0) node[right]<span style="font-style:italic">C</span> ;
		(-2,0) node[left]<span style="font-style:italic">C</span>′ ;
	
	</p><div class="center"><hr class="floatrule"></div></div></blockquote><p>Dans le triangle rectangle <span style="font-style:italic">ACC</span>′ : </p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">AC</span><sup>2</sup></td><td style="text-align:left;white-space:nowrap" >= <span style="font-style:italic">CC</span>′.<span style="font-style:italic">CH</span> = <span style="font-style:italic">CC</span>′ (<span style="font-style:italic">OC</span> − <span style="font-style:italic">OH</span>) </td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
⇔  <span style="font-style:italic">c</span><sub>2<span style="font-style:italic">n</span></sub><sup>2</sup></td><td style="text-align:left;white-space:nowrap" >= 2<span style="font-style:italic">R</span> −(<span style="font-style:italic">R</span>−<span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>)
</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>Or
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">OH</span></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= </td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">OA</span>²−<span style="font-style:italic">AH</span>²</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
⇔  <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">R</span>²−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>Donc
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span><sub>2<span style="font-style:italic">n</span></sub><sup>2</sup> = <span style="font-style:italic">R</span> (2<span style="font-style:italic">R</span>−</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >4<span style="font-style:italic">R</span><sup>2</sup> − <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
</table></td><td class="dcell">) </td></tr>
</table><p>
Comme  <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>/<span style="font-style:italic">n</span> , on obtient :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sub>2<span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4<span style="font-style:italic">n</span><sup>2</sup></td></tr>
</table></td><td class="dcell">=<span style="font-style:italic">R</span>(2<span style="font-style:italic">R</span>−</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:2em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">4<span style="font-style:italic">R</span><sup>2</sup>−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell">) </td></tr>
</table><p>
Soit pour 2<span style="font-style:italic">R</span>=1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span class="lrbox framebox">
 p_2n^2 = 2n (n - √<span style="text-decoration:overline">n^2-p_n^2</span>) 
</span> </td></tr>
</table><p>En partant d’un carré inscrit (<span style="font-style:italic">n</span>=4), nous avons <span style="font-style:italic">c</span><sub>4</sub>=√<span style="text-decoration:overline">2</span>/2 et donc 
nous pouvons calculer les valeurs de <span style="font-style:italic">p</span><sub>8</sub>, <span style="font-style:italic">p</span><sub>16</sub>, <span style="font-style:italic">p</span><sub>32</sub>, …</p>
<!--TOC subsubsection id="sec101" Calcul de <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub> en fonction de <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>-->
<h4 id="sec101" class="subsubsection">Calcul de <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub> en fonction de <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></h4><!--SEC END --><p>
Les polygones inscrits et cirsconscrits étant deux polygones semblables, nous avons :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
⇔  <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> . </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">R</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
⇔  <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> . </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">R</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >4<span style="font-style:italic">R</span><sup>2</sup> − <span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
⇔  <span style="font-style:italic">p</span>′<sub><span style="font-style:italic">n</span></sub></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">nRp</span><sub><span style="font-style:italic">n</span></sub></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >4<span style="font-style:italic">n</span><sup>2</sup> <span style="font-style:italic">R</span><sup>2</sup> − <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> 
</td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>Soit pour 2<span style="font-style:italic">R</span>=1
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span class="lrbox framebox">
 p’_n = np_n/√<span style="text-decoration:overline">n^2-p_n^2</span> 
</span> </td></tr>
</table><p>	= 4; 
			 4 = 2*sqrt(2);
			 4 = * 4 / sqrt(^2 - 4^2) ;
			 8 = sqrt(2**(- sqrt(^2 - 4^2))) ;
			 = 8;
			 8 = * 8 / sqrt(^2 - 8^2) ;
			 16 = sqrt(2**(- sqrt(^2 - 8^2))) ;
			 = 16;
			 16 = * 16 / sqrt(^2 - 16^2) ;
			 32 = sqrt(2**(- sqrt(^2 - 16^2))) ;
			 = 32;
			 32 = * 32 / sqrt(^2 - 32^2) ;
			 64 = sqrt(2**(- sqrt(^2 - 32^2))) ;
			 = 64;
			 64 = * 64 / sqrt(^2 - 64^2) ;
							 
	[draw,text width=15cm] at(0,0)Les valeurs approchées de π par défaut, et par excès en fonction
	du nombre <span style="font-style:italic">n</span> de côtés :<br>
	  <span style="font-style:italic">n</span>=4 → 4 &lt; π &lt; 4  <br>
	  <span style="font-style:italic">n</span>=8 → 8 &lt; π &lt; 8  <br>
	  <span style="font-style:italic">n</span>=16 → 16 &lt; π &lt; 16  <br>
	  <span style="font-style:italic">n</span>=32 → 32 &lt; π &lt; 32  <br>
	  <span style="font-style:italic">n</span>=64 → 64 &lt; π &lt; 64  <br>
		 	  ;
</p><p><br>
<br>

Depuis la formule  <span style="font-style:italic">p</span><sub>2<span style="font-style:italic">n</span></sub><sup>2</sup> = 2<span style="font-style:italic">n</span> (<span style="font-style:italic">n</span> − √<span style="text-decoration:overline"><span style="font-style:italic">n</span></span><sup><span style="text-decoration:overline">2</span></sup><span style="text-decoration:overline">−</span><span style="text-decoration:overline"><span style="font-style:italic">p</span></span><sub><span style="text-decoration:overline"><span style="font-style:italic">n</span></span></sub><sup><span style="text-decoration:overline">2</span></sup>)  et sachant que <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">n</span>.<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub>, 
nous pouvons en déduire :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span><sub>2<span style="font-style:italic">n</span></sub> = </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:0em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2−</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >4−<span style="font-style:italic">c</span><sub><span style="font-style:italic">n</span></sub><sup>2</sup></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>Pour un carré de rayon 1, nous avons <span style="font-style:italic">c</span><sub>4</sub>=√<span style="text-decoration:overline">2</span>. Ainsi <span style="font-style:italic">c</span><sub>8</sub>= √<span style="text-decoration:overline">2−√</span><span style="text-decoration:overline">2</span></p><p>De même, <span style="font-style:italic">c</span><sub>16</sub>=√<span style="text-decoration:overline">2−√</span><span style="text-decoration:overline">2+√</span><span style="text-decoration:overline">2</span>  et <span style="font-style:italic">c</span><sub>32</sub>=√<span style="text-decoration:overline">2−√</span><span style="text-decoration:overline">2+√</span><span style="text-decoration:overline">2+√</span><span style="text-decoration:overline">2</span> </p><p>Comme formule générique, nous obtenons ainsi avec <span style="font-style:italic">n</span>−1 racines imbriquées :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">c</span><sub>2<sup><span style="font-style:italic">n</span></sup></sub>=</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:12em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2−</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:8em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2+</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:4em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2+</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:0em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2+…</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table><p>Quand <span style="font-style:italic">n</span> tend vers l’infini, le 2<sup><span style="font-style:italic">n</span></sup>-gone tend vers le cercle. D’où :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">2<sup><span style="font-style:italic">n</span></sup> </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:12em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2−</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:8em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2+</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:4em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2+</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:0em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">2+</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >2+…</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> → π <span style="font-style:italic">quand</span> <span style="font-style:italic">m</span> → ∞ </td></tr>
</table><p>Nous pourrons nous référer à [<a href="#wm">16</a>]</p>
<!--TOC subsection id="sec102" La série alternée de Leibniz-->
<h3 id="sec102" class="subsection">6.10.2 La série alternée de Leibniz</h3><!--SEC END --><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=0</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(−1)<sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span>+1</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1</td></tr>
</table></td><td class="dcell"> −</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">+</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td><td class="dcell"> − … = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td><td class="dcell">  </td></tr>
</table><p>Nous pouvons coder cette somme infinie en utilisant un type <span style="font-style:italic">stream</span>. </p><pre class="verbatim">type 'a stream = Cons of 'a * (unit -&gt; 'a stream) ;;
let hd (Cons (h, _)) = h ;;
let tl (Cons (_, tf)) = tf () ;;

let rec sum n s acc =
 if n=0 then acc
 else  sum (n-1) (tl s) (acc +. (hd s)) ;;

let rec take n s =
 if n=0 then []
 else hd s :: take (n-1) (tl s) ;;

let rec from i = Cons ((((-1.) ** i ) /. (2.*. i +. 1.)), fun () -&gt; from (i +. 1.)) ;;
let leibniz = from 0. ;;
</pre><p>Cette série est belle, mais paresseuse. Elle converge très lentement vers π/4. 
Prenons les cinq millions premières valeurs de notre stream <code class="verb">leibniz</code>.
</p><pre class="verbatim"># 4. *. sum 5000000 leibniz 0. ;;
- : float = 3.14159245358977968
</pre>
<!--TOC subsection id="sec103" La loi des grands nombres-->
<h3 id="sec103" class="subsection">6.10.3 La loi des grands nombres</h3><!--SEC END --><p>
Sur un tirage aléatoire de coordonnées (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) avec <span style="font-style:italic">x</span> et <span style="font-style:italic">y</span> compris entre −1 et 1,
il y a π chances sur 4 que le tirage tombe dans le cercle de rayon 1.
</p><div class="center">
<br>


	[dotted] (-1,0) – (1,0) ;
	[dotted] (0,-1) – (0,1) ;
	[red] (0,0) circle (1) ;
	(-1,-1) – (-1,1) – (1, 1) – (1,-1) –cycle;
	[text width=6cm] at(-4,0)comme un jeu de fléchettes…;

</div><p>Le résultat des tirages est stocké sur notre liste "infinie". Nous effectuons cinq millions de tirage qui nous
permettent d’obtenir une valeur approchée de π avec les deux premières décimales exactes.
</p><pre class="verbatim">let gen() = 
let x = if Random.bool () then Random.float 1. else (-. Random.float 1.) in
let y = if Random.bool () then Random.float 1. else (-. Random.float 1.) in
if (x ** 2. +. y ** 2. &lt;= 1.) then 1.0 else 0.0 ;;

let rec from i = Cons (gen(), fun () -&gt; from (i + 1)) ;;

let rec sum n s acc =
if n=0 then acc
else  sum (n-1) (tl s) (acc +. (hd s)) ;;
  
4. *. (sum 5000000  tirage 0. /. 5000000.) ;;
- : float = 3.142153
</pre>
<!--TOC subsection id="sec104" Le produit de Wallis-->
<h3 id="sec104" class="subsection">6.10.4 Le produit de Wallis</h3><!--SEC END --><p>
Pour introduire le produit infini de Wallis, nous partons du fait que tout polynome
de degré <span style="font-style:italic">n</span> s’écrivant <span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup> + <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span>−1</sup>+ … + <span style="font-style:italic">a</span><sub>1</sub> <span style="font-style:italic">x</span> + <span style="font-style:italic">a</span><sub>0</sub> peut se décomposer en :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">a</span><sub><span style="font-style:italic">n</span></sub>(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>1</sub>)(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub>2</sub>)…(<span style="font-style:italic">x</span>−<span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>)</td></tr>
</table><p>
Et en factorisant ce produit par <span style="font-style:italic">x</span><sub>1</sub>.<span style="font-style:italic">x</span><sub>2</sub>… <span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub>, nous pouvons écrire :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">f</span>(<span style="font-style:italic">x</span>) = <span style="font-style:italic">C</span> (1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>1</sub></td></tr>
</table></td><td class="dcell">)(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub>2</sub></td></tr>
</table></td><td class="dcell">)…(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sub><span style="font-style:italic">n</span></sub></td></tr>
</table></td><td class="dcell">) </td></tr>
</table><p> 
<span style="font-style:italic">C</span> est ici une constante égale à <span style="font-style:italic">a</span><sub>0</sub>, que nous avons calculé en posant <span style="font-style:italic">x</span>=0.</p><p>Euler aurait démontré que cette décomposition vraie pour les polynomes l’est également pour la fonction sin(<span style="font-style:italic">x</span>), et plus
particulièrement sin(π <span style="font-style:italic">x</span>). Nous avons sin(π <span style="font-style:italic">n</span>)=0 ∀ <span style="font-style:italic">n</span> ∈ ℤ
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">sin(π <span style="font-style:italic">x</span>) = π <span style="font-style:italic">x</span> (1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1<sup>2</sup></td></tr>
</table></td><td class="dcell">)(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2</sup></td></tr>
</table></td><td class="dcell">)(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3<sup>2</sup></td></tr>
</table></td><td class="dcell">)(1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4<sup>2</sup></td></tr>
</table></td><td class="dcell">)… </td></tr>
</table><p>
Et donc pour <span style="font-style:italic">x</span>=1/2, nous avons :
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">sin(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">) = 1 = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> (1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2</sup>.1<sup>2</sup></td></tr>
</table></td><td class="dcell">) (1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2</sup>.3<sup>2</sup></td></tr>
</table></td><td class="dcell">) (1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2</sup>.4<sup>2</sup></td></tr>
</table></td><td class="dcell">) … </td></tr>
</table><p>
Si nous écrivons 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">1−</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<sup>2</sup>.<span style="font-style:italic">n</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">n</span>−1)(2<span style="font-style:italic">n</span>+1)</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span>.2<span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Nous obtenons le produit de Wallis :</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> = ( </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">3</td></tr>
</table></td><td class="dcell"> ) . (</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell"> ).(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">6</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">5</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">6</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell"> ).(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">8</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">7</td></tr>
</table></td><td class="dcell">.</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">8</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">9</td></tr>
</table></td><td class="dcell"> ) . ...  =  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=1</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">2<span style="font-style:italic">n</span>.2<span style="font-style:italic">n</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">(2<span style="font-style:italic">n</span>−1).(2<span style="font-style:italic">n</span>+1)</td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∏</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>=1</td></tr>
</table></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">4<span style="font-style:italic">n</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4<span style="font-style:italic">n</span><sup>2</sup>−1</td></tr>
</table></td></tr>
</table><p>
	
</p><pre class="verbatim">let rec from i = Cons ((4. *. i**2. ) /. (4. *. i**2. -. 1.), fun () -&gt; from (i +. 1.)) ;;
let wallis = from 1. ;;

let rec mult n s acc =
 if n=0 then acc
 else  mult (n-1) (tl s) (acc *. (hd s)) ;;
</pre><p>
Le produit converge ici rapidement vers π /2. Nous multiplions les cinquantes premiers millions 
de notre liste infinie <code class="verb">wallis</code>.
</p><pre class="verbatim">utop # 
2. *. mult 5000000 wallis 1. ;;
- : float = 3.14159249652297845
</pre>
<!--TOC subsection id="sec105" L’intégrale ∫<sub>0</sub><sup>1</sup> 1/1+<span style="font-style:italic">x</span><sup>2</sup> <span style="font-style:italic">dx</span>-->
<h3 id="sec105" class="subsection">6.10.5 L’intégrale ∫<sub>0</sub><sup>1</sup> 1/1+<span style="font-style:italic">x</span><sup>2</sup> <span style="font-style:italic">dx</span></h3><!--SEC END --><p>

	[-&gt;] (-0.5, 0) – (1.5, 0) node[right] <span style="font-style:italic">x</span>;
	[-&gt;] (0, -0.5) – (0, 1.5) node[above] <span style="font-style:italic">y</span>;
	node[below left]0 ;
	(1,0) node[below]1 ;
	[domain=-0.5:1.5, smooth, variable=, blue] plot (, 1 /( 1 + ^2);
	[pattern=north east lines]
	 (0,0)
	 – (1,0)
	 – (1,0.5)
	 – plot [domain=0:1] (, 1 /( 1 + ^2))
	 – (0,1) 
	 – cycle;
	[text width=7cm] at(6,1)</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-size:xx-large">∫</span></td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:left">1</td></tr>
<tr><td class="dcell" style="text-align:left"><br>
<br>
</td></tr>
<tr><td class="dcell" style="text-align:left">0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">1+<span style="font-style:italic">x</span><sup>2</sup></td></tr>
</table></td><td class="dcell"> <span style="font-style:italic">dx</span>  = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">&nbsp;</td></tr>
<tr><td class="dcell" style="text-align:center">lim</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>→ ∞</td></tr>
</table></td><td class="dcell">  </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">1</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+(</td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">i</span></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span></td></tr>
</table></td><td class="dcell">)<sup>2</sup></td></tr>
</table></td></tr>
</table></td><td class="dcell"> = </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">π</td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">4</td></tr>
</table></td></tr>
</table><p>;
</p><pre class="verbatim">let f x = 1. /. (1. +. x**2.)

let rec somme n i acc =
  if i &gt; n then (1./. n) *. acc 
  else somme n (i +. 1.)  (acc +. (f (i /. n))) ;;

utop # 
 4. *. somme 900000000. 0. 0. ;;
 - : float = 3.14159265692298773
</pre>
<!--TOC section id="sec106" Poésies-->
<h2 id="sec106" class="section">6.11 Poésies</h2><!--SEC END --><blockquote class="verse">
	Un soir t’en souvient-il ? Nous voguions en silence ; <br>
	On n’entendait au loin, sur l’onde et sous les cieux, <br>
	Que le bruit des rameurs qui frappaient en cadence <br>
	Tes flots harmonieux. <br>
</blockquote><blockquote class="verse">
	Les feuilles mortes se ramassent à la pelle <br>
	Tu vois, je n’ai pas oublié... <br>
	Les feuilles mortes se ramassent à la pelle, <br>
	Les souvenirs et les regrets aussi <br>
</blockquote><blockquote class="verse">
	Agneau de Dieu, qui sauves les hommes, <br>
	Agneau de Dieu, qui nous comptes et nous nommes, <br>
	Agneau de Dieu, vois, prends pitié de ce que nous sommes. <br>
</blockquote>
<!--TOC section id="sec107" L’irrationalité de √<span style="text-decoration:overline">2</span>-->
<h2 id="sec107" class="section">6.12 L’irrationalité de √<span style="text-decoration:overline">2</span></h2><!--SEC END --><p>
[scale=2]
	[-&gt;] (0, 0) – (2, 0) node[right] <span style="font-style:italic">x</span>;
	(0, 0) – (1, 1) ;
	(0,0) node[below] 0 ;
	(1,0) node [below] 1 ;
	(0, 0) – (1, 0) ;
	(1, 1) – (1, 0) ;
	[dotted, -&gt;] (1,1) arc (45:0:1.41) node[below] √<span style="text-decoration:overline">2</span> ;
	(0.5,-0.05) – (0.5,0.05) ;
	(0.95,0.5) – (1.05,0.5) ;
	(0.9,0) – (0.9,0.1) –(0.9,0.1) – (1,0.1) ;
	</p><p>	[blue] (0,-1) – (1,-1) – node[below right] <span style="color:red"><span style="font-style:italic">A</span></span> = 2<sup>2</sup> = 4  (1,-2) – 
	 node[below] 1 (0.5, -2) – node[below] 1 (0,-2) – node[left] 1 (0, -1.5) – cycle ;
	[red] (0.5,-1) – node[right] <span style="color:red"><span style="font-style:italic">A</span></span> = √<span style="text-decoration:overline">2</span><sup>2</sup> = 2  (1,-1.5) – (0.5,-2) – 
	 node[above ] √<span style="text-decoration:overline">2</span> (0.,-1.5) – cycle ;</p><p>	[dotted] (0,-1.5) – (1,-1.5) ;
	[dotted] (0.5,-1) – (0.5,-2) ;</p><p>	[draw,text width=10cm] at(5.1,-0.5)<span style="font-weight:bold">Démonstration par l’absurde</span><br>
 <br>

	
	Considérons que √<span style="text-decoration:overline">2</span>=<span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> avec la fraction <span style="font-style:italic">a</span>/<span style="font-style:italic">b</span> étant réduite. <br>
 Alors, nous avons 2 = <span style="font-style:italic">a</span><sup>2</sup>/<span style="font-style:italic">b</span><sup>2</sup> ⇔ <span style="font-style:italic">a</span><sup>2</sup> = 2<span style="font-style:italic">b</span><sup>2</sup>  <br>
 Donc <span style="font-style:italic">a</span><sup>2</sup> est pair, et donc <span style="font-style:italic">a</span> est pair. Nous écrivons <span style="font-style:italic">a</span>=2<span style="font-style:italic">r</span>. <br>
 Cela donne (2<span style="font-style:italic">r</span>)<sup>2</sup> = 2<span style="font-style:italic">b</span><sup>2</sup> ⇔ 2<span style="font-style:italic">r</span><sup>2</sup> = <span style="font-style:italic">b</span><sup>2</sup>  <br>
 Donc <span style="font-style:italic">b</span><sup>2</sup> est pair, et donc <span style="font-style:italic">b</span> est pair. <br>
 Ainsi <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> sont pairs, ce qui contredit l’hypothèse initiale de la fraction réduite. <br>
	
	<br>

D √<span style="text-decoration:overline">2</span> n’est pas un nombre rationnel.		 
	;
</p>
<!--TOC section id="sec108" Démonstration non constructive-->
<h2 id="sec108" class="section">6.13 Démonstration non constructive</h2><!--SEC END --><p>
Démontrons qu’il existe deux irrationnels <span style="font-style:italic">a</span> et <span style="font-style:italic">b</span> tels que <span style="font-style:italic">a</span><sup><span style="font-style:italic">b</span></sup> soit rationnel.</p><p>Considérons √<span style="text-decoration:overline">3</span><sup>√<span style="text-decoration:overline">2</span></sup> </p><p>Si √<span style="text-decoration:overline">3</span><sup>√<span style="text-decoration:overline">2</span></sup> ∈ ℚ alors on pose <span style="font-style:italic">a</span> = √<span style="text-decoration:overline">3</span> et <span style="font-style:italic">b</span>= √<span style="text-decoration:overline">2</span></p><p>Sinon, on pose <span style="font-style:italic">a</span> = √<span style="text-decoration:overline">3</span><sup>√<span style="text-decoration:overline">2</span></sup> et <span style="font-style:italic">b</span>=√<span style="text-decoration:overline">3</span>, 
de sorte que  (√<span style="text-decoration:overline">3</span><sup>√<span style="text-decoration:overline">2</span></sup>)<sup>√<span style="text-decoration:overline">2</span></sup> = 3 ∈ ℚ </p><p>Mais laquelle des deux est la solution ?
Faut-il abandonner le principe du <span style="font-style:italic">tiers exlus</span> de nos démonstrations
mathématiques ?
</p>
<!--TOC section id="sec109" L’hyperbole <span style="font-style:italic">xy</span>=1-->
<h2 id="sec109" class="section">6.14 L’hyperbole <span style="font-style:italic">xy</span>=1</h2><!--SEC END --><p>

	[-&gt;] (-3, 0) – (3, 0) node[right] <span style="font-style:italic">x</span>;
	[-&gt;] (0, -3) – (0, 3) node[above] <span style="font-style:italic">y</span>;
	[domain=0.3:3, smooth, variable=, blue] plot (, 1 / );
	[domain=-3:-0.3, smooth, variable=, blue] plot (, 1 / );
	[red] (0.5,0) – (0.5,2) ;
	[red] (0,2) – (0.5,2) node [right] L’aire du rectangle rouge est égale à 1 ;
</p>
<!--TOC section id="sec110" L’exponentielle-->
<h2 id="sec110" class="section">6.15 L’exponentielle</h2><!--SEC END --><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" ><span style="font-style:italic">e</span><sup><span style="font-style:italic">x</span></sup></td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= 1 + <span style="font-style:italic">x</span> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>2</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">2</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>3</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">6</td></tr>
</table></td><td class="dcell"> + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup>4</sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center">24</td></tr>
</table></td><td class="dcell"> + … + </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">n</span></sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">n</span>!</td></tr>
</table></td><td class="dcell"> + … </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center">∞</td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-size:xx-large">∑</span></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>=0</td></tr>
</table></td><td class="dcell"> </td><td class="dcell"><table class="display"><tr><td class="dcell" style="text-align:center"><span style="font-style:italic">x</span><sup><span style="font-style:italic">k</span></sup></td></tr>
<tr><td class="hrule"></td></tr>
<tr><td class="dcell" style="text-align:center"><span style="font-style:italic">k</span>!</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><p>
Nous avons ainsi : <span style="font-style:italic">e</span>= 1+1+1/2+1/6 +1/24+ … + + 1/<span style="font-style:italic">n</span>! + …  <br>
Et également <span style="font-style:italic">e</span> = lim<sub><span style="font-style:italic">n</span> → ∞</sub> (1/1+<span style="font-style:italic">n</span>)<sup><span style="font-style:italic">n</span></sup> </p>
<!--TOC section id="sec111" Les fonctions sin1/<span style="font-style:italic">x</span> et <span style="font-style:italic">x</span> . sin1/<span style="font-style:italic">x</span> -->
<h2 id="sec111" class="section">6.16 Les fonctions sin1/<span style="font-style:italic">x</span> et <span style="font-style:italic">x</span> . sin1/<span style="font-style:italic">x</span> </h2><!--SEC END --><div class="center">
[scale =3]
	[-&gt;] (-0.2, 0) – (1, 0) node[right] <span style="font-style:italic">x</span>;
	[-&gt;] (0, -1) – (0, 1) node[above] sin1/<span style="font-style:italic">x</span>;
	[domain=0.01:1, samples=5000, smooth, variable=, blue] plot (, sin((1/)r));

   
[scale =3]
	[-&gt;] (-0.2, 0) – (1, 0) node[right] <span style="font-style:italic">x</span>;
	[-&gt;] (0, -1) – (0, 1) node[above] <span style="font-style:italic">x</span> . sin1/<span style="font-style:italic">x</span>;
	[domain=0.01:1, samples=5000, smooth, variable=, blue] plot (, * sin((1/)r));
[domain=0.01:1, smooth, variable=, red] plot (, );
[domain=0.01:1, smooth, variable=, red] plot (, -);

</div>
<!--TOC section id="sec112" Srivanasa Ramanujan-->
<h2 id="sec112" class="section">6.17 Srivanasa Ramanujan</h2><!--SEC END --><p>
Le mathématicien indien aurait découvert la très belle formule 
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">3 = </td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:8em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+2</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:4em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+3</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:0em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+4</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+…</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table><p>
Posons <span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>) = <span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>+2), et sachant que <span style="font-style:italic">n</span>(<span style="font-style:italic">n</span>+2) = <span style="font-style:italic">n</span> √<span style="text-decoration:overline">1+(</span><span style="text-decoration:overline"><span style="font-style:italic">n</span></span><span style="text-decoration:overline">+1)(</span><span style="text-decoration:overline"><span style="font-style:italic">n</span></span><span style="text-decoration:overline">+3)</span>, nous avons :</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">
     

</td><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >	<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>)</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= <span style="font-style:italic">n</span></td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>+1)</td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
	 	</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= <span style="font-style:italic">n</span></td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:0em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+(<span style="font-style:italic">n</span>+1)</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>+2)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td class="dcell"> </td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >
	 	</td><td style="text-align:left;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">= <span style="font-style:italic">n</span></td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:4em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+(<span style="font-style:italic">n</span>+1)</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:0em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1+(<span style="font-style:italic">n</span>+2)</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1+<span style="font-style:italic">f</span>(<span style="font-style:italic">n</span>+3)</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >&nbsp;</td><td style="text-align:right;white-space:nowrap" >&nbsp;</td></tr>
</table></td></tr>
</table><pre class="verbatim">let rec f n i =
 if i = 0 then 1.
 else n *. sqrt(1. +. (f (n +. 1.) (i-1)))

utop # f 1. 10 ;;
- : float = 2.99480026926620502
</pre><p>Nous pouvons définir la fonction d’affichage <code class="verb">f_latex</code> comme ci-dessous:
</p><pre class="verbatim">let rec f_latex n i =
  if i = 0 then "\\ldots"  
  else (string_of_int n)^ "\\sqrt{1 + " ^ (f_latex (n + 1) (i-1)) ^ "}" ;;

print_string (f_latex 1 10) ;; 
</pre><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">3 = 1</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:32em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:1;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 2</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:28em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 3</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:24em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 4</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:20em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 5</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:16em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 6</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:12em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 7</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:8em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 8</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:4em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 9</td><td class="dcell"><table style="border-spacing:0" class="cellpadding0"><tr><td ALIGN="right"><div CLASS="vertical-rule" STYLE="height:0em;"></div></td></tr>
<tr><td><span style="font-size:xx-large"><span style="font-size:150%">√</span></span></td></tr>
</table></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" ><table class="display"><tr style="vertical-align:middle"><td class="dcell">1 + 10</td><td class="dcell"><span style="font-size:x-large">√</span></td><td class="dcell"><table style="border:0;border-spacing:0;border-collapse:separate;" class="cellpadding0"><tr><td class="hrule"></td></tr>
<tr><td style="text-align:center;white-space:nowrap" >1 + …</td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table></td></tr>
</table>
<!--TOC section id="sec113" L’alphabet grec. Extraits du nouveau testament-->
<h2 id="sec113" class="section">6.18 L’alphabet grec. Extraits du nouveau testament</h2><!--SEC END --><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:center;white-space:nowrap" > α</td><td style="text-align:center;white-space:nowrap" >β</td><td style="text-align:center;white-space:nowrap" >γ</td><td style="text-align:center;white-space:nowrap" >δ</td><td style="text-align:center;white-space:nowrap" >є</td><td style="text-align:center;white-space:nowrap" >ζ</td><td style="text-align:center;white-space:nowrap" >η</td><td style="text-align:center;white-space:nowrap" >θ</td><td style="text-align:center;white-space:nowrap" >ι</td><td style="text-align:center;white-space:nowrap" >κ</td><td style="text-align:center;white-space:nowrap" >λ</td><td style="text-align:center;white-space:nowrap" >µ</td><td style="text-align:center;white-space:nowrap" >ν</td><td style="text-align:center;white-space:nowrap" >ξ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">o</span></td><td style="text-align:center;white-space:nowrap" >π</td><td style="text-align:center;white-space:nowrap" >ρ</td><td style="text-align:center;white-space:nowrap" >σ</td><td style="text-align:center;white-space:nowrap" >τ</td><td style="text-align:center;white-space:nowrap" > υ</td><td style="text-align:center;white-space:nowrap" >φ</td><td style="text-align:center;white-space:nowrap" >χ</td><td style="text-align:center;white-space:nowrap" >ψ</td><td style="text-align:center;white-space:nowrap" >ω </td></tr>
<tr><td style="text-align:center;white-space:nowrap" > <span style="font-style:italic">A</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">B</span></td><td style="text-align:center;white-space:nowrap" >Γ</td><td style="text-align:center;white-space:nowrap" >Δ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">E</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">Z</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">H</span></td><td style="text-align:center;white-space:nowrap" >Θ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">I</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">K</span></td><td style="text-align:center;white-space:nowrap" >Λ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">M</span></td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">N</span></td><td style="text-align:center;white-space:nowrap" >Ξ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">O</span></td><td style="text-align:center;white-space:nowrap" >Π</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">R</span></td><td style="text-align:center;white-space:nowrap" >Σ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">T</span></td><td style="text-align:center;white-space:nowrap" >Υ</td><td style="text-align:center;white-space:nowrap" >Φ</td><td style="text-align:center;white-space:nowrap" ><span style="font-style:italic">X</span></td><td style="text-align:center;white-space:nowrap" >Ψ</td><td style="text-align:center;white-space:nowrap" >Ω
</td></tr>
</table></td></tr>
</table><div class="center">

[line width=0.7mm, smooth, tension=1] plot coordinates(0,0) (1,-0.5) (2.1, 0) (2.5, 0.55) ;
[line width=0.7mm, smooth, tension=1] plot coordinates(0,0) (1,0.5) (2.1, 0) (2.5,-0.55) ;
node at (1.1,0) IQJUS ;
 
<br>
Ἰησοῦς Χριστὸς Θεοῦ Υἱὸς Σωτήρ 
</div><p><br>
<br>
</p><p>	
Ἐγὼ τὸ Ἄλφα καὶ τὸ Omega, ὁ πρῶτος καὶ ὁ ἔσχατος, ἡ ἀρχὴ καὶ τὸ τέλος</p><p>Ἄλλην παραβολὴν παρέθηκεν αὐτοῖς, λέγων, Ὁμοία ἐστὶν ἡ βασιλεία τῶν οὐρανῶν
κόκκῳ σινάπεως, ὃν λαβὼν ἄνθρωπος ἔσπειρεν ἐν τῷ ἀγρῷ αὐτοῦ:
ὃ μικρότερον μέν ἐστιν πάντων τῶν σπερμάτων: ὅταν δὲ αὐξηθῇ,
μεῖζον τῶν λαχάνων ἐστίν, καὶ γίνεται δένδρον, ὥστε ἐλθεῖν τὰ πετεινὰ τοῦ οὐρανοῦ 
καὶ κατασκηνοῦν ἐν τοῖς κλάδοις αὐτοῦ.</p><p>Eirene umin !
</p><!--TOC chapter id="sec114" Références-->
<h1 id="sec114" class="chapter">Références</h1><!--SEC END --><dl class="thebibliography"><dt class="dt-thebibliography">
<a id="genese">[1]</a></dt><dd class="dd-thebibliography">
<em>Livre de la Genèse, Gn 11, 1-9</em>.</dd><dt class="dt-thebibliography"><a id="ab">[2]</a></dt><dd class="dd-thebibliography">
Badiou Alain.
<em>Eloge des mathématiques</em>.
Flammarion, 2015.</dd><dt class="dt-thebibliography"><a id="baren">[3]</a></dt><dd class="dd-thebibliography">
Henk Barendregt.
<em>Lambda calculi with types</em>.</dd><dt class="dt-thebibliography"><a id="plisp">[4]</a></dt><dd class="dd-thebibliography">
Jacques Chazarain.
<em>Programmer avec Scheme: De la pratique </em><em>à</em><em> la th</em><em>é</em><em>orie</em>.
International Thomson Publ. France, 1996.</dd><dt class="dt-thebibliography"><a id="deepR">[5]</a></dt><dd class="dd-thebibliography">
Francois Chollet and JJ ‍Allaire.
Deep learning with r, 2018.</dd><dt class="dt-thebibliography"><a id="rewriting">[6]</a></dt><dd class="dd-thebibliography">
Baader Franz.
<em>Term Rewriting and All That</em>.
Cambridge University Press, 1998.</dd><dt class="dt-thebibliography"><a id="gide">[7]</a></dt><dd class="dd-thebibliography">
André Gide.
<em>Les faux monnayeurs</em>.</dd><dt class="dt-thebibliography"><a id="god">[8]</a></dt><dd class="dd-thebibliography">
Douglas ‍R Hofstadter et ‍al.
<em>G</em><em>ö</em><em>del, Escher, Bach: an eternal golden braid</em>, volume ‍13.
Basic books New York, 1979.</dd><dt class="dt-thebibliography"><a id="vh">[9]</a></dt><dd class="dd-thebibliography">
Victor Hugo.
<em>Les travailleurs de la mer</em>.</dd><dt class="dt-thebibliography"><a id="mf">[10]</a></dt><dd class="dd-thebibliography">
Donald Knuth.
<em>The  Book</em>.
Addison Wesley, 1992.</dd><dt class="dt-thebibliography"><a id="lalement">[11]</a></dt><dd class="dd-thebibliography">
René Lalement.
<em>Logique, r</em><em>é</em><em>duction, r</em><em>é</em><em>solution</em>.
1990.</dd><dt class="dt-thebibliography"><a id="lamport1994latex">[12]</a></dt><dd class="dd-thebibliography">
Leslie Lamport.
<em>L<sup>A</sup>T<sub>E</sub>X a document preparation system</em>.
Addison-wesley, 1994.</dd><dt class="dt-thebibliography"><a id="gb">[13]</a></dt><dd class="dd-thebibliography">
C. ‍Lebossé.
<em>Géométrie plane</em>.
Fernand Nathan, 1947.</dd><dt class="dt-thebibliography"><a id="poincare">[14]</a></dt><dd class="dd-thebibliography">
Henri Poincaré.
<em>La science et l’hypothèse</em>.
1902.</dd><dt class="dt-thebibliography"><a id="lisp">[15]</a></dt><dd class="dd-thebibliography">
Christian Queinnec.
<em>Lisp in small pieces</em>.
Cambridge University Press, 2003.</dd><dt class="dt-thebibliography"><a id="wm">[16]</a></dt><dd class="dd-thebibliography">
Courant Richard.
<em>What is Mathematics ?</em>
Oxford University Press, 1941.</dd><dt class="dt-thebibliography"><a id="WS">[17]</a></dt><dd class="dd-thebibliography">
William Shakespeare.
<em>Romeo and Juliet</em>.</dd><dt class="dt-thebibliography"><a id="reflective">[18]</a></dt><dd class="dd-thebibliography">
Daniel P. ‍Friedman Stanley ‍Jefferson.
<em>A Simple Reflective Interpreter</em>.
1992.</dd><dt class="dt-thebibliography"><a id="caml">[19]</a></dt><dd class="dd-thebibliography">
Pierre Weis and Xavier Leroy.
<em>Le langage Caml</em>.
Dunod, 1999.</dd></dl><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr class="horizontal-rule" style="height:2px"><blockquote class="quote"><em>Ce document a été traduit de L<sup>A</sup>T<sub>E</sub>X par </em><a href="http://hevea.inria.fr"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a></blockquote></body>
</html>
